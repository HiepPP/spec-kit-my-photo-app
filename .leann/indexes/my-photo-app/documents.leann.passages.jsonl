{"id": "0", "text": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Project Overview\n\nThis is a photo organizer application built with React, TypeScript, Tailwind CSS, and shadcn/ui components. The app organizes local photos into albums by capture date, with drag-and-drop reordering and ZIP export functionality. All data is stored locally using SQLite with no cloud dependencies.\n\n## Constitution and Development Principles\n\nThe project follows strict constitutional principles (see `.specify/memory/constitution.md`):\n\n- **React Component Architecture**: Functional components with hooks, single responsibility principle\n- **100% Test Coverage**: TDD enforced, tests written before implementation (NON-NEGOTIABLE)\n- **Accessibility First**: WCAG 2.1 AA compliance, ARIA labels, keyboard navigation\n- **Local SQLite Storage**: Offline-first, no external dependencies for data\n- **Modern React Ecosystem**: React 18+, TypeScript, Tailwind CSS, shadcn/ui components\n\n## Project Structure and Workflow\n\n### Spec-Kit Architecture\n\nThis project uses the Spec-Kit methodology for feature development:", "metadata": {}}
{"id": "1", "text": "- **React Component Architecture**: Functional components with hooks, single responsibility principle\n- **100% Test Coverage**: TDD enforced, tests written before implementation (NON-NEGOTIABLE)\n- **Accessibility First**: WCAG 2.1 AA compliance, ARIA labels, keyboard navigation\n- **Local SQLite Storage**: Offline-first, no external dependencies for data\n- **Modern React Ecosystem**: React 18+, TypeScript, Tailwind CSS, shadcn/ui components\n\n## Project Structure and Workflow\n\n### Spec-Kit Architecture\n\nThis project uses the Spec-Kit methodology for feature development:\n\n1. `/specify` - Create feature specifications in `specs/###-feature-name/spec.md`\n2. `/plan` - Generate implementation plans in `specs/###-feature-name/plan.md`\n3. `/tasks` - Create task lists in `specs/###-feature-name/tasks.md`\n4. Implementation follows the constitutional principles\n\n### Key Directories\n\n- `.specify/` - Templates, scripts, and governance documents\n- `specs/` - Feature specifications and implementation plans\n- `.claude/` - Claude Code command definitions\n\n### Essential Scripts", "metadata": {}}
{"id": "2", "text": "1. `/specify` - Create feature specifications in `specs/###-feature-name/spec.md`\n2. `/plan` - Generate implementation plans in `specs/###-feature-name/plan.md`\n3. `/tasks` - Create task lists in `specs/###-feature-name/tasks.md`\n4. Implementation follows the constitutional principles\n\n### Key Directories\n\n- `.specify/` - Templates, scripts, and governance documents\n- `specs/` - Feature specifications and implementation plans\n- `.claude/` - Claude Code command definitions\n\n### Essential Scripts\n\n- `.specify/scripts/bash/create-new-feature.sh` - Initialize new feature branches and specs\n- `.specify/scripts/bash/update-agent-context.sh claude` - Update this CLAUDE.md file\n\n## Technology Stack\n\n### Core Dependencies\n\n- **Frontend**: React.js 18+ with TypeScript\n- **Styling**: Tailwind CSS with shadcn/ui component library\n- **Build**: Vite for development and production builds\n- **Database**: SQLite for local storage\n- **Testing**: Jest/Vitest with React Testing Library\n- **State Management**: React hooks (useState, useReducer) and Context API", "metadata": {}}
{"id": "3", "text": "- `.specify/scripts/bash/create-new-feature.sh` - Initialize new feature branches and specs\n- `.specify/scripts/bash/update-agent-context.sh claude` - Update this CLAUDE.md file\n\n## Technology Stack\n\n### Core Dependencies\n\n- **Frontend**: React.js 18+ with TypeScript\n- **Styling**: Tailwind CSS with shadcn/ui component library\n- **Build**: Vite for development and production builds\n- **Database**: SQLite for local storage\n- **Testing**: Jest/Vitest with React Testing Library\n- **State Management**: React hooks (useState, useReducer) and Context API\n\n### Development Commands\n\nSince this is a new project without package.json yet, these will be established during implementation:\n\n- Build: `npm run build` (to be configured with Vite)\n- Test: `npm test` (to be configured with Vitest)\n- Lint: `npm run lint` (to be configured)\n- Dev server: `npm run dev` (to be configured with Vite)\n\n## Constitutional Compliance\n\n### Test-Driven Development", "metadata": {}}
{"id": "4", "text": "### Development Commands\n\nSince this is a new project without package.json yet, these will be established during implementation:\n\n- Build: `npm run build` (to be configured with Vite)\n- Test: `npm test` (to be configured with Vitest)\n- Lint: `npm run lint` (to be configured)\n- Dev server: `npm run dev` (to be configured with Vite)\n\n## Constitutional Compliance\n\n### Test-Driven Development\n\n- ALWAYS write failing tests before implementation\n- Use Red-Green-Refactor cycle\n- 100% test coverage is mandatory - no exceptions\n- Tests must cover all functional requirements from specifications\n\n### Component Development\n\n- Start with shadcn/ui components when possible\n- Follow single responsibility principle\n- Use TypeScript for all components\n- Implement proper prop interfaces\n- Create custom hooks for shared logic\n\n### Accessibility Requirements\n\n- Include ARIA labels on all interactive elements\n- Ensure keyboard navigation works\n- Test with screen readers\n- Follow semantic HTML principles\n- Validate against WCAG 2.1 AA standards\n\n### Local Storage Strategy", "metadata": {}}
{"id": "5", "text": "### Component Development\n\n- Start with shadcn/ui components when possible\n- Follow single responsibility principle\n- Use TypeScript for all components\n- Implement proper prop interfaces\n- Create custom hooks for shared logic\n\n### Accessibility Requirements\n\n- Include ARIA labels on all interactive elements\n- Ensure keyboard navigation works\n- Test with screen readers\n- Follow semantic HTML principles\n- Validate against WCAG 2.1 AA standards\n\n### Local Storage Strategy\n\n- Use SQLite for all data persistence\n- No cloud storage or external APIs for data\n- Implement data export/import capabilities\n- Ensure offline functionality\n\n## Current Feature\n\n**Active Feature**: Photo Organizer App (`001-build-a-photo`)\n\n- **Specification**: `specs/001-build-a-photo/spec.md`\n- **Status**: Specification complete, ready for planning phase\n- **Key Requirements**: Upload photos, auto-group by date, drag-and-drop albums, tile view, zoom, ZIP export\n\nNext step: Run `/plan` command to create implementation plan.", "metadata": {}}
{"id": "6", "text": "/**\n * Component Props Contracts\n * Defines prop interfaces for all React components\n */\n\nimport { Photo, Album, UploadSession } from './photo-service';\n\n// Base component props\ninterface BaseComponentProps {\n  className?: string;\n  'data-testid'?: string;\n}\n\n// Album Grid Component\nexport interface AlbumGridProps extends BaseComponentProps {\n  albums: Album[];\n  onAlbumClick: (albumId: number) => void;\n  onAlbumReorder: (albumId: number, newOrder: number) => void;\n  onAlbumDelete?: (albumId: number) => void;\n  loading?: boolean;\n}\n\n// Album Tile Component\nexport interface AlbumTileProps extends BaseComponentProps {\n  album: Album;\n  thumbnailSrc?: string;\n  onClick: () => void;\n  onDelete?: () => void;\n  isDragging?: boolean;\n  dragHandleProps?: any;\n}", "metadata": {}}
{"id": "7", "text": "// Album Tile Component\nexport interface AlbumTileProps extends BaseComponentProps {\n  album: Album;\n  thumbnailSrc?: string;\n  onClick: () => void;\n  onDelete?: () => void;\n  isDragging?: boolean;\n  dragHandleProps?: any;\n}\n\n// Photo Tile View Component\nexport interface PhotoTileViewProps extends BaseComponentProps {\n  photos: Photo[];\n  onPhotoClick: (photoId: number) => void;\n  onPhotoDelete?: (photoId: number) => void;\n  loading?: boolean;\n  selectedPhotoId?: number;\n}\n\n// Individual Photo Tile Component\nexport interface PhotoTileProps extends BaseComponentProps {\n  photo: Photo;\n  thumbnailSrc: string;\n  onClick: () => void;\n  onDelete?: () => void;\n  isSelected?: boolean;\n}", "metadata": {}}
{"id": "8", "text": "// Photo Tile View Component\nexport interface PhotoTileViewProps extends BaseComponentProps {\n  photos: Photo[];\n  onPhotoClick: (photoId: number) => void;\n  onPhotoDelete?: (photoId: number) => void;\n  loading?: boolean;\n  selectedPhotoId?: number;\n}\n\n// Individual Photo Tile Component\nexport interface PhotoTileProps extends BaseComponentProps {\n  photo: Photo;\n  thumbnailSrc: string;\n  onClick: () => void;\n  onDelete?: () => void;\n  isSelected?: boolean;\n}\n\n// Zoom Modal Component\nexport interface ZoomModalProps extends BaseComponentProps {\n  isOpen: boolean;\n  onClose: () => void;\n  photo: Photo | null;\n  photos: Photo[];\n  currentIndex: number;\n  onNext: () => void;\n  onPrevious: () => void;\n  onDelete?: (photoId: number) => void;\n}", "metadata": {}}
{"id": "9", "text": "// Individual Photo Tile Component\nexport interface PhotoTileProps extends BaseComponentProps {\n  photo: Photo;\n  thumbnailSrc: string;\n  onClick: () => void;\n  onDelete?: () => void;\n  isSelected?: boolean;\n}\n\n// Zoom Modal Component\nexport interface ZoomModalProps extends BaseComponentProps {\n  isOpen: boolean;\n  onClose: () => void;\n  photo: Photo | null;\n  photos: Photo[];\n  currentIndex: number;\n  onNext: () => void;\n  onPrevious: () => void;\n  onDelete?: (photoId: number) => void;\n}\n\n// Upload Dropzone Component\nexport interface UploadDropzoneProps extends BaseComponentProps {\n  onFilesSelected: (files: FileList) => void;\n  uploadSession?: UploadSession;\n  acceptedFileTypes?: string[];\n  maxFileSize?: number;\n  isUploading?: boolean;\n}\n\n// Upload Progress Component\nexport interface UploadProgressProps extends BaseComponentProps {\n  session: UploadSession;\n  onCancel?: () => void;\n  showDetails?: boolean;\n}", "metadata": {}}
{"id": "10", "text": "// Upload Dropzone Component\nexport interface UploadDropzoneProps extends BaseComponentProps {\n  onFilesSelected: (files: FileList) => void;\n  uploadSession?: UploadSession;\n  acceptedFileTypes?: string[];\n  maxFileSize?: number;\n  isUploading?: boolean;\n}\n\n// Upload Progress Component\nexport interface UploadProgressProps extends BaseComponentProps {\n  session: UploadSession;\n  onCancel?: () => void;\n  showDetails?: boolean;\n}\n\n// Navigation Component\nexport interface NavigationProps extends BaseComponentProps {\n  currentView: 'albums' | 'photos';\n  albumName?: string;\n  onBackToAlbums?: () => void;\n  onExportAlbum?: () => void;\n  canExport?: boolean;\n}\n\n// Search Component (future)\nexport interface SearchProps extends BaseComponentProps {\n  onSearch: (query: string) => void;\n  placeholder?: string;\n  suggestions?: string[];\n}", "metadata": {}}
{"id": "11", "text": "// Navigation Component\nexport interface NavigationProps extends BaseComponentProps {\n  currentView: 'albums' | 'photos';\n  albumName?: string;\n  onBackToAlbums?: () => void;\n  onExportAlbum?: () => void;\n  canExport?: boolean;\n}\n\n// Search Component (future)\nexport interface SearchProps extends BaseComponentProps {\n  onSearch: (query: string) => void;\n  placeholder?: string;\n  suggestions?: string[];\n}\n\n// Accessibility props for complex interactions\nexport interface AccessibilityProps {\n  'aria-label'?: string;\n  'aria-labelledby'?: string;\n  'aria-describedby'?: string;\n  role?: string;\n  tabIndex?: number;\n}\n\n// Drag and Drop props\nexport interface DraggableProps extends AccessibilityProps {\n  draggable: boolean;\n  onDragStart: (event: React.DragEvent) => void;\n  onDragEnd: (event: React.DragEvent) => void;\n}", "metadata": {}}
{"id": "12", "text": "// Accessibility props for complex interactions\nexport interface AccessibilityProps {\n  'aria-label'?: string;\n  'aria-labelledby'?: string;\n  'aria-describedby'?: string;\n  role?: string;\n  tabIndex?: number;\n}\n\n// Drag and Drop props\nexport interface DraggableProps extends AccessibilityProps {\n  draggable: boolean;\n  onDragStart: (event: React.DragEvent) => void;\n  onDragEnd: (event: React.DragEvent) => void;\n}\n\nexport interface DroppableProps extends AccessibilityProps {\n  onDragOver: (event: React.DragEvent) => void;\n  onDrop: (event: React.DragEvent) => void;\n  onDragEnter: (event: React.DragEvent) => void;\n  onDragLeave: (event: React.DragEvent) => void;\n}", "metadata": {}}
{"id": "13", "text": "export interface DroppableProps extends AccessibilityProps {\n  onDragOver: (event: React.DragEvent) => void;\n  onDrop: (event: React.DragEvent) => void;\n  onDragEnter: (event: React.DragEvent) => void;\n  onDragLeave: (event: React.DragEvent) => void;\n}\n\n// Event handler types\nexport type PhotoEventHandler = (photoId: number) => void;\nexport type AlbumEventHandler = (albumId: number) => void;\nexport type FileSelectHandler = (files: FileList) => void;\nexport type OrderChangeHandler = (itemId: number, newOrder: number) => void;\n\n// Component state types\nexport interface ViewState {\n  currentView: 'albums' | 'photos';\n  selectedAlbumId?: number;\n  selectedPhotoId?: number;\n  isZoomModalOpen: boolean;\n}\n\nexport interface LoadingState {\n  albums: boolean;\n  photos: boolean;\n  upload: boolean;\n  export: boolean;\n}", "metadata": {}}
{"id": "14", "text": "// Component state types\nexport interface ViewState {\n  currentView: 'albums' | 'photos';\n  selectedAlbumId?: number;\n  selectedPhotoId?: number;\n  isZoomModalOpen: boolean;\n}\n\nexport interface LoadingState {\n  albums: boolean;\n  photos: boolean;\n  upload: boolean;\n  export: boolean;\n}\n\nexport interface ErrorState {\n  message: string;\n  type: 'upload' | 'load' | 'delete' | 'export';\n  timestamp: Date;\n}", "metadata": {}}
{"id": "15", "text": "/**\n * Photo Service Contract\n * Defines interfaces for photo management operations\n */\n\nexport interface Photo {\n  id: number;\n  filename: string;\n  albumId: number;\n  fileData: Blob;\n  thumbnailData: Blob;\n  captureDate: Date | null;\n  fileSize: number;\n  width: number;\n  height: number;\n  uploadTimestamp: Date;\n}\n\nexport interface Album {\n  id: number;\n  name: string;\n  captureDate: Date;\n  displayOrder: number;\n  thumbnailPhotoId: number | null;\n  photoCount: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface UploadSession {\n  id: string;\n  status: 'processing' | 'completed' | 'failed';\n  totalFiles: number;\n  processedFiles: number;\n  errorCount: number;\n  startedAt: Date;\n  completedAt: Date | null;\n}", "metadata": {}}
{"id": "16", "text": "export interface Album {\n  id: number;\n  name: string;\n  captureDate: Date;\n  displayOrder: number;\n  thumbnailPhotoId: number | null;\n  photoCount: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface UploadSession {\n  id: string;\n  status: 'processing' | 'completed' | 'failed';\n  totalFiles: number;\n  processedFiles: number;\n  errorCount: number;\n  startedAt: Date;\n  completedAt: Date | null;\n}\n\nexport interface PhotoService {\n  /**\n   * Upload multiple photos and group into albums by date\n   * @param files - File objects to upload\n   * @returns Upload session for tracking progress\n   */\n  uploadPhotos(files: File[]): Promise<UploadSession>;\n\n  /**\n   * Get all albums ordered by display order\n   * @returns Array of albums with basic metadata\n   */\n  getAllAlbums(): Promise<Album[]>;", "metadata": {}}
{"id": "17", "text": "export interface PhotoService {\n  /**\n   * Upload multiple photos and group into albums by date\n   * @param files - File objects to upload\n   * @returns Upload session for tracking progress\n   */\n  uploadPhotos(files: File[]): Promise<UploadSession>;\n\n  /**\n   * Get all albums ordered by display order\n   * @returns Array of albums with basic metadata\n   */\n  getAllAlbums(): Promise<Album[]>;\n\n  /**\n   * Get all photos for a specific album\n   * @param albumId - Album identifier\n   * @returns Array of photos with thumbnail data\n   */\n  getPhotosInAlbum(albumId: number): Promise<Photo[]>;\n\n  /**\n   * Get full photo data for zoom view\n   * @param photoId - Photo identifier\n   * @returns Photo with full-size image data\n   */\n  getFullPhoto(photoId: number): Promise<Photo>;", "metadata": {}}
{"id": "18", "text": "/**\n   * Get all photos for a specific album\n   * @param albumId - Album identifier\n   * @returns Array of photos with thumbnail data\n   */\n  getPhotosInAlbum(albumId: number): Promise<Photo[]>;\n\n  /**\n   * Get full photo data for zoom view\n   * @param photoId - Photo identifier\n   * @returns Photo with full-size image data\n   */\n  getFullPhoto(photoId: number): Promise<Photo>;\n\n  /**\n   * Update album display order after drag-and-drop\n   * @param albumId - Album to move\n   * @param newOrder - New display order position\n   */\n  updateAlbumOrder(albumId: number, newOrder: number): Promise<void>;\n\n  /**\n   * Export album as ZIP file\n   * @param albumId - Album to export\n   * @returns Blob containing ZIP file\n   */\n  exportAlbumAsZip(albumId: number): Promise<Blob>;", "metadata": {}}
{"id": "19", "text": "/**\n   * Update album display order after drag-and-drop\n   * @param albumId - Album to move\n   * @param newOrder - New display order position\n   */\n  updateAlbumOrder(albumId: number, newOrder: number): Promise<void>;\n\n  /**\n   * Export album as ZIP file\n   * @param albumId - Album to export\n   * @returns Blob containing ZIP file\n   */\n  exportAlbumAsZip(albumId: number): Promise<Blob>;\n\n  /**\n   * Delete photo and update album\n   * @param photoId - Photo to delete\n   */\n  deletePhoto(photoId: number): Promise<void>;\n\n  /**\n   * Delete album and all contained photos\n   * @param albumId - Album to delete\n   */\n  deleteAlbum(albumId: number): Promise<void>;\n}\n\nexport interface PhotoServiceEvents {\n  /**\n   * Emitted during photo upload progress\n   */\n  uploadProgress: {\n    sessionId: string;\n    processedFiles: number;\n    totalFiles: number;\n    currentFile?: string;\n  };", "metadata": {}}
{"id": "20", "text": "/**\n   * Delete photo and update album\n   * @param photoId - Photo to delete\n   */\n  deletePhoto(photoId: number): Promise<void>;\n\n  /**\n   * Delete album and all contained photos\n   * @param albumId - Album to delete\n   */\n  deleteAlbum(albumId: number): Promise<void>;\n}\n\nexport interface PhotoServiceEvents {\n  /**\n   * Emitted during photo upload progress\n   */\n  uploadProgress: {\n    sessionId: string;\n    processedFiles: number;\n    totalFiles: number;\n    currentFile?: string;\n  };\n\n  /**\n   * Emitted when upload session completes\n   */\n  uploadComplete: {\n    sessionId: string;\n    newAlbums: Album[];\n    totalPhotos: number;\n  };\n\n  /**\n   * Emitted when upload encounters errors\n   */\n  uploadError: {\n    sessionId: string;\n    filename: string;\n    error: string;\n  };", "metadata": {}}
{"id": "21", "text": "export interface PhotoServiceEvents {\n  /**\n   * Emitted during photo upload progress\n   */\n  uploadProgress: {\n    sessionId: string;\n    processedFiles: number;\n    totalFiles: number;\n    currentFile?: string;\n  };\n\n  /**\n   * Emitted when upload session completes\n   */\n  uploadComplete: {\n    sessionId: string;\n    newAlbums: Album[];\n    totalPhotos: number;\n  };\n\n  /**\n   * Emitted when upload encounters errors\n   */\n  uploadError: {\n    sessionId: string;\n    filename: string;\n    error: string;\n  };\n\n  /**\n   * Emitted when album order changes\n   */\n  albumOrderChanged: {\n    albumId: number;\n    oldOrder: number;\n    newOrder: number;\n  };\n}", "metadata": {}}
{"id": "22", "text": "# Data Model: Photo Organizer App\n\n## Entity Definitions\n\n### Album Entity\n\n- **id**: INTEGER PRIMARY KEY - Unique identifier\n- **name**: TEXT NOT NULL - Display name (typically formatted date)\n- **capture_date**: DATE NOT NULL - Date for grouping photos\n- **display_order**: INTEGER NOT NULL - User-defined order for drag-and-drop\n- **thumbnail_photo_id**: INTEGER - Reference to representative photo\n- **photo_count**: INTEGER - Cached count for UI display\n- **created_at**: DATETIME DEFAULT CURRENT_TIMESTAMP\n- **updated_at**: DATETIME DEFAULT CURRENT_TIMESTAMP\n\n**Validation Rules**:\n\n- `name` cannot be empty\n- `capture_date` must be valid date\n- `display_order` must be unique within user's albums\n- `thumbnail_photo_id` must reference existing photo\n\n**State Transitions**:\n\n- Created: When first photo with new date is uploaded\n- Updated: When photos are added/removed or user drags to reorder\n- Deleted: When last photo in album is deleted\n\n### Photo Entity", "metadata": {}}
{"id": "23", "text": "**Validation Rules**:\n\n- `name` cannot be empty\n- `capture_date` must be valid date\n- `display_order` must be unique within user's albums\n- `thumbnail_photo_id` must reference existing photo\n\n**State Transitions**:\n\n- Created: When first photo with new date is uploaded\n- Updated: When photos are added/removed or user drags to reorder\n- Deleted: When last photo in album is deleted\n\n### Photo Entity\n\n- **id**: INTEGER PRIMARY KEY - Unique identifier\n- **filename**: TEXT NOT NULL - Original filename from upload\n- **album_id**: INTEGER NOT NULL - Foreign key to albums table\n- **file_data**: BLOB NOT NULL - Binary image data\n- **thumbnail_data**: BLOB NOT NULL - Generated thumbnail (256x256)\n- **capture_date**: DATETIME - Extracted from EXIF or NULL\n- **file_size**: INTEGER NOT NULL - Size in bytes\n- **width**: INTEGER - Image width in pixels\n- **height**: INTEGER - Image height in pixels\n- **upload_timestamp**: DATETIME DEFAULT CURRENT_TIMESTAMP\n\n**Validation Rules**:", "metadata": {}}
{"id": "24", "text": "**Validation Rules**:\n\n- `filename` cannot be empty\n- `album_id` must reference existing album\n- `file_data` must be valid image format\n- `file_size` must be > 0\n- `width` and `height` must be > 0\n\n**State Transitions**:\n\n- Created: When uploaded and processed\n- Updated: If moved between albums (rare, likely requires new spec)\n- Deleted: When user removes photo\n\n### Upload Session Entity (Temporary)\n\n- **id**: TEXT PRIMARY KEY - UUID for session tracking\n- **status**: TEXT NOT NULL - 'processing', 'completed', 'failed'\n- **total_files**: INTEGER NOT NULL - Number of files in upload\n- **processed_files**: INTEGER DEFAULT 0 - Number completed\n- **error_count**: INTEGER DEFAULT 0 - Number failed\n- **started_at**: DATETIME DEFAULT CURRENT_TIMESTAMP\n- **completed_at**: DATETIME - When session finished\n\n**Validation Rules**:", "metadata": {}}
{"id": "25", "text": "### Upload Session Entity (Temporary)\n\n- **id**: TEXT PRIMARY KEY - UUID for session tracking\n- **status**: TEXT NOT NULL - 'processing', 'completed', 'failed'\n- **total_files**: INTEGER NOT NULL - Number of files in upload\n- **processed_files**: INTEGER DEFAULT 0 - Number completed\n- **error_count**: INTEGER DEFAULT 0 - Number failed\n- **started_at**: DATETIME DEFAULT CURRENT_TIMESTAMP\n- **completed_at**: DATETIME - When session finished\n\n**Validation Rules**:\n\n- `status` must be one of allowed values\n- `processed_files` + `error_count` <= `total_files`\n- `completed_at` only set when status is 'completed' or 'failed'\n\n**State Transitions**:\n\n- Created: When user starts file upload\n- Processing: As files are individually processed\n- Completed: When all files processed successfully\n- Failed: If critical error occurs\n\n## Relationships\n\n### Album → Photos (One-to-Many)", "metadata": {}}
{"id": "26", "text": "**Validation Rules**:\n\n- `status` must be one of allowed values\n- `processed_files` + `error_count` <= `total_files`\n- `completed_at` only set when status is 'completed' or 'failed'\n\n**State Transitions**:\n\n- Created: When user starts file upload\n- Processing: As files are individually processed\n- Completed: When all files processed successfully\n- Failed: If critical error occurs\n\n## Relationships\n\n### Album → Photos (One-to-Many)\n\n- Each album contains multiple photos\n- Photos cannot exist without an album\n- When album is deleted, all photos are deleted (CASCADE)\n\n### Album → Thumbnail Photo (One-to-One Optional)\n\n- Album may have a representative thumbnail photo\n- Thumbnail photo must be from the same album\n- If thumbnail photo is deleted, thumbnail_photo_id set to NULL\n\n### Upload Session → Photos (One-to-Many Temporary)\n\n- During upload, photos are associated with session\n- After completion, session can be deleted\n- Used for progress tracking and error recovery\n\n## Indexes for Performance", "metadata": {}}
{"id": "27", "text": "- Each album contains multiple photos\n- Photos cannot exist without an album\n- When album is deleted, all photos are deleted (CASCADE)\n\n### Album → Thumbnail Photo (One-to-One Optional)\n\n- Album may have a representative thumbnail photo\n- Thumbnail photo must be from the same album\n- If thumbnail photo is deleted, thumbnail_photo_id set to NULL\n\n### Upload Session → Photos (One-to-Many Temporary)\n\n- During upload, photos are associated with session\n- After completion, session can be deleted\n- Used for progress tracking and error recovery\n\n## Indexes for Performance\n\n```sql\nCREATE INDEX idx_albums_capture_date ON albums(capture_date);\nCREATE INDEX idx_albums_display_order ON albums(display_order);\nCREATE INDEX idx_photos_album_id ON photos(album_id);\nCREATE INDEX idx_photos_upload_timestamp ON photos(upload_timestamp);\n```\n\n## Data Integrity Constraints\n\n```sql\n-- Ensure display_order is unique\nCREATE UNIQUE INDEX idx_albums_unique_order ON albums(display_order);\n\n-- Foreign key constraints\nPRAGMA foreign_keys = ON;", "metadata": {}}
{"id": "28", "text": "- During upload, photos are associated with session\n- After completion, session can be deleted\n- Used for progress tracking and error recovery\n\n## Indexes for Performance\n\n```sql\nCREATE INDEX idx_albums_capture_date ON albums(capture_date);\nCREATE INDEX idx_albums_display_order ON albums(display_order);\nCREATE INDEX idx_photos_album_id ON photos(album_id);\nCREATE INDEX idx_photos_upload_timestamp ON photos(upload_timestamp);\n```\n\n## Data Integrity Constraints\n\n```sql\n-- Ensure display_order is unique\nCREATE UNIQUE INDEX idx_albums_unique_order ON albums(display_order);\n\n-- Foreign key constraints\nPRAGMA foreign_keys = ON;\n\n-- Check constraints\nALTER TABLE albums ADD CONSTRAINT chk_album_name_not_empty\n  CHECK (length(trim(name)) > 0);\n\nALTER TABLE photos ADD CONSTRAINT chk_photo_filename_not_empty\n  CHECK (length(trim(filename)) > 0);\n\nALTER TABLE photos ADD CONSTRAINT chk_photo_dimensions_positive\n  CHECK (width > 0 AND height > 0);\n```\n\n## Component Data Requirements\n\n### AlbumGrid Component", "metadata": {}}
{"id": "29", "text": "## Data Integrity Constraints\n\n```sql\n-- Ensure display_order is unique\nCREATE UNIQUE INDEX idx_albums_unique_order ON albums(display_order);\n\n-- Foreign key constraints\nPRAGMA foreign_keys = ON;\n\n-- Check constraints\nALTER TABLE albums ADD CONSTRAINT chk_album_name_not_empty\n  CHECK (length(trim(name)) > 0);\n\nALTER TABLE photos ADD CONSTRAINT chk_photo_filename_not_empty\n  CHECK (length(trim(filename)) > 0);\n\nALTER TABLE photos ADD CONSTRAINT chk_photo_dimensions_positive\n  CHECK (width > 0 AND height > 0);\n```\n\n## Component Data Requirements\n\n### AlbumGrid Component\n\n- Needs: All albums with thumbnail_photo_id, photo_count, name, display_order\n- Updates: display_order when drag-and-drop occurs\n- Query: `SELECT * FROM albums ORDER BY display_order`\n\n### AlbumTile Component\n\n- Needs: Album data + thumbnail image blob\n- Join: `albums LEFT JOIN photos ON albums.thumbnail_photo_id = photos.id`\n\n### PhotoTileView Component", "metadata": {}}
{"id": "30", "text": "ALTER TABLE photos ADD CONSTRAINT chk_photo_dimensions_positive\n  CHECK (width > 0 AND height > 0);\n```\n\n## Component Data Requirements\n\n### AlbumGrid Component\n\n- Needs: All albums with thumbnail_photo_id, photo_count, name, display_order\n- Updates: display_order when drag-and-drop occurs\n- Query: `SELECT * FROM albums ORDER BY display_order`\n\n### AlbumTile Component\n\n- Needs: Album data + thumbnail image blob\n- Join: `albums LEFT JOIN photos ON albums.thumbnail_photo_id = photos.id`\n\n### PhotoTileView Component\n\n- Needs: All photos for specific album with thumbnail_data\n- Query: `SELECT * FROM photos WHERE album_id = ? ORDER BY upload_timestamp`\n\n### ZoomModal Component\n\n- Needs: Full photo data (file_data) + navigation info\n- Query: `SELECT * FROM photos WHERE album_id = ? ORDER BY upload_timestamp`\n\n### UploadDropzone Component\n\n- Creates: New photos and potentially new albums\n- Updates: Upload session progress\n\n## Storage Considerations", "metadata": {}}
{"id": "31", "text": "### PhotoTileView Component\n\n- Needs: All photos for specific album with thumbnail_data\n- Query: `SELECT * FROM photos WHERE album_id = ? ORDER BY upload_timestamp`\n\n### ZoomModal Component\n\n- Needs: Full photo data (file_data) + navigation info\n- Query: `SELECT * FROM photos WHERE album_id = ? ORDER BY upload_timestamp`\n\n### UploadDropzone Component\n\n- Creates: New photos and potentially new albums\n- Updates: Upload session progress\n\n## Storage Considerations\n\n**SQLite Database Size**: Estimated 10-50MB for 1000 photos with thumbnails\n**Browser Storage**: Uses IndexedDB for persistence (typically 50MB+ available)\n**Memory Usage**: Load thumbnails in batches, full images on-demand\n**Backup Strategy**: ZIP export includes database + photos for complete backup", "metadata": {}}
{"id": "32", "text": "# Implementation Plan: Photo Organizer App\n\n**Branch**: `001-build-a-photo` | **Date**: 2025-09-23 | **Spec**: [spec.md](./spec.md)\n**Input**: Feature specification from `/specs/001-build-a-photo/spec.md`\n\n## Execution Flow (/plan command scope)\n\n```\n1. Load feature spec from Input path\n   → If not found: ERROR \"No feature spec at {path}\"\n2. Fill Technical Context (scan for NEEDS CLARIFICATION)\n   → Detect Project Type from context (web=frontend+backend, mobile=app+api)\n   → Set Structure Decision based on project type\n3. Fill the Constitution Check section based on the content of the constitution document.\n4. Evaluate Constitution Check section below\n   → If violations exist: Document in Complexity Tracking\n   → If no justification possible: ERROR \"Simplify approach first\"\n   → Update Progress Tracking: Initial Constitution Check\n5. Execute Phase 0 → research.md\n   → If NEEDS CLARIFICATION remain: ERROR \"Resolve unknowns\"\n6.", "metadata": {}}
{"id": "33", "text": "Fill the Constitution Check section based on the content of the constitution document.\n4. Evaluate Constitution Check section below\n   → If violations exist: Document in Complexity Tracking\n   → If no justification possible: ERROR \"Simplify approach first\"\n   → Update Progress Tracking: Initial Constitution Check\n5. Execute Phase 0 → research.md\n   → If NEEDS CLARIFICATION remain: ERROR \"Resolve unknowns\"\n6. Execute Phase 1 → contracts, data-model.md, quickstart.md, agent-specific template file (e.g., `CLAUDE.md` for Claude Code, `.github/copilot-instructions.md` for GitHub Copilot, `GEMINI.md` for Gemini CLI, `QWEN.md` for Qwen Code or `AGENTS.md` for opencode).\n7. Re-evaluate Constitution Check section\n   → If new violations: Refactor design, return to Phase 1\n   → Update Progress Tracking: Post-Design Constitution Check\n8. Plan Phase 2 → Describe task generation approach (DO NOT create tasks.md)\n9. STOP - Ready for /tasks command\n```", "metadata": {}}
{"id": "34", "text": "7. Re-evaluate Constitution Check section\n   → If new violations: Refactor design, return to Phase 1\n   → Update Progress Tracking: Post-Design Constitution Check\n8. Plan Phase 2 → Describe task generation approach (DO NOT create tasks.md)\n9. STOP - Ready for /tasks command\n```\n\n**IMPORTANT**: The /plan command STOPS at step 7. Phases 2-4 are executed by other commands:\n\n- Phase 2: /tasks command creates tasks.md\n- Phase 3-4: Implementation execution (manual or via tools)\n\n## Summary\n\nPhoto organizer app with React UI component hierarchy including AlbumGrid, AlbumTile, PhotoTileView, ZoomModal, and UploadDropzone components. Uses shadcn/ui integration with drag-and-drop functionality for album reordering. Auto-groups photos by EXIF capture date with local SQLite storage.\n\n## Technical Context", "metadata": {}}
{"id": "35", "text": "**IMPORTANT**: The /plan command STOPS at step 7. Phases 2-4 are executed by other commands:\n\n- Phase 2: /tasks command creates tasks.md\n- Phase 3-4: Implementation execution (manual or via tools)\n\n## Summary\n\nPhoto organizer app with React UI component hierarchy including AlbumGrid, AlbumTile, PhotoTileView, ZoomModal, and UploadDropzone components. Uses shadcn/ui integration with drag-and-drop functionality for album reordering. Auto-groups photos by EXIF capture date with local SQLite storage.\n\n## Technical Context\n\n**Language/Version**: TypeScript with React.js 18+\n**Primary Dependencies**: React, Tailwind CSS, shadcn/ui, Vite, @dnd-kit/core for drag-drop\n**Storage**: SQLite with local file storage only\n**Testing**: Vitest with React Testing Library for 100% coverage\n**Target Platform**: Modern web browsers (Chrome 90+, Firefox 88+, Safari 14+)\n**Project Type**: single - React SPA with local data persistence\n**Performance Goals**: <100ms UI interactions, smooth 60fps drag animations\n**Constraints**: Offline-capable, no cloud storage, WCAG 2.1 AA accessibility\n**Scale/Scope**: Single-user desktop/mobile web app, ~1000 photos per album", "metadata": {}}
{"id": "36", "text": "## Constitution Check\n\n*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*\n\n**✅ React Component Architecture**: UI plan focuses on functional components with hooks (AlbumGrid, AlbumTile, PhotoTileView, ZoomModal, UploadDropzone)\n\n**✅ 100% Test Coverage**: TDD approach with Vitest + React Testing Library for all components\n\n**✅ Accessibility First**: WCAG 2.1 AA compliance with ARIA labels, semantic HTML, keyboard navigation\n\n**✅ Local SQLite Storage**: All photo/album data persisted locally, no cloud dependencies\n\n**✅ Modern React Ecosystem**: React 18+, TypeScript, Tailwind CSS, shadcn/ui components, Vite build\n\n## Project Structure\n\n### Documentation (this feature)", "metadata": {}}
{"id": "37", "text": "**✅ 100% Test Coverage**: TDD approach with Vitest + React Testing Library for all components\n\n**✅ Accessibility First**: WCAG 2.1 AA compliance with ARIA labels, semantic HTML, keyboard navigation\n\n**✅ Local SQLite Storage**: All photo/album data persisted locally, no cloud dependencies\n\n**✅ Modern React Ecosystem**: React 18+, TypeScript, Tailwind CSS, shadcn/ui components, Vite build\n\n## Project Structure\n\n### Documentation (this feature)\n\n```\nspecs/[###-feature]/\n├── plan.md              # This file (/plan command output)\n├── research.md          # Phase 0 output (/plan command)\n├── data-model.md        # Phase 1 output (/plan command)\n├── quickstart.md        # Phase 1 output (/plan command)\n├── contracts/           # Phase 1 output (/plan command)\n└── tasks.md             # Phase 2 output (/tasks command - NOT created by /plan)\n```\n\n### Source Code (repository root)", "metadata": {}}
{"id": "38", "text": "## Project Structure\n\n### Documentation (this feature)\n\n```\nspecs/[###-feature]/\n├── plan.md              # This file (/plan command output)\n├── research.md          # Phase 0 output (/plan command)\n├── data-model.md        # Phase 1 output (/plan command)\n├── quickstart.md        # Phase 1 output (/plan command)\n├── contracts/           # Phase 1 output (/plan command)\n└── tasks.md             # Phase 2 output (/tasks command - NOT created by /plan)\n```\n\n### Source Code (repository root)\n\n```\n# Option 1: Single project (DEFAULT)\nsrc/\n├── models/\n├── services/\n├── cli/\n└── lib/\n\ntests/\n├── contract/\n├── integration/\n└── unit/\n\n# Option 2: Web application (when \"frontend\" + \"backend\" detected)\nbackend/\n├── src/\n│   ├── models/\n│   ├── services/\n│   └── api/\n└── tests/", "metadata": {}}
{"id": "39", "text": "### Source Code (repository root)\n\n```\n# Option 1: Single project (DEFAULT)\nsrc/\n├── models/\n├── services/\n├── cli/\n└── lib/\n\ntests/\n├── contract/\n├── integration/\n└── unit/\n\n# Option 2: Web application (when \"frontend\" + \"backend\" detected)\nbackend/\n├── src/\n│   ├── models/\n│   ├── services/\n│   └── api/\n└── tests/\n\nfrontend/\n├── src/\n│   ├── components/\n│   ├── pages/\n│   └── services/\n└── tests/\n\n# Option 3: Mobile + API (when \"iOS/Android\" detected)\napi/\n└── [same as backend above]\n\nios/ or android/\n└── [platform-specific structure]\n```\n\n**Structure Decision**: Option 1 (Single project) - React SPA with local storage\n\n## Phase 0: Outline & Research", "metadata": {}}
{"id": "40", "text": "frontend/\n├── src/\n│   ├── components/\n│   ├── pages/\n│   └── services/\n└── tests/\n\n# Option 3: Mobile + API (when \"iOS/Android\" detected)\napi/\n└── [same as backend above]\n\nios/ or android/\n└── [platform-specific structure]\n```\n\n**Structure Decision**: Option 1 (Single project) - React SPA with local storage\n\n## Phase 0: Outline & Research\n\n1. **Extract unknowns from Technical Context** above:\n   - For each NEEDS CLARIFICATION → research task\n   - For each dependency → best practices task\n   - For each integration → patterns task\n\n2. **Generate and dispatch research agents**:\n\n   ```\n   For each unknown in Technical Context:\n     Task: \"Research {unknown} for {feature context}\"\n   For each technology choice:\n     Task: \"Find best practices for {tech} in {domain}\"\n   ```", "metadata": {}}
{"id": "41", "text": "**Structure Decision**: Option 1 (Single project) - React SPA with local storage\n\n## Phase 0: Outline & Research\n\n1. **Extract unknowns from Technical Context** above:\n   - For each NEEDS CLARIFICATION → research task\n   - For each dependency → best practices task\n   - For each integration → patterns task\n\n2. **Generate and dispatch research agents**:\n\n   ```\n   For each unknown in Technical Context:\n     Task: \"Research {unknown} for {feature context}\"\n   For each technology choice:\n     Task: \"Find best practices for {tech} in {domain}\"\n   ```\n\n3. **Consolidate findings** in `research.md` using format:\n   - Decision: [what was chosen]\n   - Rationale: [why chosen]\n   - Alternatives considered: [what else evaluated]\n\n**Output**: research.md with all NEEDS CLARIFICATION resolved\n\n## Phase 1: Design & Contracts\n\n*Prerequisites: research.md complete*", "metadata": {}}
{"id": "42", "text": "```\n   For each unknown in Technical Context:\n     Task: \"Research {unknown} for {feature context}\"\n   For each technology choice:\n     Task: \"Find best practices for {tech} in {domain}\"\n   ```\n\n3. **Consolidate findings** in `research.md` using format:\n   - Decision: [what was chosen]\n   - Rationale: [why chosen]\n   - Alternatives considered: [what else evaluated]\n\n**Output**: research.md with all NEEDS CLARIFICATION resolved\n\n## Phase 1: Design & Contracts\n\n*Prerequisites: research.md complete*\n\n1. **Extract entities from feature spec** → `data-model.md`:\n   - Entity name, fields, relationships\n   - Validation rules from requirements\n   - State transitions if applicable\n\n2. **Generate API contracts** from functional requirements:\n   - For each user action → endpoint\n   - Use standard REST/GraphQL patterns\n   - Output OpenAPI/GraphQL schema to `/contracts/`", "metadata": {}}
{"id": "43", "text": "**Output**: research.md with all NEEDS CLARIFICATION resolved\n\n## Phase 1: Design & Contracts\n\n*Prerequisites: research.md complete*\n\n1. **Extract entities from feature spec** → `data-model.md`:\n   - Entity name, fields, relationships\n   - Validation rules from requirements\n   - State transitions if applicable\n\n2. **Generate API contracts** from functional requirements:\n   - For each user action → endpoint\n   - Use standard REST/GraphQL patterns\n   - Output OpenAPI/GraphQL schema to `/contracts/`\n\n3. **Generate contract tests** from contracts:\n   - One test file per endpoint\n   - Assert request/response schemas\n   - Tests must fail (no implementation yet)\n\n4. **Extract test scenarios** from user stories:\n   - Each story → integration test scenario\n   - Quickstart test = story validation steps", "metadata": {}}
{"id": "44", "text": "2. **Generate API contracts** from functional requirements:\n   - For each user action → endpoint\n   - Use standard REST/GraphQL patterns\n   - Output OpenAPI/GraphQL schema to `/contracts/`\n\n3. **Generate contract tests** from contracts:\n   - One test file per endpoint\n   - Assert request/response schemas\n   - Tests must fail (no implementation yet)\n\n4. **Extract test scenarios** from user stories:\n   - Each story → integration test scenario\n   - Quickstart test = story validation steps\n\n5. **Update agent file incrementally** (O(1) operation):\n   - Run `.specify/scripts/bash/update-agent-context.sh claude`\n     **IMPORTANT**: Execute it exactly as specified above. Do not add or remove any arguments.\n   - If exists: Add only NEW tech from current plan\n   - Preserve manual additions between markers\n   - Update recent changes (keep last 3)\n   - Keep under 150 lines for token efficiency\n   - Output to repository root\n\n**Output**: data-model.md, /contracts/*, failing tests, quickstart.md, agent-specific file", "metadata": {}}
{"id": "45", "text": "5. **Update agent file incrementally** (O(1) operation):\n   - Run `.specify/scripts/bash/update-agent-context.sh claude`\n     **IMPORTANT**: Execute it exactly as specified above. Do not add or remove any arguments.\n   - If exists: Add only NEW tech from current plan\n   - Preserve manual additions between markers\n   - Update recent changes (keep last 3)\n   - Keep under 150 lines for token efficiency\n   - Output to repository root\n\n**Output**: data-model.md, /contracts/*, failing tests, quickstart.md, agent-specific file\n\n## Phase 2: Task Planning Approach\n\n*This section describes what the /tasks command will do - DO NOT execute during /plan*\n\n**Task Generation Strategy**:\n\n- Generate UI component tasks from React component hierarchy\n- Create service layer tasks for PhotoService contract\n- Database setup and migration tasks for SQLite schema\n- Testing tasks for 100% coverage requirement\n- Accessibility validation tasks for WCAG compliance\n\n**Ordering Strategy**:", "metadata": {}}
{"id": "46", "text": "**Output**: data-model.md, /contracts/*, failing tests, quickstart.md, agent-specific file\n\n## Phase 2: Task Planning Approach\n\n*This section describes what the /tasks command will do - DO NOT execute during /plan*\n\n**Task Generation Strategy**:\n\n- Generate UI component tasks from React component hierarchy\n- Create service layer tasks for PhotoService contract\n- Database setup and migration tasks for SQLite schema\n- Testing tasks for 100% coverage requirement\n- Accessibility validation tasks for WCAG compliance\n\n**Ordering Strategy**:\n\n- Setup: Project initialization, dependencies, database schema\n- Tests First: Component tests, service tests (TDD)\n- Core Components: AlbumGrid, AlbumTile, PhotoTileView [P]\n- Supporting Components: ZoomModal, UploadDropzone [P]\n- Service Layer: PhotoService implementation, SQLite integration\n- Integration: Drag-and-drop, ZIP export, error handling\n- Polish: Accessibility, performance, documentation\n\n**Estimated Output**: 30-35 numbered, ordered tasks focusing on UI component hierarchy", "metadata": {}}
{"id": "47", "text": "**Ordering Strategy**:\n\n- Setup: Project initialization, dependencies, database schema\n- Tests First: Component tests, service tests (TDD)\n- Core Components: AlbumGrid, AlbumTile, PhotoTileView [P]\n- Supporting Components: ZoomModal, UploadDropzone [P]\n- Service Layer: PhotoService implementation, SQLite integration\n- Integration: Drag-and-drop, ZIP export, error handling\n- Polish: Accessibility, performance, documentation\n\n**Estimated Output**: 30-35 numbered, ordered tasks focusing on UI component hierarchy\n\n**IMPORTANT**: This phase is executed by the /tasks command, NOT by /plan\n\n## Phase 3+: Future Implementation\n\n*These phases are beyond the scope of the /plan command*\n\n**Phase 3**: Task execution (/tasks command creates tasks.md)  \n**Phase 4**: Implementation (execute tasks.md following constitutional principles)  \n**Phase 5**: Validation (run tests, execute quickstart.md, performance validation)\n\n## Complexity Tracking\n\n*Fill ONLY if Constitution Check has violations that must be justified*", "metadata": {}}
{"id": "48", "text": "**Estimated Output**: 30-35 numbered, ordered tasks focusing on UI component hierarchy\n\n**IMPORTANT**: This phase is executed by the /tasks command, NOT by /plan\n\n## Phase 3+: Future Implementation\n\n*These phases are beyond the scope of the /plan command*\n\n**Phase 3**: Task execution (/tasks command creates tasks.md)  \n**Phase 4**: Implementation (execute tasks.md following constitutional principles)  \n**Phase 5**: Validation (run tests, execute quickstart.md, performance validation)\n\n## Complexity Tracking\n\n*Fill ONLY if Constitution Check has violations that must be justified*\n\n| Violation | Why Needed | Simpler Alternative Rejected Because |\n|-----------|------------|-------------------------------------|\n| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |\n| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |\n\n## Progress Tracking\n\n*This checklist is updated during execution flow*\n\n**Phase Status**:", "metadata": {}}
{"id": "49", "text": "## Complexity Tracking\n\n*Fill ONLY if Constitution Check has violations that must be justified*\n\n| Violation | Why Needed | Simpler Alternative Rejected Because |\n|-----------|------------|-------------------------------------|\n| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |\n| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |\n\n## Progress Tracking\n\n*This checklist is updated during execution flow*\n\n**Phase Status**:\n\n- [x] Phase 0: Research complete (/plan command)\n- [x] Phase 1: Design complete (/plan command)\n- [x] Phase 2: Task planning complete (/plan command - describe approach only)\n- [ ] Phase 3: Tasks generated (/tasks command)\n- [ ] Phase 4: Implementation complete\n- [ ] Phase 5: Validation passed\n\n**Gate Status**:\n\n- [x] Initial Constitution Check: PASS\n- [x] Post-Design Constitution Check: PASS\n- [x] All NEEDS CLARIFICATION resolved\n- [ ] Complexity deviations documented", "metadata": {}}
{"id": "50", "text": "- [x] Phase 0: Research complete (/plan command)\n- [x] Phase 1: Design complete (/plan command)\n- [x] Phase 2: Task planning complete (/plan command - describe approach only)\n- [ ] Phase 3: Tasks generated (/tasks command)\n- [ ] Phase 4: Implementation complete\n- [ ] Phase 5: Validation passed\n\n**Gate Status**:\n\n- [x] Initial Constitution Check: PASS\n- [x] Post-Design Constitution Check: PASS\n- [x] All NEEDS CLARIFICATION resolved\n- [ ] Complexity deviations documented\n\n---\n*Based on Constitution v2.1.1 - See `/memory/constitution.md`*", "metadata": {}}
{"id": "51", "text": "# Quickstart: Photo Organizer App\n\n## Setup and First Run\n\n### 1. Initial Setup\n```bash\n# Install dependencies\nnpm install\n\n# Start development server\nnpm run dev\n\n# Open browser to http://localhost:5173\n```\n\n### 2. Development Commands\n```bash\n# Run tests with coverage\nnpm test\n\n# Run tests in watch mode\nnpm test:watch\n\n# Run linting\nnpm run lint\n\n# Run type checking\nnpm run type-check\n\n# Build for production\nnpm run build\n```\n\n## User Journey Testing\n\n### Primary Flow: Upload and Organize Photos\n\n1. **Empty State**\n   - Open app in browser\n   - Verify empty grid shows with upload instructions\n   - Confirm accessibility: Screen reader announces \"No albums found. Upload photos to get started\"\n\n2. **Upload Photos**\n   - Drag 5-10 photos with different dates into upload dropzone\n   - Verify upload progress bar appears\n   - Confirm photos are processed and grouped by capture date\n   - Check that albums appear in grid layout", "metadata": {}}
{"id": "52", "text": "# Build for production\nnpm run build\n```\n\n## User Journey Testing\n\n### Primary Flow: Upload and Organize Photos\n\n1. **Empty State**\n   - Open app in browser\n   - Verify empty grid shows with upload instructions\n   - Confirm accessibility: Screen reader announces \"No albums found. Upload photos to get started\"\n\n2. **Upload Photos**\n   - Drag 5-10 photos with different dates into upload dropzone\n   - Verify upload progress bar appears\n   - Confirm photos are processed and grouped by capture date\n   - Check that albums appear in grid layout\n\n3. **Browse Albums**\n   - Click on an album tile\n   - Verify photo tile view opens\n   - Confirm navigation breadcrumb shows album name\n   - Test keyboard navigation through photos\n\n4. **View Photo in Zoom Mode**\n   - Click on a photo tile\n   - Verify zoom modal opens with full-size image\n   - Test navigation controls (next/previous/close)\n   - Confirm keyboard navigation works (arrow keys, escape)", "metadata": {}}
{"id": "53", "text": "3. **Browse Albums**\n   - Click on an album tile\n   - Verify photo tile view opens\n   - Confirm navigation breadcrumb shows album name\n   - Test keyboard navigation through photos\n\n4. **View Photo in Zoom Mode**\n   - Click on a photo tile\n   - Verify zoom modal opens with full-size image\n   - Test navigation controls (next/previous/close)\n   - Confirm keyboard navigation works (arrow keys, escape)\n\n5. **Reorder Albums**\n   - Return to main album grid\n   - Drag an album tile to new position\n   - Verify visual feedback during drag\n   - Confirm new order persists after page refresh\n\n6. **Export Album**\n   - Select an album\n   - Click export button\n   - Verify ZIP file downloads with all photos\n   - Confirm file names match original uploads\n\n### Accessibility Testing Checklist", "metadata": {}}
{"id": "54", "text": "5. **Reorder Albums**\n   - Return to main album grid\n   - Drag an album tile to new position\n   - Verify visual feedback during drag\n   - Confirm new order persists after page refresh\n\n6. **Export Album**\n   - Select an album\n   - Click export button\n   - Verify ZIP file downloads with all photos\n   - Confirm file names match original uploads\n\n### Accessibility Testing Checklist\n\n- [ ] Tab navigation works through all interactive elements\n- [ ] Screen reader announces all content appropriately\n- [ ] High contrast mode displays clearly\n- [ ] Keyboard shortcuts work (arrow keys in zoom, escape to close)\n- [ ] Focus indicators are visible\n- [ ] Alt text is provided for all images\n- [ ] ARIA labels describe interactive elements\n\n### Error Scenario Testing\n\n1. **Upload Errors**\n   - Try uploading unsupported file type\n   - Upload corrupted image file\n   - Upload when storage is nearly full\n   - Verify error messages are helpful and actionable", "metadata": {}}
{"id": "55", "text": "### Accessibility Testing Checklist\n\n- [ ] Tab navigation works through all interactive elements\n- [ ] Screen reader announces all content appropriately\n- [ ] High contrast mode displays clearly\n- [ ] Keyboard shortcuts work (arrow keys in zoom, escape to close)\n- [ ] Focus indicators are visible\n- [ ] Alt text is provided for all images\n- [ ] ARIA labels describe interactive elements\n\n### Error Scenario Testing\n\n1. **Upload Errors**\n   - Try uploading unsupported file type\n   - Upload corrupted image file\n   - Upload when storage is nearly full\n   - Verify error messages are helpful and actionable\n\n2. **Browser Recovery**\n   - Upload photos, then refresh page mid-upload\n   - Verify recovery prompt appears\n   - Confirm data integrity after recovery\n\n3. **Offline Usage**\n   - Disconnect network after loading app\n   - Verify all functionality continues to work\n   - Confirm data persists locally\n\n## Component Development Workflow\n\n### 1. Start with Tests\n```bash\n# Create component test file\ntouch src/components/AlbumGrid/AlbumGrid.test.tsx", "metadata": {}}
{"id": "56", "text": "2. **Browser Recovery**\n   - Upload photos, then refresh page mid-upload\n   - Verify recovery prompt appears\n   - Confirm data integrity after recovery\n\n3. **Offline Usage**\n   - Disconnect network after loading app\n   - Verify all functionality continues to work\n   - Confirm data persists locally\n\n## Component Development Workflow\n\n### 1. Start with Tests\n```bash\n# Create component test file\ntouch src/components/AlbumGrid/AlbumGrid.test.tsx\n\n# Write failing test first\nnpm test -- --watch AlbumGrid\n```\n\n### 2. Build Component\n```bash\n# Create component directory\nmkdir src/components/AlbumGrid\n\n# Create files\ntouch src/components/AlbumGrid/index.ts\ntouch src/components/AlbumGrid/AlbumGrid.tsx\ntouch src/components/AlbumGrid/AlbumGrid.stories.tsx\n```\n\n### 3. Integration Testing\n```bash\n# Run full test suite\nnpm test\n\n# Check coverage\nnpm run test:coverage\n```\n\n## Database Development\n\n### 1. Schema Changes\n```bash\n# Create migration\nnpm run db:migrate", "metadata": {}}
{"id": "57", "text": "### 2. Build Component\n```bash\n# Create component directory\nmkdir src/components/AlbumGrid\n\n# Create files\ntouch src/components/AlbumGrid/index.ts\ntouch src/components/AlbumGrid/AlbumGrid.tsx\ntouch src/components/AlbumGrid/AlbumGrid.stories.tsx\n```\n\n### 3. Integration Testing\n```bash\n# Run full test suite\nnpm test\n\n# Check coverage\nnpm run test:coverage\n```\n\n## Database Development\n\n### 1. Schema Changes\n```bash\n# Create migration\nnpm run db:migrate\n\n# Seed test data\nnpm run db:seed\n\n# Reset database\nnpm run db:reset\n```\n\n### 2. Query Testing\n```bash\n# Start database console\nnpm run db:console\n\n# Run query tests\nnpm run test:db\n```\n\n## Performance Testing\n\n### 1. Load Testing\n- Upload 100+ photos\n- Verify smooth scrolling in grids\n- Check memory usage in DevTools\n- Confirm 60fps during animations", "metadata": {}}
{"id": "58", "text": "## Database Development\n\n### 1. Schema Changes\n```bash\n# Create migration\nnpm run db:migrate\n\n# Seed test data\nnpm run db:seed\n\n# Reset database\nnpm run db:reset\n```\n\n### 2. Query Testing\n```bash\n# Start database console\nnpm run db:console\n\n# Run query tests\nnpm run test:db\n```\n\n## Performance Testing\n\n### 1. Load Testing\n- Upload 100+ photos\n- Verify smooth scrolling in grids\n- Check memory usage in DevTools\n- Confirm 60fps during animations\n\n### 2. Bundle Analysis\n```bash\n# Analyze bundle size\nnpm run build:analyze\n\n# Check lighthouse scores\nnpm run lighthouse\n```\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Photos not appearing**\n   - Check browser console for EXIF parsing errors\n   - Verify IndexedDB is available and not full\n   - Confirm supported file formats", "metadata": {}}
{"id": "59", "text": "## Performance Testing\n\n### 1. Load Testing\n- Upload 100+ photos\n- Verify smooth scrolling in grids\n- Check memory usage in DevTools\n- Confirm 60fps during animations\n\n### 2. Bundle Analysis\n```bash\n# Analyze bundle size\nnpm run build:analyze\n\n# Check lighthouse scores\nnpm run lighthouse\n```\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Photos not appearing**\n   - Check browser console for EXIF parsing errors\n   - Verify IndexedDB is available and not full\n   - Confirm supported file formats\n\n2. **Drag and drop not working**\n   - Ensure @dnd-kit/core is installed\n   - Check accessibility settings allow drag operations\n   - Verify touch events for mobile\n\n3. **Export failing**\n   - Check available disk space\n   - Verify ZIP library is loaded\n   - Confirm photos exist in database\n\n### Debug Mode\n```bash\n# Enable debug logging\nVITE_DEBUG=true npm run dev\n\n# View database contents\nnpm run db:inspect\n```\n\n## Production Deployment", "metadata": {}}
{"id": "60", "text": "2. **Drag and drop not working**\n   - Ensure @dnd-kit/core is installed\n   - Check accessibility settings allow drag operations\n   - Verify touch events for mobile\n\n3. **Export failing**\n   - Check available disk space\n   - Verify ZIP library is loaded\n   - Confirm photos exist in database\n\n### Debug Mode\n```bash\n# Enable debug logging\nVITE_DEBUG=true npm run dev\n\n# View database contents\nnpm run db:inspect\n```\n\n## Production Deployment\n\n### 1. Build and Test\n```bash\n# Full production build\nnpm run build\n\n# Test production build locally\nnpm run preview\n\n# Run production test suite\nnpm run test:prod\n```\n\n### 2. Performance Validation\n- [ ] Lighthouse score > 90 for all metrics\n- [ ] Bundle size < 500KB gzipped\n- [ ] First Contentful Paint < 1.5s\n- [ ] Largest Contentful Paint < 2.5s", "metadata": {}}
{"id": "61", "text": "# View database contents\nnpm run db:inspect\n```\n\n## Production Deployment\n\n### 1. Build and Test\n```bash\n# Full production build\nnpm run build\n\n# Test production build locally\nnpm run preview\n\n# Run production test suite\nnpm run test:prod\n```\n\n### 2. Performance Validation\n- [ ] Lighthouse score > 90 for all metrics\n- [ ] Bundle size < 500KB gzipped\n- [ ] First Contentful Paint < 1.5s\n- [ ] Largest Contentful Paint < 2.5s\n\n### 3. Accessibility Validation\n- [ ] WAVE browser extension shows 0 errors\n- [ ] axe-core automated tests pass\n- [ ] Manual keyboard navigation test passed\n- [ ] Screen reader compatibility verified", "metadata": {}}
{"id": "62", "text": "# Research: Photo Organizer App UI Components\n\n## Decision Summary\n\nThis research resolves the three NEEDS CLARIFICATION items from the spec and establishes the UI component architecture for the React-based photo organizer.\n\n## EXIF Date Handling Strategy\n\n**Decision**: Default to \"Unknown Date\" album for photos without EXIF metadata\n\n**Rationale**:\n\n- Creates predictable user experience - all photos are organized\n- Allows users to manually reorganize if needed\n- Avoids complex date prompting flows that interrupt upload UX\n- Maintains constitutional principle of offline functionality\n\n**Alternatives considered**:\n\n- Upload date fallback: Rejected - would scatter photos across many date-based albums\n- User prompt: Rejected - creates poor UX for batch uploads\n\n## Supported Image Formats\n\n**Decision**: Support JPEG, PNG, WebP, HEIC (via browser support)\n\n**Rationale**:\n\n- JPEG/PNG: Universal browser support for common formats\n- WebP: Modern format with good compression and browser support\n- HEIC: iOS default format, supported by modern browsers\n- RAW files excluded: No native browser support, large file sizes", "metadata": {}}
{"id": "63", "text": "**Alternatives considered**:\n\n- Upload date fallback: Rejected - would scatter photos across many date-based albums\n- User prompt: Rejected - creates poor UX for batch uploads\n\n## Supported Image Formats\n\n**Decision**: Support JPEG, PNG, WebP, HEIC (via browser support)\n\n**Rationale**:\n\n- JPEG/PNG: Universal browser support for common formats\n- WebP: Modern format with good compression and browser support\n- HEIC: iOS default format, supported by modern browsers\n- RAW files excluded: No native browser support, large file sizes\n\n**Alternatives considered**:\n\n- RAW support: Rejected - requires external libraries, violates minimal dependencies principle\n- GIF support: Rejected - not a photography format, adds complexity\n\n## Error Recovery Scenarios\n\n**Decision**: Comprehensive error handling with local storage recovery\n\n**Rationale**:\n\n- Browser refresh: Auto-save to localStorage with recovery prompt\n- Storage full: Graceful degradation with user notification\n- Upload failures: Retry mechanism with progress preservation\n- Data corruption: Backup/restore functionality using ZIP export\n\n**Alternatives considered**:", "metadata": {}}
{"id": "64", "text": "**Alternatives considered**:\n\n- RAW support: Rejected - requires external libraries, violates minimal dependencies principle\n- GIF support: Rejected - not a photography format, adds complexity\n\n## Error Recovery Scenarios\n\n**Decision**: Comprehensive error handling with local storage recovery\n\n**Rationale**:\n\n- Browser refresh: Auto-save to localStorage with recovery prompt\n- Storage full: Graceful degradation with user notification\n- Upload failures: Retry mechanism with progress preservation\n- Data corruption: Backup/restore functionality using ZIP export\n\n**Alternatives considered**:\n\n- No error recovery: Rejected - violates data loss prevention requirement\n- Cloud backup: Rejected - violates constitutional no-cloud principle\n\n## React Component Architecture Research\n\n### Drag-and-Drop Library Selection\n\n**Decision**: @dnd-kit/core for drag-and-drop functionality\n\n**Rationale**:\n\n- Modern, accessible drag-and-drop with keyboard support\n- TypeScript native support\n- Meets WCAG 2.1 AA accessibility requirements\n- Lightweight with tree-shaking support\n\n**Alternatives considered**:", "metadata": {}}
{"id": "65", "text": "**Alternatives considered**:\n\n- No error recovery: Rejected - violates data loss prevention requirement\n- Cloud backup: Rejected - violates constitutional no-cloud principle\n\n## React Component Architecture Research\n\n### Drag-and-Drop Library Selection\n\n**Decision**: @dnd-kit/core for drag-and-drop functionality\n\n**Rationale**:\n\n- Modern, accessible drag-and-drop with keyboard support\n- TypeScript native support\n- Meets WCAG 2.1 AA accessibility requirements\n- Lightweight with tree-shaking support\n\n**Alternatives considered**:\n\n- react-beautiful-dnd: Rejected - accessibility concerns, maintenance status\n- Native HTML5 drag-and-drop: Rejected - poor accessibility, browser inconsistencies\n\n### shadcn/ui Component Selection\n\n**Decision**: Use shadcn/ui components as foundation with custom extensions\n\n**Components to use**:\n\n- Button, Card, Dialog (for ZoomModal)\n- Progress (for upload progress)\n- Skeleton (for loading states)\n- Toast (for notifications)\n\n**Components to build custom**:", "metadata": {}}
{"id": "66", "text": "**Alternatives considered**:\n\n- react-beautiful-dnd: Rejected - accessibility concerns, maintenance status\n- Native HTML5 drag-and-drop: Rejected - poor accessibility, browser inconsistencies\n\n### shadcn/ui Component Selection\n\n**Decision**: Use shadcn/ui components as foundation with custom extensions\n\n**Components to use**:\n\n- Button, Card, Dialog (for ZoomModal)\n- Progress (for upload progress)\n- Skeleton (for loading states)\n- Toast (for notifications)\n\n**Components to build custom**:\n\n- AlbumGrid (custom layout with drag-drop)\n- AlbumTile (custom with thumbnail + metadata)\n- PhotoTileView (custom grid with virtualization)\n- UploadDropzone (custom file handling)\n\n**Rationale**: Balances constitutional preference for shadcn/ui with need for specialized photo UI components\n\n### File Upload Strategy\n\n**Decision**: HTML5 File API with progressive enhancement\n\n**Rationale**:\n\n- Native browser support for file selection and reading\n- EXIF data extraction via exif-js library\n- Drag-and-drop file handling with visual feedback\n- Batch processing with progress indication\n\n**Implementation approach**:", "metadata": {}}
{"id": "67", "text": "- AlbumGrid (custom layout with drag-drop)\n- AlbumTile (custom with thumbnail + metadata)\n- PhotoTileView (custom grid with virtualization)\n- UploadDropzone (custom file handling)\n\n**Rationale**: Balances constitutional preference for shadcn/ui with need for specialized photo UI components\n\n### File Upload Strategy\n\n**Decision**: HTML5 File API with progressive enhancement\n\n**Rationale**:\n\n- Native browser support for file selection and reading\n- EXIF data extraction via exif-js library\n- Drag-and-drop file handling with visual feedback\n- Batch processing with progress indication\n\n**Implementation approach**:\n\n- FileReader API for image processing\n- Canvas API for thumbnail generation\n- Web Workers for EXIF extraction (non-blocking)\n\n## SQLite Integration Research\n\n**Decision**: sql.js with IndexedDB persistence\n\n**Rationale**:\n\n- Pure JavaScript SQLite implementation\n- No external dependencies (constitutional compliance)\n- IndexedDB provides persistent browser storage\n- Supports full SQL functionality for complex queries\n\n**Schema design**:", "metadata": {}}
{"id": "68", "text": "- Native browser support for file selection and reading\n- EXIF data extraction via exif-js library\n- Drag-and-drop file handling with visual feedback\n- Batch processing with progress indication\n\n**Implementation approach**:\n\n- FileReader API for image processing\n- Canvas API for thumbnail generation\n- Web Workers for EXIF extraction (non-blocking)\n\n## SQLite Integration Research\n\n**Decision**: sql.js with IndexedDB persistence\n\n**Rationale**:\n\n- Pure JavaScript SQLite implementation\n- No external dependencies (constitutional compliance)\n- IndexedDB provides persistent browser storage\n- Supports full SQL functionality for complex queries\n\n**Schema design**:\n\n```sql\nCREATE TABLE albums (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  capture_date DATE NOT NULL,\n  display_order INTEGER NOT NULL,\n  thumbnail_photo_id INTEGER\n);\n\nCREATE TABLE photos (\n  id INTEGER PRIMARY KEY,\n  filename TEXT NOT NULL,\n  album_id INTEGER REFERENCES albums(id),\n  file_data BLOB NOT NULL,\n  capture_date DATETIME,\n  file_size INTEGER,\n  width INTEGER,\n  height INTEGER,\n  upload_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```", "metadata": {}}
{"id": "69", "text": "**Schema design**:\n\n```sql\nCREATE TABLE albums (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  capture_date DATE NOT NULL,\n  display_order INTEGER NOT NULL,\n  thumbnail_photo_id INTEGER\n);\n\nCREATE TABLE photos (\n  id INTEGER PRIMARY KEY,\n  filename TEXT NOT NULL,\n  album_id INTEGER REFERENCES albums(id),\n  file_data BLOB NOT NULL,\n  capture_date DATETIME,\n  file_size INTEGER,\n  width INTEGER,\n  height INTEGER,\n  upload_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n## Performance Considerations\n\n**Virtualization Strategy**: React-window for large photo grids\n**Image Optimization**: Canvas-based thumbnail generation at multiple sizes\n**Loading Strategy**: Progressive loading with skeleton states\n**Memory Management**: Lazy loading of full-size images in zoom view\n\n## Accessibility Implementation\n\n**Keyboard Navigation**: Tab order through albums and photos\n**Screen Reader Support**: ARIA labels for all interactive elements\n**Focus Management**: Focus trapping in modal views\n**Alternative Text**: Auto-generated descriptions for photos\n**High Contrast**: Tailwind CSS utilities for contrast compliance\n\n## Testing Strategy", "metadata": {}}
{"id": "70", "text": "## Performance Considerations\n\n**Virtualization Strategy**: React-window for large photo grids\n**Image Optimization**: Canvas-based thumbnail generation at multiple sizes\n**Loading Strategy**: Progressive loading with skeleton states\n**Memory Management**: Lazy loading of full-size images in zoom view\n\n## Accessibility Implementation\n\n**Keyboard Navigation**: Tab order through albums and photos\n**Screen Reader Support**: ARIA labels for all interactive elements\n**Focus Management**: Focus trapping in modal views\n**Alternative Text**: Auto-generated descriptions for photos\n**High Contrast**: Tailwind CSS utilities for contrast compliance\n\n## Testing Strategy\n\n**Component Testing**: React Testing Library for all UI components\n**Integration Testing**: MSW (Mock Service Worker) for file operations\n**Accessibility Testing**: @testing-library/jest-dom for ARIA assertions\n**Visual Testing**: Storybook for component documentation and testing\n**E2E Testing**: Playwright for full user workflows", "metadata": {}}
{"id": "71", "text": "# Feature Specification: Photo Organizer App\n\n**Feature Branch**: `001-build-a-photo`\n**Created**: 2025-09-23\n**Status**: Draft\n**Input**: User description: \"Build a photo organizer app. Users upload local photos (no cloud storage). Auto-group into albums by capture date. Main view: Grid of albums with thumbnails; drag-and-drop to reorder albums (flat structure\u0014no nesting). Inside an album: Tile-view photo previews with zoom on click. Export albums as ZIP.\"\n\n## User Scenarios & Testing\n\n### Primary User Story\n\nA user wants to organize their local photo collection without cloud dependency. They upload photos from their device, and the system automatically groups them into albums by capture date. They can see all albums in a grid layout, reorder them by dragging, browse photos within each album, and export complete albums as ZIP files for backup or sharing.\n\n### Acceptance Scenarios", "metadata": {}}
{"id": "72", "text": "## User Scenarios & Testing\n\n### Primary User Story\n\nA user wants to organize their local photo collection without cloud dependency. They upload photos from their device, and the system automatically groups them into albums by capture date. They can see all albums in a grid layout, reorder them by dragging, browse photos within each album, and export complete albums as ZIP files for backup or sharing.\n\n### Acceptance Scenarios\n\n1. **Given** no photos are uploaded, **When** user accesses the main view, **Then** an empty grid is displayed with upload instructions\n2. **Given** photos are uploaded, **When** photos have different capture dates, **Then** separate albums are automatically created for each date\n3. **Given** multiple albums exist, **When** user drags an album tile, **Then** albums reorder and maintain new position\n4. **Given** user clicks on an album, **When** album opens, **Then** tile view shows all photos from that album\n5. **Given** user clicks on a photo tile, **When** photo opens, **Then** zoomed view displays with navigation controls\n6. **Given** user selects an album, **When** export is triggered, **Then** ZIP file downloads with all album photos", "metadata": {}}
{"id": "73", "text": "### Edge Cases\n\n- What happens when photos lack EXIF capture date metadata?\n- How does system handle duplicate photos (same file, same date)?\n- What occurs when user attempts to drag album during upload process?\n- How does system behave with corrupted or unsupported image files?\n- What happens when export fails due to insufficient storage space?\n\n## Requirements\n\n### Functional Requirements", "metadata": {}}
{"id": "74", "text": "### Edge Cases\n\n- What happens when photos lack EXIF capture date metadata?\n- How does system handle duplicate photos (same file, same date)?\n- What occurs when user attempts to drag album during upload process?\n- How does system behave with corrupted or unsupported image files?\n- What happens when export fails due to insufficient storage space?\n\n## Requirements\n\n### Functional Requirements\n\n- **FR-001**: System MUST allow users to upload multiple photo files from local device storage\n- **FR-002**: System MUST automatically extract capture date from photo EXIF metadata\n- **FR-003**: System MUST automatically group photos into albums based on capture date (one album per date)\n- **FR-004**: System MUST display albums in a grid layout with thumbnail previews\n- **FR-005**: System MUST enable drag-and-drop reordering of album tiles\n- **FR-006**: System MUST maintain flat album structure with no nested folders\n- **FR-007**: System MUST show tile-view photo previews when album is opened\n- **FR-008**: System MUST display zoomed photo view when individual photo is clicked\n- **FR-009**: System MUST provide navigation controls in zoomed view (next,", "metadata": {}}
{"id": "75", "text": "previous, close)\n- **FR-010**: System MUST export selected albums as ZIP files for download\n- **FR-011**: System MUST persist photo organization and album order locally\n- **FR-012**: System MUST handle photos without EXIF date by [NEEDS CLARIFICATION: default album strategy - upload date, \"Unknown Date\" album, or user prompt?]\n- **FR-013**: System MUST support common image formats [NEEDS CLARIFICATION: specific formats - JPEG, PNG, HEIC, RAW files?]\n- **FR-014**: System MUST prevent data loss during [NEEDS CLARIFICATION: error scenarios - browser refresh, network issues, storage full?]\n\n### Key Entities\n\n- **Photo**: Individual image file with metadata (filename, capture date, file size, dimensions, upload timestamp)\n- **Album**: Collection of photos grouped by capture date with display order, thumbnail image, photo count\n- **Upload Session**: Temporary state during photo import with progress tracking, error handling\n\n## Review & Acceptance Checklist\n\n### Content Quality", "metadata": {}}
{"id": "76", "text": "- **FR-014**: System MUST prevent data loss during [NEEDS CLARIFICATION: error scenarios - browser refresh, network issues, storage full?]\n\n### Key Entities\n\n- **Photo**: Individual image file with metadata (filename, capture date, file size, dimensions, upload timestamp)\n- **Album**: Collection of photos grouped by capture date with display order, thumbnail image, photo count\n- **Upload Session**: Temporary state during photo import with progress tracking, error handling\n\n## Review & Acceptance Checklist\n\n### Content Quality\n\n- [x] No implementation details (languages, frameworks, APIs)\n- [x] Focused on user value and business needs\n- [x] Written for non-technical stakeholders\n- [x] All mandatory sections completed\n\n### Requirement Completeness\n\n- [ ] No [NEEDS CLARIFICATION] markers remain\n- [x] Requirements are testable and unambiguous\n- [x] Success criteria are measurable\n- [x] Scope is clearly bounded\n- [x] Dependencies and assumptions identified\n\n## Execution Status", "metadata": {}}
{"id": "77", "text": "## Review & Acceptance Checklist\n\n### Content Quality\n\n- [x] No implementation details (languages, frameworks, APIs)\n- [x] Focused on user value and business needs\n- [x] Written for non-technical stakeholders\n- [x] All mandatory sections completed\n\n### Requirement Completeness\n\n- [ ] No [NEEDS CLARIFICATION] markers remain\n- [x] Requirements are testable and unambiguous\n- [x] Success criteria are measurable\n- [x] Scope is clearly bounded\n- [x] Dependencies and assumptions identified\n\n## Execution Status\n\n- [x] User description parsed\n- [x] Key concepts extracted\n- [x] Ambiguities marked\n- [x] User scenarios defined\n- [x] Requirements generated\n- [x] Entities identified\n- [ ] Review checklist passed", "metadata": {}}
{"id": "78", "text": "# Tasks: Photo Organizer App - Main Landing Page\n\n**Input**: Design documents from `/specs/001-build-a-photo/`\n**Prerequisites**: plan.md (required), research.md, data-model.md, contracts/\n\n## Format: `[ID] [P?] Description`\n- **[P]**: Can run in parallel (different files, no dependencies)\n- Include exact file paths in descriptions\n\n## Path Conventions\n- **Single project**: `src/`, `tests/` at repository root (React SPA)\n- Paths assume single project structure per plan.md\n\n## Phase 3.1: Project Setup", "metadata": {}}
{"id": "79", "text": "# Tasks: Photo Organizer App - Main Landing Page\n\n**Input**: Design documents from `/specs/001-build-a-photo/`\n**Prerequisites**: plan.md (required), research.md, data-model.md, contracts/\n\n## Format: `[ID] [P?] Description`\n- **[P]**: Can run in parallel (different files, no dependencies)\n- Include exact file paths in descriptions\n\n## Path Conventions\n- **Single project**: `src/`, `tests/` at repository root (React SPA)\n- Paths assume single project structure per plan.md\n\n## Phase 3.1: Project Setup\n\n- [x] T001 Initialize React TypeScript project with Vite build system in repository root\n- [x] T002 Install core dependencies: React 18+, TypeScript, Tailwind CSS, @dnd-kit/core, sql.js\n- [x] T003 [P] Configure Tailwind CSS with shadcn/ui component library integration\n- [x] T004 [P] Setup Vitest with React Testing Library for 100% test coverage\n- [x] T005 [P] Configure ESLint, Prettier, and TypeScript strict mode\n- [x] T006 [P] Setup Storybook for component development and documentation", "metadata": {}}
{"id": "80", "text": "## Phase 3.2: Mock Data and Types (TDD) ⚠️ MUST COMPLETE BEFORE 3.3\n\n**CRITICAL: These setup tasks MUST be completed before any component implementation**\n\n- [x] T007 [P] Create mock album data generator in src/mocks/albums.ts\n- [x] T008 [P] Create TypeScript interfaces in src/types/index.ts from contracts\n- [x] T009 [P] Setup test utilities and custom render functions in tests/utils.tsx\n- [x] T010 [P] Create mock photo data with thumbnail URLs in src/mocks/photos.ts\n\n## Phase 3.3: Core UI Components Tests (TDD)\n\n**CRITICAL: These tests MUST be written and MUST FAIL before ANY implementation**", "metadata": {}}
{"id": "81", "text": "- [x] T007 [P] Create mock album data generator in src/mocks/albums.ts\n- [x] T008 [P] Create TypeScript interfaces in src/types/index.ts from contracts\n- [x] T009 [P] Setup test utilities and custom render functions in tests/utils.tsx\n- [x] T010 [P] Create mock photo data with thumbnail URLs in src/mocks/photos.ts\n\n## Phase 3.3: Core UI Components Tests (TDD)\n\n**CRITICAL: These tests MUST be written and MUST FAIL before ANY implementation**\n\n- [x] T011 [P] Album Grid component test in tests/components/AlbumGrid.test.tsx\n- [x] T012 [P] Album Tile component test in tests/components/AlbumTile.test.tsx\n- [x] T013 [P] Infinite scroll hook test in tests/hooks/useInfiniteScroll.test.tsx\n- [x] T014 [P] Mock data service test in tests/services/MockDataService.test.tsx\n\n## Phase 3.4: Landing Page Layout (ONLY after tests are failing)", "metadata": {}}
{"id": "82", "text": "**CRITICAL: These tests MUST be written and MUST FAIL before ANY implementation**\n\n- [x] T011 [P] Album Grid component test in tests/components/AlbumGrid.test.tsx\n- [x] T012 [P] Album Tile component test in tests/components/AlbumTile.test.tsx\n- [x] T013 [P] Infinite scroll hook test in tests/hooks/useInfiniteScroll.test.tsx\n- [x] T014 [P] Mock data service test in tests/services/MockDataService.test.tsx\n\n## Phase 3.4: Landing Page Layout (ONLY after tests are failing)\n\n- [x] T015 Create main App component with routing setup in src/App.tsx\n- [x] T016 Create Layout component with header and navigation in src/components/Layout/index.tsx\n- [x] T017 Create Landing Page container component in src/pages/LandingPage.tsx\n- [x] T018 Implement responsive 3-column grid system with Tailwind CSS\n\n## Phase 3.5: Album Grid Implementation", "metadata": {}}
{"id": "83", "text": "## Phase 3.4: Landing Page Layout (ONLY after tests are failing)\n\n- [x] T015 Create main App component with routing setup in src/App.tsx\n- [x] T016 Create Layout component with header and navigation in src/components/Layout/index.tsx\n- [x] T017 Create Landing Page container component in src/pages/LandingPage.tsx\n- [x] T018 Implement responsive 3-column grid system with Tailwind CSS\n\n## Phase 3.5: Album Grid Implementation\n\n- [x] T019 [P] Implement AlbumTile component with shadcn/ui Card in src/components/AlbumTile/index.tsx\n- [x] T020 [P] Create thumbnail display with lazy loading in AlbumTile component\n- [x] T021 Implement AlbumGrid container component in src/components/AlbumGrid/index.tsx\n- [x] T022 Add CSS Grid layout with responsive breakpoints (3 columns desktop, 2 tablet, 1 mobile)\n\n## Phase 3.6: Infinite Loading Implementation", "metadata": {}}
{"id": "84", "text": "## Phase 3.5: Album Grid Implementation\n\n- [x] T019 [P] Implement AlbumTile component with shadcn/ui Card in src/components/AlbumTile/index.tsx\n- [x] T020 [P] Create thumbnail display with lazy loading in AlbumTile component\n- [x] T021 Implement AlbumGrid container component in src/components/AlbumGrid/index.tsx\n- [x] T022 Add CSS Grid layout with responsive breakpoints (3 columns desktop, 2 tablet, 1 mobile)\n\n## Phase 3.6: Infinite Loading Implementation\n\n- [x] T023 [P] Create useInfiniteScroll custom hook in src/hooks/useInfiniteScroll.ts\n- [x] T024 [P] Implement IntersectionObserver logic for scroll detection\n- [x] T025 Integrate infinite loading with AlbumGrid component\n- [x] T026 Add loading spinner using shadcn/ui components during pagination\n\n## Phase 3.7: Mock Data Service", "metadata": {}}
{"id": "85", "text": "## Phase 3.6: Infinite Loading Implementation\n\n- [x] T023 [P] Create useInfiniteScroll custom hook in src/hooks/useInfiniteScroll.ts\n- [x] T024 [P] Implement IntersectionObserver logic for scroll detection\n- [x] T025 Integrate infinite loading with AlbumGrid component\n- [x] T026 Add loading spinner using shadcn/ui components during pagination\n\n## Phase 3.7: Mock Data Service\n\n- [x] T027 [P] Create MockDataService class in src/services/MockDataService.ts\n- [x] T028 [P] Implement paginated album fetching with simulated delays\n- [x] T029 Connect MockDataService to AlbumGrid via React hooks\n- [x] T030 Add error handling and retry logic for data fetching\n\n## Phase 3.8: Accessibility and Polish", "metadata": {}}
{"id": "86", "text": "## Phase 3.7: Mock Data Service\n\n- [x] T027 [P] Create MockDataService class in src/services/MockDataService.ts\n- [x] T028 [P] Implement paginated album fetching with simulated delays\n- [x] T029 Connect MockDataService to AlbumGrid via React hooks\n- [x] T030 Add error handling and retry logic for data fetching\n\n## Phase 3.8: Accessibility and Polish\n\n- [x] T031 [P] Add ARIA labels and keyboard navigation to AlbumGrid\n- [x] T032 [P] Implement focus management for infinite scroll\n- [x] T033 [P] Add loading states with proper ARIA live regions\n- [x] T034 [P] Create Storybook stories for AlbumGrid and AlbumTile components\n- [x] T035 Test with screen reader and keyboard-only navigation\n\n## Phase 3.9: Integration and Performance", "metadata": {}}
{"id": "87", "text": "## Phase 3.8: Accessibility and Polish\n\n- [x] T031 [P] Add ARIA labels and keyboard navigation to AlbumGrid\n- [x] T032 [P] Implement focus management for infinite scroll\n- [x] T033 [P] Add loading states with proper ARIA live regions\n- [x] T034 [P] Create Storybook stories for AlbumGrid and AlbumTile components\n- [x] T035 Test with screen reader and keyboard-only navigation\n\n## Phase 3.9: Integration and Performance\n\n- [x] T036 Add performance monitoring for infinite scroll performance\n- [x] T037 Implement virtualization for large album lists (react-window integration)\n- [x] T038 Add image preloading for smooth user experience\n- [x] T039 Optimize bundle size and implement code splitting\n\n## Phase 3.10: Testing and Validation", "metadata": {}}
{"id": "88", "text": "## Phase 3.9: Integration and Performance\n\n- [x] T036 Add performance monitoring for infinite scroll performance\n- [x] T037 Implement virtualization for large album lists (react-window integration)\n- [x] T038 Add image preloading for smooth user experience\n- [x] T039 Optimize bundle size and implement code splitting\n\n## Phase 3.10: Testing and Validation\n\n- [x] T040 [P] Run full test suite and achieve 100% coverage\n- [x] T041 [P] Execute Lighthouse performance audit (target: 90+ scores)\n- [x] T042 [P] Validate WCAG 2.1 AA compliance with axe-core\n- [x] T043 Manual testing of 3-column responsive grid on different screen sizes\n- [x] T044 Load testing with 1000+ mock albums for infinite scroll performance\n\n## Dependencies\n\n**Setup Dependencies**:\n- T001 blocks T002-T006\n- T007-T010 must complete before T011-T014\n- T011-T014 (tests) must complete before T015-T044", "metadata": {}}
{"id": "89", "text": "## Dependencies\n\n**Setup Dependencies**:\n- T001 blocks T002-T006\n- T007-T010 must complete before T011-T014\n- T011-T014 (tests) must complete before T015-T044\n\n**Component Dependencies**:\n- T015-T018 (layout) before T019-T022 (album components)\n- T019-T020 (AlbumTile) before T021-T022 (AlbumGrid)\n- T023-T024 (infinite scroll hook) before T025-T026 (integration)\n- T027-T028 (data service) before T029-T030 (connection)\n\n**Parallel Execution Groups**:\n- Setup: T003, T004, T005, T006\n- Mock Data: T007, T008, T009, T010\n- Tests: T011, T012, T013, T014\n- Components: T019, T020 (different files)\n- Services: T027, T028 (different concerns)\n- Polish: T031, T032, T033, T034, T040, T041, T042\n\n## Parallel Execution Examples", "metadata": {}}
{"id": "90", "text": "**Parallel Execution Groups**:\n- Setup: T003, T004, T005, T006\n- Mock Data: T007, T008, T009, T010\n- Tests: T011, T012, T013, T014\n- Components: T019, T020 (different files)\n- Services: T027, T028 (different concerns)\n- Polish: T031, T032, T033, T034, T040, T041, T042\n\n## Parallel Execution Examples\n\n```\n# Launch T007-T010 together for mock data setup:\nTask: \"Create mock album data generator in src/mocks/albums.ts\"\nTask: \"Create TypeScript interfaces in src/types/index.ts from contracts\"\nTask: \"Setup test utilities and custom render functions in tests/utils.tsx\"\nTask: \"Create mock photo data with thumbnail URLs in src/mocks/photos.ts\"\n```", "metadata": {}}
{"id": "91", "text": "## Parallel Execution Examples\n\n```\n# Launch T007-T010 together for mock data setup:\nTask: \"Create mock album data generator in src/mocks/albums.ts\"\nTask: \"Create TypeScript interfaces in src/types/index.ts from contracts\"\nTask: \"Setup test utilities and custom render functions in tests/utils.tsx\"\nTask: \"Create mock photo data with thumbnail URLs in src/mocks/photos.ts\"\n```\n\n```\n# Launch T011-T014 together for test creation:\nTask: \"Album Grid component test in tests/components/AlbumGrid.test.tsx\"\nTask: \"Album Tile component test in tests/components/AlbumTile.test.tsx\"\nTask: \"Infinite scroll hook test in tests/hooks/useInfiniteScroll.test.tsx\"\nTask: \"Mock data service test in tests/services/MockDataService.test.tsx\"\n```\n\n## Notes", "metadata": {}}
{"id": "92", "text": "```\n# Launch T011-T014 together for test creation:\nTask: \"Album Grid component test in tests/components/AlbumGrid.test.tsx\"\nTask: \"Album Tile component test in tests/components/AlbumTile.test.tsx\"\nTask: \"Infinite scroll hook test in tests/hooks/useInfiniteScroll.test.tsx\"\nTask: \"Mock data service test in tests/services/MockDataService.test.tsx\"\n```\n\n## Notes\n\n- **Mock Data First**: All components use mock data before database integration\n- **3-Column Grid**: CSS Grid with responsive breakpoints for desktop/tablet/mobile\n- **Infinite Loading**: Uses IntersectionObserver API for performance\n- **TDD Enforced**: All tests must fail before implementation begins\n- **Accessibility Required**: WCAG 2.1 AA compliance validated before completion\n- **Performance Target**: 60fps scrolling, <100ms interaction times\n\n## Task Generation Rules Applied", "metadata": {}}
{"id": "93", "text": "## Notes\n\n- **Mock Data First**: All components use mock data before database integration\n- **3-Column Grid**: CSS Grid with responsive breakpoints for desktop/tablet/mobile\n- **Infinite Loading**: Uses IntersectionObserver API for performance\n- **TDD Enforced**: All tests must fail before implementation begins\n- **Accessibility Required**: WCAG 2.1 AA compliance validated before completion\n- **Performance Target**: 60fps scrolling, <100ms interaction times\n\n## Task Generation Rules Applied\n\n1. **From Contracts**: AlbumGridProps and AlbumTileProps → component tests and implementations\n2. **From Data Model**: Album entity → mock data generation and TypeScript interfaces\n3. **From User Requirements**: 3-column grid + infinite loading → specific UI implementation tasks\n4. **From Constitutional Requirements**: 100% test coverage + accessibility → comprehensive testing tasks\n\n## Validation Checklist", "metadata": {}}
{"id": "94", "text": "## Task Generation Rules Applied\n\n1. **From Contracts**: AlbumGridProps and AlbumTileProps → component tests and implementations\n2. **From Data Model**: Album entity → mock data generation and TypeScript interfaces\n3. **From User Requirements**: 3-column grid + infinite loading → specific UI implementation tasks\n4. **From Constitutional Requirements**: 100% test coverage + accessibility → comprehensive testing tasks\n\n## Validation Checklist\n\n- [x] All component contracts have corresponding tests\n- [x] All UI requirements have implementation tasks\n- [x] All tests come before implementation (TDD)\n- [x] Parallel tasks are truly independent files\n- [x] Each task specifies exact file path\n- [x] No task modifies same file as another [P] task\n- [x] Landing page focus with 3-column grid and infinite loading addressed", "metadata": {}}
{"id": "95", "text": "# Data Model: Image Detail View\n\n**Feature**: Image Detail View (002-user-can-click)\n**Date**: 2025-09-26\n\n## Core Entities\n\n### Image\n\nRepresents a single photo with all associated metadata.", "metadata": {}}
{"id": "96", "text": "# Data Model: Image Detail View\n\n**Feature**: Image Detail View (002-user-can-click)\n**Date**: 2025-09-26\n\n## Core Entities\n\n### Image\n\nRepresents a single photo with all associated metadata.\n\n**Fields**:\n- `id`: string (UUID) - Unique identifier\n- `filename`: string - Original filename\n- `path`: string - File path in local storage\n- `url`: string - Display URL (blob or data URL)\n- `caption`: string? - Optional user-added caption\n- `uploadedBy`: string - User ID who uploaded\n- `uploadedAt`: DateTime - Upload timestamp\n- `capturedAt`: DateTime? - Original capture date from EXIF\n- `fileSize`: number - Size in bytes\n- `width`: number? - Image width in pixels\n- `height`: number? - Image height in pixels\n- `mimeType`: string - e.g., \"image/jpeg\"\n- `cameraModel`: string? - From EXIF data\n- `location`: string? - GPS coordinates from EXIF\n- `tags`: string[] - User-defined tags", "metadata": {}}
{"id": "97", "text": "**Validation Rules**:\n- `id`: Required, valid UUID\n- `filename`: Required, max 255 chars\n- `path`: Required, must exist\n- `uploadedBy`: Required, valid user ID\n- `uploadedAt`: Required, past date\n- `fileSize`: Required, positive integer\n- `mimeType`: Required, valid image type\n\n### User\n\nRepresents the user who uploaded images.\n\n**Fields**:\n- `id`: string (UUID) - Unique identifier\n- `username`: string - Unique username\n- `displayName`: string? - Display name\n- `email`: string - Email address\n- `avatarUrl`: string? - Profile picture URL\n\n**Validation Rules**:\n- `id`: Required, valid UUID\n- `username`: Required, 3-30 chars, alphanumeric + underscore\n- `email`: Required, valid email format\n\n## State Models\n\n### ImageDetailState\n\nState for the image detail modal.", "metadata": {}}
{"id": "98", "text": "### User\n\nRepresents the user who uploaded images.\n\n**Fields**:\n- `id`: string (UUID) - Unique identifier\n- `username`: string - Unique username\n- `displayName`: string? - Display name\n- `email`: string - Email address\n- `avatarUrl`: string? - Profile picture URL\n\n**Validation Rules**:\n- `id`: Required, valid UUID\n- `username`: Required, 3-30 chars, alphanumeric + underscore\n- `email`: Required, valid email format\n\n## State Models\n\n### ImageDetailState\n\nState for the image detail modal.\n\n```typescript\ninterface ImageDetailState {\n  isOpen: boolean;\n  selectedImage: Image | null;\n  isLoading: boolean;\n  error: string | null;\n}\n```\n\n### GalleryState\n\nExtended gallery state to support detail view.\n\n```typescript\ninterface GalleryState {\n  images: Image[];\n  filters: GalleryFilters;\n  selectedImageId: string | null;\n  isDetailOpen: boolean;\n}\n```\n\n## Data Flow", "metadata": {}}
{"id": "99", "text": "## State Models\n\n### ImageDetailState\n\nState for the image detail modal.\n\n```typescript\ninterface ImageDetailState {\n  isOpen: boolean;\n  selectedImage: Image | null;\n  isLoading: boolean;\n  error: string | null;\n}\n```\n\n### GalleryState\n\nExtended gallery state to support detail view.\n\n```typescript\ninterface GalleryState {\n  images: Image[];\n  filters: GalleryFilters;\n  selectedImageId: string | null;\n  isDetailOpen: boolean;\n}\n```\n\n## Data Flow\n\n1. **User clicks image** → Gallery updates `selectedImageId` and `isDetailOpen`\n2. **Modal opens** → Fetches full image data if not cached\n3. **User closes modal** → Updates `isDetailOpen` to false\n4. **Navigation persists** → Gallery state remains unchanged\n\n## Relationships\n\n- **Image → User**: Many-to-one (many images per user)\n- **Image → Tags**: Many-to-many (via junction table)\n\n## Schema Evolution", "metadata": {}}
{"id": "100", "text": "## Data Flow\n\n1. **User clicks image** → Gallery updates `selectedImageId` and `isDetailOpen`\n2. **Modal opens** → Fetches full image data if not cached\n3. **User closes modal** → Updates `isDetailOpen` to false\n4. **Navigation persists** → Gallery state remains unchanged\n\n## Relationships\n\n- **Image → User**: Many-to-one (many images per user)\n- **Image → Tags**: Many-to-many (via junction table)\n\n## Schema Evolution\n\nThis feature extends the existing image schema without breaking changes:\n- Adds optional EXIF fields (cameraModel, location)\n- Maintains backward compatibility with existing images\n\n## Performance Considerations\n\n- Lazy load image details only when needed\n- Cache image metadata to avoid repeated EXIF reading\n- Consider pagination for very large galleries", "metadata": {}}
{"id": "101", "text": "# Implementation Plan: Image Detail View\n\n**Branch**: `002-user-can-click` | **Date**: 2025-09-26 | **Spec**: `/specs/002-user-can-click/spec.md`\n**Input**: Feature specification from `/specs/[###-feature-name]/spec.md`\n\n## Execution Flow (/plan command scope)\n\n```\n1. Load feature spec from Input path\n   → If not found: ERROR \"No feature spec at {path}\"\n2. Fill Technical Context (scan for NEEDS CLARIFICATION)\n   → Detect Project Type from context (web=frontend+backend, mobile=app+api)\n   → Set Structure Decision based on project type\n3. Fill the Constitution Check section based on the content of the constitution document.\n4. Evaluate Constitution Check section below\n   → If violations exist: Document in Complexity Tracking\n   → If no justification possible: ERROR \"Simplify approach first\"\n   → Update Progress Tracking: Initial Constitution Check\n5. Execute Phase 0 → research.md\n   → If NEEDS CLARIFICATION remain: ERROR \"Resolve unknowns\"\n6.", "metadata": {}}
{"id": "102", "text": "Fill the Constitution Check section based on the content of the constitution document.\n4. Evaluate Constitution Check section below\n   → If violations exist: Document in Complexity Tracking\n   → If no justification possible: ERROR \"Simplify approach first\"\n   → Update Progress Tracking: Initial Constitution Check\n5. Execute Phase 0 → research.md\n   → If NEEDS CLARIFICATION remain: ERROR \"Resolve unknowns\"\n6. Execute Phase 1 → contracts, data-model.md, quickstart.md, agent-specific template file (e.g., `CLAUDE.md` for Claude Code, `.github/copilot-instructions.md` for GitHub Copilot, `GEMINI.md` for Gemini CLI, `QWEN.md` for Qwen Code or `AGENTS.md` for opencode).\n7. Re-evaluate Constitution Check section\n   → If new violations: Refactor design, return to Phase 1\n   → Update Progress Tracking: Post-Design Constitution Check\n8. Plan Phase 2 → Describe task generation approach (DO NOT create tasks.md)\n9. STOP - Ready for /tasks command\n```", "metadata": {}}
{"id": "103", "text": "7. Re-evaluate Constitution Check section\n   → If new violations: Refactor design, return to Phase 1\n   → Update Progress Tracking: Post-Design Constitution Check\n8. Plan Phase 2 → Describe task generation approach (DO NOT create tasks.md)\n9. STOP - Ready for /tasks command\n```\n\n**IMPORTANT**: The /plan command STOPS at step 7. Phases 2-4 are executed by other commands:\n\n- Phase 2: /tasks command creates tasks.md\n- Phase 3-4: Implementation execution (manual or via tools)\n\n## Summary\n\nCreate an image detail view that allows users to click on any photo in the gallery to view it in a focused 2-column layout with the image on the left and metadata (uploader info, date/time) on the right. This feature requires implementing navigation between gallery and detail views while maintaining the offline-first, React-based architecture.\n\n## Technical Context", "metadata": {}}
{"id": "104", "text": "**IMPORTANT**: The /plan command STOPS at step 7. Phases 2-4 are executed by other commands:\n\n- Phase 2: /tasks command creates tasks.md\n- Phase 3-4: Implementation execution (manual or via tools)\n\n## Summary\n\nCreate an image detail view that allows users to click on any photo in the gallery to view it in a focused 2-column layout with the image on the left and metadata (uploader info, date/time) on the right. This feature requires implementing navigation between gallery and detail views while maintaining the offline-first, React-based architecture.\n\n## Technical Context\n\n**Language/Version**: TypeScript with React 18+\n**Primary Dependencies**: React, TypeScript, Tailwind CSS, shadcn/ui components\n**Storage**: SQLite (local database)\n**Testing**: Vitest with React Testing Library\n**Target Platform**: Web browser\n**Project Type**: web (frontend application)\n**Performance Goals**: <100ms for detail view transitions, responsive 2-column layout\n**Constraints**: Offline-first, 100% test coverage, WCAG 2.1 AA compliance\n**Scale/Scope**: Single feature addition to existing photo app, focused on UI component and routing", "metadata": {}}
{"id": "105", "text": "## Technical Context\n\n**Language/Version**: TypeScript with React 18+\n**Primary Dependencies**: React, TypeScript, Tailwind CSS, shadcn/ui components\n**Storage**: SQLite (local database)\n**Testing**: Vitest with React Testing Library\n**Target Platform**: Web browser\n**Project Type**: web (frontend application)\n**Performance Goals**: <100ms for detail view transitions, responsive 2-column layout\n**Constraints**: Offline-first, 100% test coverage, WCAG 2.1 AA compliance\n**Scale/Scope**: Single feature addition to existing photo app, focused on UI component and routing\n\n## Constitution Check\n\n*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*\n\n### Required Compliance", "metadata": {}}
{"id": "106", "text": "## Constitution Check\n\n*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*\n\n### Required Compliance\n\n- **I. React Component Architecture**: ✓ Compliant - Detail view will be a React component\n- **II. 100% Test Coverage**: ✓ Compliant - All code will have tests before implementation\n- **III. Accessibility First**: ✓ Compliant - ARIA labels, keyboard navigation included\n- **IV. Local SQLite Storage**: ✓ Compliant - Uses existing SQLite photo storage\n- **V. Modern React Ecosystem**: ✓ Compliant - Uses shadcn/ui, Tailwind, TypeScript\n\n### Potential Issues\n\n- None identified\n\n## Project Structure\n\n### Documentation (this feature)", "metadata": {}}
{"id": "107", "text": "### Required Compliance\n\n- **I. React Component Architecture**: ✓ Compliant - Detail view will be a React component\n- **II. 100% Test Coverage**: ✓ Compliant - All code will have tests before implementation\n- **III. Accessibility First**: ✓ Compliant - ARIA labels, keyboard navigation included\n- **IV. Local SQLite Storage**: ✓ Compliant - Uses existing SQLite photo storage\n- **V. Modern React Ecosystem**: ✓ Compliant - Uses shadcn/ui, Tailwind, TypeScript\n\n### Potential Issues\n\n- None identified\n\n## Project Structure\n\n### Documentation (this feature)\n\n```\nspecs/[###-feature]/\n├── plan.md              # This file (/plan command output)\n├── research.md          # Phase 0 output (/plan command)\n├── data-model.md        # Phase 1 output (/plan command)\n├── quickstart.md        # Phase 1 output (/plan command)\n├── contracts/           # Phase 1 output (/plan command)\n└── tasks.md             # Phase 2 output (/tasks command - NOT created by /plan)\n```", "metadata": {}}
{"id": "108", "text": "### Potential Issues\n\n- None identified\n\n## Project Structure\n\n### Documentation (this feature)\n\n```\nspecs/[###-feature]/\n├── plan.md              # This file (/plan command output)\n├── research.md          # Phase 0 output (/plan command)\n├── data-model.md        # Phase 1 output (/plan command)\n├── quickstart.md        # Phase 1 output (/plan command)\n├── contracts/           # Phase 1 output (/plan command)\n└── tasks.md             # Phase 2 output (/tasks command - NOT created by /plan)\n```\n\n### Source Code (repository root)\n\n```\n# Option 1: Single project (current structure)\nsrc/\n├── components/\n│   ├── ImageGallery/\n│   ├── ImageDetail/  # New\n│   └── shared/\n├── pages/\n│   ├── GalleryPage/\n│   └── ImageDetailPage/  # New\n├── hooks/\n├── services/\n├── types/\n└── utils/", "metadata": {}}
{"id": "109", "text": "### Source Code (repository root)\n\n```\n# Option 1: Single project (current structure)\nsrc/\n├── components/\n│   ├── ImageGallery/\n│   ├── ImageDetail/  # New\n│   └── shared/\n├── pages/\n│   ├── GalleryPage/\n│   └── ImageDetailPage/  # New\n├── hooks/\n├── services/\n├── types/\n└── utils/\n\ntests/\n├── components/\n├── pages/\n└── services/\n```\n\n**Structure Decision**: Option 1 (Single project) - This is a feature addition to existing web app\n\n## Phase 0: Outline & Research\n\n1. **Extract unknowns from Technical Context** above:\n   - For each NEEDS CLARIFICATION → research task\n   - For each dependency → best practices task\n   - For each integration → patterns task\n\n2. **Generate and dispatch research agents**:", "metadata": {}}
{"id": "110", "text": "tests/\n├── components/\n├── pages/\n└── services/\n```\n\n**Structure Decision**: Option 1 (Single project) - This is a feature addition to existing web app\n\n## Phase 0: Outline & Research\n\n1. **Extract unknowns from Technical Context** above:\n   - For each NEEDS CLARIFICATION → research task\n   - For each dependency → best practices task\n   - For each integration → patterns task\n\n2. **Generate and dispatch research agents**:\n\n   ```\n   For each unknown in Technical Context:\n     Task: \"Research {unknown} for {feature context}\"\n   For each technology choice:\n     Task: \"Find best practices for {tech} in {domain}\"\n   ```\n\n3. **Consolidate findings** in `research.md` using format:\n   - Decision: [what was chosen]\n   - Rationale: [why chosen]\n   - Alternatives considered: [what else evaluated]\n\n**Output**: research.md with all NEEDS CLARIFICATION resolved\n\n## Phase 1: Design & Contracts\n\n*Prerequisites: research.md complete*", "metadata": {}}
{"id": "111", "text": "```\n   For each unknown in Technical Context:\n     Task: \"Research {unknown} for {feature context}\"\n   For each technology choice:\n     Task: \"Find best practices for {tech} in {domain}\"\n   ```\n\n3. **Consolidate findings** in `research.md` using format:\n   - Decision: [what was chosen]\n   - Rationale: [why chosen]\n   - Alternatives considered: [what else evaluated]\n\n**Output**: research.md with all NEEDS CLARIFICATION resolved\n\n## Phase 1: Design & Contracts\n\n*Prerequisites: research.md complete*\n\n1. **Extract entities from feature spec** → `data-model.md`:\n   - Entity name, fields, relationships\n   - Validation rules from requirements\n   - State transitions if applicable\n\n2. **Generate API contracts** from functional requirements:\n   - For each user action → endpoint\n   - Use standard REST/GraphQL patterns\n   - Output OpenAPI/GraphQL schema to `/contracts/`", "metadata": {}}
{"id": "112", "text": "**Output**: research.md with all NEEDS CLARIFICATION resolved\n\n## Phase 1: Design & Contracts\n\n*Prerequisites: research.md complete*\n\n1. **Extract entities from feature spec** → `data-model.md`:\n   - Entity name, fields, relationships\n   - Validation rules from requirements\n   - State transitions if applicable\n\n2. **Generate API contracts** from functional requirements:\n   - For each user action → endpoint\n   - Use standard REST/GraphQL patterns\n   - Output OpenAPI/GraphQL schema to `/contracts/`\n\n3. **Generate contract tests** from contracts:\n   - One test file per endpoint\n   - Assert request/response schemas\n   - Tests must fail (no implementation yet)\n\n4. **Extract test scenarios** from user stories:\n   - Each story → integration test scenario\n   - Quickstart test = story validation steps", "metadata": {}}
{"id": "113", "text": "2. **Generate API contracts** from functional requirements:\n   - For each user action → endpoint\n   - Use standard REST/GraphQL patterns\n   - Output OpenAPI/GraphQL schema to `/contracts/`\n\n3. **Generate contract tests** from contracts:\n   - One test file per endpoint\n   - Assert request/response schemas\n   - Tests must fail (no implementation yet)\n\n4. **Extract test scenarios** from user stories:\n   - Each story → integration test scenario\n   - Quickstart test = story validation steps\n\n5. **Update agent file incrementally** (O(1) operation):\n   - Run `.specify/scripts/bash/update-agent-context.sh claude`\n     **IMPORTANT**: Execute it exactly as specified above. Do not add or remove any arguments.\n   - If exists: Add only NEW tech from current plan\n   - Preserve manual additions between markers\n   - Update recent changes (keep last 3)\n   - Keep under 150 lines for token efficiency\n   - Output to repository root\n\n**Output**: data-model.md, /contracts/*, failing tests, quickstart.md, agent-specific file", "metadata": {}}
{"id": "114", "text": "5. **Update agent file incrementally** (O(1) operation):\n   - Run `.specify/scripts/bash/update-agent-context.sh claude`\n     **IMPORTANT**: Execute it exactly as specified above. Do not add or remove any arguments.\n   - If exists: Add only NEW tech from current plan\n   - Preserve manual additions between markers\n   - Update recent changes (keep last 3)\n   - Keep under 150 lines for token efficiency\n   - Output to repository root\n\n**Output**: data-model.md, /contracts/*, failing tests, quickstart.md, agent-specific file\n\n## Phase 2: Task Planning Approach\n\n*This section describes what the /tasks command will do - DO NOT execute during /plan*\n\n**Task Generation Strategy**:\n\n- Load `.specify/templates/tasks-template.md` as base\n- Generate tasks from Phase 1 design docs (contracts, data model, quickstart)\n- Each contract → contract test task [P]\n- Each entity → model creation task [P]\n- Each user story → integration test task\n- Implementation tasks to make tests pass\n\n**Ordering Strategy**:", "metadata": {}}
{"id": "115", "text": "## Phase 2: Task Planning Approach\n\n*This section describes what the /tasks command will do - DO NOT execute during /plan*\n\n**Task Generation Strategy**:\n\n- Load `.specify/templates/tasks-template.md` as base\n- Generate tasks from Phase 1 design docs (contracts, data model, quickstart)\n- Each contract → contract test task [P]\n- Each entity → model creation task [P]\n- Each user story → integration test task\n- Implementation tasks to make tests pass\n\n**Ordering Strategy**:\n\n- TDD order: Tests before implementation\n- Dependency order: Models before services before UI\n- Mark [P] for parallel execution (independent files)\n\n**Estimated Output**: 25-30 numbered, ordered tasks in tasks.md\n\n**IMPORTANT**: This phase is executed by the /tasks command, NOT by /plan\n\n## Phase 3+: Future Implementation\n\n*These phases are beyond the scope of the /plan command*", "metadata": {}}
{"id": "116", "text": "**Ordering Strategy**:\n\n- TDD order: Tests before implementation\n- Dependency order: Models before services before UI\n- Mark [P] for parallel execution (independent files)\n\n**Estimated Output**: 25-30 numbered, ordered tasks in tasks.md\n\n**IMPORTANT**: This phase is executed by the /tasks command, NOT by /plan\n\n## Phase 3+: Future Implementation\n\n*These phases are beyond the scope of the /plan command*\n\n**Phase 3**: Task execution (/tasks command creates tasks.md)  \n**Phase 4**: Implementation (execute tasks.md following constitutional principles)  \n**Phase 5**: Validation (run tests, execute quickstart.md, performance validation)\n\n## Complexity Tracking\n\n*Fill ONLY if Constitution Check has violations that must be justified*\n\n| Violation | Why Needed | Simpler Alternative Rejected Because |\n|-----------|------------|-------------------------------------|\n| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |\n| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |", "metadata": {}}
{"id": "117", "text": "## Complexity Tracking\n\n*Fill ONLY if Constitution Check has violations that must be justified*\n\n| Violation | Why Needed | Simpler Alternative Rejected Because |\n|-----------|------------|-------------------------------------|\n| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |\n| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |\n\n## Progress Tracking\n\n*This checklist is updated during execution flow*\n\n**Phase Status**:\n\n- [x] Phase 0: Research complete (/plan command)\n- [x] Phase 1: Design complete (/plan command)\n- [x] Phase 2: Task planning complete (/plan command - describe approach only)\n- [ ] Phase 3: Tasks generated (/tasks command)\n- [ ] Phase 4: Implementation complete\n- [ ] Phase 5: Validation passed\n\n**Gate Status**:\n\n- [x] Initial Constitution Check: PASS\n- [x] Post-Design Constitution Check: PASS\n- [x] All NEEDS CLARIFICATION resolved\n- [x] Complexity deviations documented", "metadata": {}}
{"id": "118", "text": "- [x] Phase 0: Research complete (/plan command)\n- [x] Phase 1: Design complete (/plan command)\n- [x] Phase 2: Task planning complete (/plan command - describe approach only)\n- [ ] Phase 3: Tasks generated (/tasks command)\n- [ ] Phase 4: Implementation complete\n- [ ] Phase 5: Validation passed\n\n**Gate Status**:\n\n- [x] Initial Constitution Check: PASS\n- [x] Post-Design Constitution Check: PASS\n- [x] All NEEDS CLARIFICATION resolved\n- [x] Complexity deviations documented\n\n---\n*Based on Constitution v2.1.1 - See `/memory/constitution.md`*", "metadata": {}}
{"id": "119", "text": "# Quick Start Guide: Image Detail View Feature\n\nThis guide demonstrates how to use the new image detail view functionality.\n\n## Prerequisites\n\n- Node.js 18+ installed\n- Photo app running locally\n- At least one image uploaded to your gallery\n\n## Basic Usage\n\n### 1. Navigate to Gallery\n\nOpen the photo app and go to the main gallery view where you can see all your photos.\n\n### 2. Click on an Image\n\nClick any image thumbnail to open the detail view.\n\n```bash\n# The modal should open showing:\n# - Full-size image on the left\n# - Image details on the right\n```\n\n### 3. View Image Details", "metadata": {}}
{"id": "120", "text": "## Prerequisites\n\n- Node.js 18+ installed\n- Photo app running locally\n- At least one image uploaded to your gallery\n\n## Basic Usage\n\n### 1. Navigate to Gallery\n\nOpen the photo app and go to the main gallery view where you can see all your photos.\n\n### 2. Click on an Image\n\nClick any image thumbnail to open the detail view.\n\n```bash\n# The modal should open showing:\n# - Full-size image on the left\n# - Image details on the right\n```\n\n### 3. View Image Details\n\nThe right column displays:\n- **Uploader**: Username of who uploaded the image\n- **Upload Date**: When the image was added to the app\n- **Capture Date**: When the photo was taken (from EXIF data)\n- **File Size**: Human-readable size (e.g., \"2.4 MB\")\n- **Dimensions**: Width × height in pixels\n- **Camera Model**: If available in EXIF data\n- **File Type**: e.g., \"JPEG\", \"PNG\"\n\n### 4. Close the Detail View", "metadata": {}}
{"id": "121", "text": "### 3. View Image Details\n\nThe right column displays:\n- **Uploader**: Username of who uploaded the image\n- **Upload Date**: When the image was added to the app\n- **Capture Date**: When the photo was taken (from EXIF data)\n- **File Size**: Human-readable size (e.g., \"2.4 MB\")\n- **Dimensions**: Width × height in pixels\n- **Camera Model**: If available in EXIF data\n- **File Type**: e.g., \"JPEG\", \"PNG\"\n\n### 4. Close the Detail View\n\nUse any of these methods to close:\n- Click the × button in the top-right corner\n- Click outside the modal (on the dark overlay)\n- Press the ESC key\n\n## Keyboard Navigation\n\n- **Tab**: Navigate between interactive elements\n- **Enter/Space**: Activate focused buttons\n- **ESC**: Close the detail view\n- **Arrow Keys**: Navigate between images in slideshow mode (future enhancement)\n\n## Accessibility Features", "metadata": {}}
{"id": "122", "text": "### 4. Close the Detail View\n\nUse any of these methods to close:\n- Click the × button in the top-right corner\n- Click outside the modal (on the dark overlay)\n- Press the ESC key\n\n## Keyboard Navigation\n\n- **Tab**: Navigate between interactive elements\n- **Enter/Space**: Activate focused buttons\n- **ESC**: Close the detail view\n- **Arrow Keys**: Navigate between images in slideshow mode (future enhancement)\n\n## Accessibility Features\n\n- All buttons have ARIA labels\n- Modal traps focus when open\n- Screen reader announces when modal opens/closes\n- Full keyboard navigation support\n\n## Testing the Feature\n\n### Manual Testing\n\n1. **Open Detail View**\n   - Click various images\n   - Verify correct image loads\n   - Check metadata displays correctly\n\n2. **Close Modal**\n   - Test all close methods (×, outside click, ESC)\n   - Verify focus returns to clicked image\n\n3. **Accessibility**\n   - Test with screen reader (VoiceOver, NVDA)\n   - Navigate with keyboard only\n   - Verify ARIA labels are descriptive", "metadata": {}}
{"id": "123", "text": "## Testing the Feature\n\n### Manual Testing\n\n1. **Open Detail View**\n   - Click various images\n   - Verify correct image loads\n   - Check metadata displays correctly\n\n2. **Close Modal**\n   - Test all close methods (×, outside click, ESC)\n   - Verify focus returns to clicked image\n\n3. **Accessibility**\n   - Test with screen reader (VoiceOver, NVDA)\n   - Navigate with keyboard only\n   - Verify ARIA labels are descriptive\n\n4. **Responsive Design**\n   - Test on mobile device (layout should stack)\n   - Test on tablet and desktop\n   - Verify text remains readable\n\n### Automated Testing\n\nRun the test suite:\n\n```bash\nnpm test\n```\n\nKey test files:\n- `ImageDetailModal.test.tsx` - Component tests\n- `ImageGallery.test.tsx` - Integration tests\n- `useImageDetail.test.ts` - Hook tests\n- `accessibility.test.tsx` - Accessibility tests\n\n## Troubleshooting\n\n### Image Not Loading", "metadata": {}}
{"id": "124", "text": "4. **Responsive Design**\n   - Test on mobile device (layout should stack)\n   - Test on tablet and desktop\n   - Verify text remains readable\n\n### Automated Testing\n\nRun the test suite:\n\n```bash\nnpm test\n```\n\nKey test files:\n- `ImageDetailModal.test.tsx` - Component tests\n- `ImageGallery.test.tsx` - Integration tests\n- `useImageDetail.test.ts` - Hook tests\n- `accessibility.test.tsx` - Accessibility tests\n\n## Troubleshooting\n\n### Image Not Loading\n\n1. Check browser console for errors\n2. Verify image file exists in storage\n3. Check file permissions\n\n### Missing Metadata\n\n1. Some images may not have EXIF data\n2. Upload date should always show\n3. File size and type should always be available\n\n### Modal Not Opening\n\n1. Check JavaScript console for errors\n2. Verify React is running without errors\n3. Check CSS is loaded correctly\n\n## Future Enhancements\n\n- Image editing capabilities\n- Slideshow mode\n- Share functionality\n- Download button\n- EXIF data editor", "metadata": {}}
{"id": "125", "text": "# Research: Image Detail View Feature\n\n**Feature**: Image Detail View (002-user-can-click)\n**Date**: 2025-09-26\n\n## Decisions Made\n\n### Navigation Method\n**Decision**: Implement a modal/overlay for detail view instead of separate page\n**Rationale**:\n- Provides better user experience with instant view without page reload\n- Maintains gallery context in background\n- Easier to implement with existing React router setup\n- More responsive on mobile devices\n\n**Alternatives considered**:\n- Separate page route: More traditional but requires full page transition\n- Side panel: Could work but reduces image visibility\n\n### Uploader Information Display\n**Decision**: Display \"Uploaded by [username]\" with optional real name if available\n**Rationale**:\n- Clear and concise\n- Follows common social media patterns\n- Privacy-preserving (username instead of email)\n\n**Alternatives considered**:\n- Full name only: Could expose private information\n- Email address: Privacy violation", "metadata": {}}
{"id": "126", "text": "**Alternatives considered**:\n- Separate page route: More traditional but requires full page transition\n- Side panel: Could work but reduces image visibility\n\n### Uploader Information Display\n**Decision**: Display \"Uploaded by [username]\" with optional real name if available\n**Rationale**:\n- Clear and concise\n- Follows common social media patterns\n- Privacy-preserving (username instead of email)\n\n**Alternatives considered**:\n- Full name only: Could expose private information\n- Email address: Privacy violation\n\n### Metadata Fields to Display\n**Decision**:\n- Upload date/time (formatted)\n- File size\n- Image dimensions (width × height)\n- Camera model (if available in EXIF)\n- File type\n\n**Rationale**: Comprehensive but not overwhelming\n\n### Back Navigation\n**Decision**:\n- Close button (×) in top-right corner\n- Click outside modal to close\n- ESC key support\n- Optional back arrow in top-left\n\n**Rationale**: Multiple intuitive ways to exit detail view", "metadata": {}}
{"id": "127", "text": "**Alternatives considered**:\n- Full name only: Could expose private information\n- Email address: Privacy violation\n\n### Metadata Fields to Display\n**Decision**:\n- Upload date/time (formatted)\n- File size\n- Image dimensions (width × height)\n- Camera model (if available in EXIF)\n- File type\n\n**Rationale**: Comprehensive but not overwhelming\n\n### Back Navigation\n**Decision**:\n- Close button (×) in top-right corner\n- Click outside modal to close\n- ESC key support\n- Optional back arrow in top-left\n\n**Rationale**: Multiple intuitive ways to exit detail view\n\n### Mobile Responsiveness\n**Decision**: Stack layout on mobile (image above, details below)\n**Rationale**: Better use of limited screen space\n\n### Image Loading Strategy\n**Decision**: Lazy loading with placeholder\n**Rationale**: Better performance for large images\n\n### Accessibility Considerations\n**Decision**:\n- ARIA labels for all interactive elements\n- Keyboard navigation support\n- Focus management when opening/closing\n- Screen reader announcements\n\n**Rationale**: Required by constitution and WCAG 2.1 AA", "metadata": {}}
{"id": "128", "text": "**Rationale**: Multiple intuitive ways to exit detail view\n\n### Mobile Responsiveness\n**Decision**: Stack layout on mobile (image above, details below)\n**Rationale**: Better use of limited screen space\n\n### Image Loading Strategy\n**Decision**: Lazy loading with placeholder\n**Rationale**: Better performance for large images\n\n### Accessibility Considerations\n**Decision**:\n- ARIA labels for all interactive elements\n- Keyboard navigation support\n- Focus management when opening/closing\n- Screen reader announcements\n\n**Rationale**: Required by constitution and WCAG 2.1 AA\n\n## Technical Implementation Notes\n\n### Component Structure\n- `ImageDetailModal`: Main component for detail view\n- `ImageGallery`: Modified to handle click events\n- `ImageMetadata`: Component for displaying metadata\n\n### State Management\n- Use React context for selected image state\n- Local state for modal open/close\n\n### Styling\n- Use Tailwind CSS for responsive layout\n- Shadcn/ui components for buttons and close button\n\n### Testing Strategy\n- Unit tests for all components\n- Integration tests for navigation flow\n- Accessibility tests with axe-core", "metadata": {}}
{"id": "129", "text": "## Technical Implementation Notes\n\n### Component Structure\n- `ImageDetailModal`: Main component for detail view\n- `ImageGallery`: Modified to handle click events\n- `ImageMetadata`: Component for displaying metadata\n\n### State Management\n- Use React context for selected image state\n- Local state for modal open/close\n\n### Styling\n- Use Tailwind CSS for responsive layout\n- Shadcn/ui components for buttons and close button\n\n### Testing Strategy\n- Unit tests for all components\n- Integration tests for navigation flow\n- Accessibility tests with axe-core\n\n## All NEEDS CLARIFICATION Resolved\n\n- ✅ Navigation method: Modal with multiple exit options\n- ✅ Uploader info: Username with optional real name\n- ✅ Back navigation: Close button, click outside, ESC key", "metadata": {}}
{"id": "130", "text": "# Feature Specification: Image Detail View\n\n**Feature Branch**: `[002-user-can-click]`\n**Created**: 2025-09-26\n**Status**: Draft\n**Input**: User description: \"User can click to image and view detail of that only image. in detail page, display 2 column, image in left side, image detail (who upload, date time) in right side\"\n\n## Execution Flow (main)", "metadata": {}}
{"id": "131", "text": "# Feature Specification: Image Detail View\n\n**Feature Branch**: `[002-user-can-click]`\n**Created**: 2025-09-26\n**Status**: Draft\n**Input**: User description: \"User can click to image and view detail of that only image. in detail page, display 2 column, image in left side, image detail (who upload, date time) in right side\"\n\n## Execution Flow (main)\n\n```\n1. Parse user description from Input\n    User wants: click image  view detail  2-column layout\n2. Extract key concepts from description\n    Actors: User\n    Actions: Click image, view detail\n    Data: Image, uploader info, date/time\n    Layout: 2-column (image left, details right)\n3. For each unclear aspect:\n    Navigation: How to enter/exit detail view [NEEDS CLARIFICATION]\n    Image details: What specific metadata to show [NEEDS CLARIFICATION]\n4. Fill User Scenarios & Testing section\n    User journey identified: browse  click  view detail  return\n5. Generate Functional Requirements\n    Requirements testable and marked where unclear\n6. Identify Key Entities\n    Image entity with metadata\n7. Run Review Checklist\n    Spec has uncertainties marked\n8. Return: SUCCESS (spec ready for planning)\n```", "metadata": {}}
{"id": "132", "text": "---\n\n##  Quick Guidelines\n\n- \u0005 Focus on WHAT users need and WHY\n- L Avoid HOW to implement (no tech stack, APIs, code structure)\n- =e Written for business stakeholders, not developers\n\n### Section Requirements\n\n- **Mandatory sections**: Must be completed for every feature\n- **Optional sections**: Include only when relevant to the feature\n- When a section doesn't apply, remove it entirely (don't leave as \"N/A\")\n\n---\n\n## User Scenarios & Testing *(mandatory)*\n\n### Primary User Story\n\nAs a photo app user, I want to click on any image to view its details in a focused view, so I can see the image larger and access its metadata without distraction from other photos.\n\n### Acceptance Scenarios\n\n1. **Given** I am viewing photos in the main gallery, **When** I click on any image, **Then** I am taken to a detail page showing only that image", "metadata": {}}
{"id": "133", "text": "---\n\n## User Scenarios & Testing *(mandatory)*\n\n### Primary User Story\n\nAs a photo app user, I want to click on any image to view its details in a focused view, so I can see the image larger and access its metadata without distraction from other photos.\n\n### Acceptance Scenarios\n\n1. **Given** I am viewing photos in the main gallery, **When** I click on any image, **Then** I am taken to a detail page showing only that image\n\n2. **Given** I am on the image detail page, **When** the page loads, **Then** I see a 2-column layout with the image displayed on the left side and image details on the right side\n\n3. **Given** I am viewing image details, **When** I look at the details column, **Then** I can see who uploaded the image and the capture date/time", "metadata": {}}
{"id": "134", "text": "### Acceptance Scenarios\n\n1. **Given** I am viewing photos in the main gallery, **When** I click on any image, **Then** I am taken to a detail page showing only that image\n\n2. **Given** I am on the image detail page, **When** the page loads, **Then** I see a 2-column layout with the image displayed on the left side and image details on the right side\n\n3. **Given** I am viewing image details, **When** I look at the details column, **Then** I can see who uploaded the image and the capture date/time\n\n4. **Given** I am on the image detail page, **When** I want to return to the gallery, **Then** there is a way to navigate back [NEEDS CLARIFICATION: back button, X button, or other?]\n\n### Edge Cases", "metadata": {}}
{"id": "135", "text": "3. **Given** I am viewing image details, **When** I look at the details column, **Then** I can see who uploaded the image and the capture date/time\n\n4. **Given** I am on the image detail page, **When** I want to return to the gallery, **Then** there is a way to navigate back [NEEDS CLARIFICATION: back button, X button, or other?]\n\n### Edge Cases\n\n- What happens when the image metadata is missing or incomplete?\n- How does the view handle very large images?\n- What happens when the user tries to access a deleted image's detail page?\n- How does the layout adapt on mobile devices where 2 columns may not fit?\n\n## Requirements *(mandatory)*\n\n### Functional Requirements", "metadata": {}}
{"id": "136", "text": "4. **Given** I am on the image detail page, **When** I want to return to the gallery, **Then** there is a way to navigate back [NEEDS CLARIFICATION: back button, X button, or other?]\n\n### Edge Cases\n\n- What happens when the image metadata is missing or incomplete?\n- How does the view handle very large images?\n- What happens when the user tries to access a deleted image's detail page?\n- How does the layout adapt on mobile devices where 2 columns may not fit?\n\n## Requirements *(mandatory)*\n\n### Functional Requirements\n\n- **FR-001**: System MUST allow users to click on any image to view its detailed information\n- **FR-002**: System MUST display the selected image in an isolated view, showing only that single image\n- **FR-003**: System MUST present the detail view in a 2-column layout format\n- **FR-004**: System MUST display the image in the left column of the detail view\n- **FR-005**: System MUST display image metadata in the right column of the detail view\n- **FR-006**: System MUST show who uploaded the image as part of the metadata [NEEDS CLARIFICATION: display name, username, or other identifier?]\n- **FR-007**: System MUST show the image capture date and time as part of the metadata\n- **FR-008**: System MUST provide a way for users to navigate from the detail view back to the main gallery [NEEDS CLARIFICATION: specific navigation method?]\n- **FR-009**: System MUST handle cases where image metadata is incomplete or missing", "metadata": {}}
{"id": "137", "text": "### Key Entities *(include if feature involves data)*\n\n- **Image**: Represents a single photo with associated metadata including uploader information and capture timestamp\n- **Image Metadata**: Contains supplementary information about the image including uploader identity and capture date/time\n\n---\n\n## Review & Acceptance Checklist\n\n*GATE: Automated checks run during main() execution*\n\n### Content Quality\n\n- [ ] No implementation details (languages, frameworks, APIs)\n- [ ] Focused on user value and business needs\n- [ ] Written for non-technical stakeholders\n- [ ] All mandatory sections completed\n\n### Requirement Completeness\n\n- [ ] No [NEEDS CLARIFICATION] markers remain\n- [ ] Requirements are testable and unambiguous\n- [ ] Success criteria are measurable\n- [ ] Scope is clearly bounded\n- [ ] Dependencies and assumptions identified\n\n---\n\n## Execution Status\n\n*Updated by main() during processing*", "metadata": {}}
{"id": "138", "text": "### Content Quality\n\n- [ ] No implementation details (languages, frameworks, APIs)\n- [ ] Focused on user value and business needs\n- [ ] Written for non-technical stakeholders\n- [ ] All mandatory sections completed\n\n### Requirement Completeness\n\n- [ ] No [NEEDS CLARIFICATION] markers remain\n- [ ] Requirements are testable and unambiguous\n- [ ] Success criteria are measurable\n- [ ] Scope is clearly bounded\n- [ ] Dependencies and assumptions identified\n\n---\n\n## Execution Status\n\n*Updated by main() during processing*\n\n- [x] User description parsed\n- [x] Key concepts extracted\n- [x] Ambiguities marked\n- [x] User scenarios defined\n- [x] Requirements generated\n- [x] Entities identified\n- [ ] Review checklist passed\n\n---", "metadata": {}}
{"id": "139", "text": "# Tasks: Image Detail View Feature\n\n**Input**: Design documents from `/specs/002-user-can-click/`\n**Prerequisites**: plan.md (required), research.md, data-model.md, contracts/\n\n## Feature Overview\nImplement an image detail view modal that allows users to click on any photo in the gallery to view it in a focused 2-column layout with the image on the left and metadata (uploader info, date/time) on the right.\n\n## Phase 3.1: Setup\n- [X] T001 Verify project structure has src/components/, src/pages/, src/hooks/, src/services/, src/types/, src/utils/\n- [X] T002 Install/verify shadcn/ui components for modal and buttons\n- [X] T003 [P] Configure TypeScript types for Image and User entities", "metadata": {}}
{"id": "140", "text": "## Feature Overview\nImplement an image detail view modal that allows users to click on any photo in the gallery to view it in a focused 2-column layout with the image on the left and metadata (uploader info, date/time) on the right.\n\n## Phase 3.1: Setup\n- [X] T001 Verify project structure has src/components/, src/pages/, src/hooks/, src/services/, src/types/, src/utils/\n- [X] T002 Install/verify shadcn/ui components for modal and buttons\n- [X] T003 [P] Configure TypeScript types for Image and User entities\n\n## Phase 3.2: Tests First (TDD) ⚠️ MUST COMPLETE BEFORE 3.3\n**CRITICAL: These tests MUST be written and MUST FAIL before ANY implementation**\n- [X] T004 [P] Contract test GET /api/images/{id} in tests/contract/test_image_get.test.ts\n- [X] T005 [P] Contract test GET /api/images/{id}/file in tests/contract/test_image_file_get.test.ts\n- [X] T006 [P] Contract test PUT /api/images/{id} in tests/contract/test_image_put.test.ts\n- [X] T007 [P] Integration test image click opens detail modal in tests/integration/test_image_detail_flow.test.tsx\n- [X] T008 [P] Integration test modal close methods in tests/integration/test_modal_close.test.tsx\n- [X] T009 [P] Accessibility test for modal in tests/accessibility/test_modal_accessibility.test.tsx", "metadata": {}}
{"id": "141", "text": "## Phase 3.3: Core Implementation (ONLY after tests are failing)\n- [X] T010 [P] Image type definition in src/types/image.ts\n- [X] T011 [P] User type definition in src/types/user.ts\n- [X] T012 [P] ImageDetailState interface in src/types/state.ts\n- [X] T013 [P] useImageDetail hook in src/hooks/useImageDetail.ts\n- [X] T014 [P] ImageMetadata component in src/components/ImageMetadata/ImageMetadata.tsx\n- [X] T015 [P] ImageDetailModal component in src/components/ImageDetailModal/ImageDetailModal.tsx\n- [X] T016 Update ImageGallery component to handle click events\n- [X] T017 GET /api/images/{id} endpoint implementation\n- [X] T018 GET /api/images/{id}/file endpoint implementation\n- [X] T019 PUT /api/images/{id} endpoint implementation\n- [X] T020 Image service with detail fetching methods", "metadata": {}}
{"id": "142", "text": "## Phase 3.4: Integration\n- [X] T021 Connect modal to gallery state management\n- [X] T022 Implement image file URL generation\n- [X] T023 Add keyboard navigation (ESC to close)\n- [X] T024 Add click-outside-to-close functionality\n- [X] T025 Implement focus trapping for accessibility\n- [X] T026 Add screen reader announcements\n\n## Phase 3.5: Polish\n- [X] T027 [P] Unit tests for useImageDetail hook in tests/hooks/test_useImageDetail.test.ts\n- [X] T028 [P] Unit tests for ImageMetadata component in tests/components/test_ImageMetadata.test.tsx\n- [X] T029 Performance tests (<100ms modal transitions)\n- [X] T030 [P] Add responsive design for mobile stacking\n- [X] T031 Add loading states for image fetching\n- [X] T032 Add error handling for failed image loads\n- [X] T033 Run quickstart.md test scenarios", "metadata": {}}
{"id": "143", "text": "## Dependencies\n- Tests (T004-T009) before implementation (T010-T020)\n- Type definitions (T010-T012) block components (T014-T015)\n- ImageDetailModal (T015) depends on useImageDetail (T013) and ImageMetadata (T014)\n- Gallery update (T016) depends on modal (T015)\n- Implementation before integration (T021-T026)\n- Integration before polish (T027-T033)", "metadata": {}}
{"id": "144", "text": "## Dependencies\n- Tests (T004-T009) before implementation (T010-T020)\n- Type definitions (T010-T012) block components (T014-T015)\n- ImageDetailModal (T015) depends on useImageDetail (T013) and ImageMetadata (T014)\n- Gallery update (T016) depends on modal (T015)\n- Implementation before integration (T021-T026)\n- Integration before polish (T027-T033)\n\n## Parallel Example\n```\n# Launch T004-T009 together:\nTask: \"Contract test GET /api/images/{id} in tests/contract/test_image_get.test.ts\"\nTask: \"Contract test GET /api/images/{id}/file in tests/contract/test_image_file_get.test.ts\"\nTask: \"Contract test PUT /api/images/{id} in tests/contract/test_image_put.test.ts\"\nTask: \"Integration test image click opens detail modal in tests/integration/test_image_detail_flow.test.tsx\"\nTask: \"Integration test modal close methods in tests/integration/test_modal_close.test.tsx\"\nTask: \"Accessibility test for modal in tests/accessibility/test_modal_accessibility.test.tsx\"", "metadata": {}}
{"id": "145", "text": "# Launch T010-T012 together:\nTask: \"Image type definition in src/types/image.ts\"\nTask: \"User type definition in src/types/user.ts\"\nTask: \"ImageDetailState interface in src/types/state.ts\"\n\n# Launch T027, T028, T030 together:\nTask: \"Unit tests for useImageDetail hook in tests/hooks/test_useImageDetail.test.ts\"\nTask: \"Unit tests for ImageMetadata component in tests/components/test_ImageMetadata.test.tsx\"\nTask: \"Add responsive design for mobile stacking\"\n```\n\n## Notes\n- [P] tasks = different files, no dependencies\n- Verify tests fail before implementing\n- Follow constitutional principles: 100% test coverage, accessibility first, React functional components\n- Use shadcn/ui components where possible\n- Implement WCAG 2.1 AA compliance\n- Ensure offline-first functionality with SQLite", "metadata": {}}
{"id": "146", "text": "import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'\nimport { useState, useEffect } from 'react'\nimport { ViewState } from './types'\nimport Layout from './components/Layout'\nimport LandingPage from './pages/LandingPage'\n// import { useBundleOptimization } from './utils/bundleOptimization'\nimport './App.css'\n\nfunction App() {\n  const [viewState, setViewState] = useState<ViewState>({\n    currentView: 'albums',\n    isZoomModalOpen: false\n  })\n\n  // Bundle optimization monitoring (temporarily disabled)\n  // const { metrics, recommendations, evaluateOptimization } = useBundleOptimization()", "metadata": {}}
{"id": "147", "text": "function App() {\n  const [viewState, setViewState] = useState<ViewState>({\n    currentView: 'albums',\n    isZoomModalOpen: false\n  })\n\n  // Bundle optimization monitoring (temporarily disabled)\n  // const { metrics, recommendations, evaluateOptimization } = useBundleOptimization()\n\n  // Log bundle optimization evaluation in development (temporarily disabled)\n  // useEffect(() => {\n  //   if (process.env.NODE_ENV === 'development') {\n  //     // Wait for initial load to complete\n  //     const timer = setTimeout(() => {\n  //       const evaluation = evaluateOptimization()\n  //       if (evaluation.score < 80) {\n  //         console.group('⚠️ Bundle Optimization Warnings')\n  //         console.log(`Optimization Score: ${evaluation.score}/100`)\n  //         if (evaluation.issues.length > 0) {\n  //           console.log('Issues:', evaluation.issues)\n  //         }\n  //         if (evaluation.suggestions.length > 0) {\n  //           console.log('Suggestions:', evaluation.suggestions)\n  //         }\n  //         console.groupEnd()\n  //       }\n  //     }, 3000)", "metadata": {}}
{"id": "148", "text": "//     return () => clearTimeout(timer)\n  //   }\n  // }, [evaluateOptimization])\n\n  const handleAlbumClick = (albumId: number) => {\n    setViewState(prev => ({\n      ...prev,\n      currentView: 'photos',\n      selectedAlbumId: albumId\n    }))\n  }\n\n  const handleBackToAlbums = () => {\n    setViewState(prev => ({\n      ...prev,\n      currentView: 'albums',\n      selectedAlbumId: undefined,\n      selectedPhotoId: undefined\n    }))\n  }\n\n  const handlePhotoClick = (photoId: number) => {\n    setViewState(prev => ({\n      ...prev,\n      selectedPhotoId: photoId,\n      isZoomModalOpen: true\n    }))\n  }\n\n  const handleCloseZoom = () => {\n    setViewState(prev => ({\n      ...prev,\n      isZoomModalOpen: false,\n      selectedPhotoId: undefined\n    }))\n  }", "metadata": {}}
{"id": "149", "text": "const handlePhotoClick = (photoId: number) => {\n    setViewState(prev => ({\n      ...prev,\n      selectedPhotoId: photoId,\n      isZoomModalOpen: true\n    }))\n  }\n\n  const handleCloseZoom = () => {\n    setViewState(prev => ({\n      ...prev,\n      isZoomModalOpen: false,\n      selectedPhotoId: undefined\n    }))\n  }\n\n  return (\n    <Router>\n      <Layout viewState={viewState} onBackToAlbums={handleBackToAlbums}>\n        <Routes>\n          <Route\n            path=\"/\"\n            element={\n              <LandingPage\n                viewState={viewState}\n                onAlbumClick={handleAlbumClick}\n                onPhotoClick={handlePhotoClick}\n                onCloseZoom={handleCloseZoom}\n              />\n            }\n          />\n          <Route\n            path=\"/albums/:albumId\"\n            element={\n              <LandingPage\n                viewState={viewState}\n                onAlbumClick={handleAlbumClick}\n                onPhotoClick={handlePhotoClick}\n                onCloseZoom={handleCloseZoom}\n              />\n            }\n          />\n        </Routes>", "metadata": {}}
{"id": "150", "text": "{/* Bundle optimization indicator for development (temporarily disabled) */}\n        {/* {process.env.NODE_ENV === 'development' && metrics && (\n          <div className=\"fixed top-4 left-4 bg-black/80 text-white text-xs px-3 py-2 rounded-lg shadow-lg\">\n            <div className=\"font-semibold mb-1\">Bundle Stats</div>\n            <div>Size: {(metrics.totalSize / 1024).toFixed(1)}KB</div>\n            <div>Chunks: {metrics.chunksLoaded}</div>\n            <div>Load: {metrics.loadTimes.initial.toFixed(0)}ms</div>\n            {recommendations?.enableLazyLoading && (\n              <div className=\"text-yellow-300 mt-1\">⚡ Lazy loading recommended</div>\n            )}\n          </div>\n        )} */}\n      </Layout>\n    </Router>\n  )\n}\n\nexport default App", "metadata": {}}
{"id": "151", "text": "import type { Meta, StoryObj } from '@storybook/react'\nimport AlbumGrid from './index'\nimport { Album } from '../../types'\n\n// Sample album data generator\nconst generateSampleAlbum = (id: number): Album => ({\n  id,\n  name: `Album ${id}`,\n  captureDate: new Date(2024 - Math.floor(id / 12), (id % 12), 15),\n  displayOrder: id,\n  thumbnailPhotoId: 100 + id,\n  photoCount: Math.floor(Math.random() * 100) + 5,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n})\n\n// Generate sample albums\nconst sampleAlbums = Array.from({ length: 6 }, (_, i) => generateSampleAlbum(i + 1))\nconst manyAlbums = Array.from({ length: 21 }, (_, i) => generateSampleAlbum(i + 1))\n\n// Named albums for specific stories\nconst namedAlbums: Album[] = [\n  {\n    id: 1,\n    name: 'Summer Vacation 2024',", "metadata": {}}
{"id": "152", "text": "// Generate sample albums\nconst sampleAlbums = Array.from({ length: 6 }, (_, i) => generateSampleAlbum(i + 1))\nconst manyAlbums = Array.from({ length: 21 }, (_, i) => generateSampleAlbum(i + 1))\n\n// Named albums for specific stories\nconst namedAlbums: Album[] = [\n  {\n    id: 1,\n    name: 'Summer Vacation 2024',\n    captureDate: new Date('2024-07-15'),\n    displayOrder: 1,\n    thumbnailPhotoId: 101,\n    photoCount: 24,\n    createdAt: new Date('2024-07-15T10:00:00Z'),\n    updatedAt: new Date('2024-07-15T10:00:00Z'),\n  },\n  {\n    id: 2,\n    name: 'Wedding Photography',\n    captureDate: new Date('2024-06-10'),\n    displayOrder: 2,\n    thumbnailPhotoId: 102,", "metadata": {}}
{"id": "153", "text": "displayOrder: 1,\n    thumbnailPhotoId: 101,\n    photoCount: 24,\n    createdAt: new Date('2024-07-15T10:00:00Z'),\n    updatedAt: new Date('2024-07-15T10:00:00Z'),\n  },\n  {\n    id: 2,\n    name: 'Wedding Photography',\n    captureDate: new Date('2024-06-10'),\n    displayOrder: 2,\n    thumbnailPhotoId: 102,\n    photoCount: 156,\n    createdAt: new Date('2024-06-10T14:00:00Z'),\n    updatedAt: new Date('2024-06-10T14:00:00Z'),\n  },\n  {\n    id: 3,\n    name: 'Daily Life Moments',\n    captureDate: new Date('2024-08-20'),\n    displayOrder: 3,\n    thumbnailPhotoId: null,", "metadata": {}}
{"id": "154", "text": "displayOrder: 2,\n    thumbnailPhotoId: 102,\n    photoCount: 156,\n    createdAt: new Date('2024-06-10T14:00:00Z'),\n    updatedAt: new Date('2024-06-10T14:00:00Z'),\n  },\n  {\n    id: 3,\n    name: 'Daily Life Moments',\n    captureDate: new Date('2024-08-20'),\n    displayOrder: 3,\n    thumbnailPhotoId: null,\n    photoCount: 43,\n    createdAt: new Date('2024-08-20T09:00:00Z'),\n    updatedAt: new Date('2024-08-20T09:00:00Z'),\n  },\n]\n\nconst meta: Meta<typeof AlbumGrid> = {\n  title: 'Components/AlbumGrid',\n  component: AlbumGrid,\n  parameters: {\n    layout: 'fullscreen',", "metadata": {}}
{"id": "155", "text": "captureDate: new Date('2024-08-20'),\n    displayOrder: 3,\n    thumbnailPhotoId: null,\n    photoCount: 43,\n    createdAt: new Date('2024-08-20T09:00:00Z'),\n    updatedAt: new Date('2024-08-20T09:00:00Z'),\n  },\n]\n\nconst meta: Meta<typeof AlbumGrid> = {\n  title: 'Components/AlbumGrid',\n  component: AlbumGrid,\n  parameters: {\n    layout: 'fullscreen',\n    docs: {\n      description: {\n        component: `\nThe AlbumGrid component displays a responsive grid of album tiles with support for:\n- Responsive layout (1 column mobile, 2 columns tablet, 3 columns desktop)\n- Keyboard navigation with arrow keys, Home, End\n- Accessibility features including ARIA labels and live regions\n- Loading states with skeleton placeholders\n- Drag and drop reordering\n        `,\n      },\n    },\n    viewport: {\n      defaultViewport: 'responsive',\n    },", "metadata": {}}
{"id": "156", "text": "component: AlbumGrid,\n  parameters: {\n    layout: 'fullscreen',\n    docs: {\n      description: {\n        component: `\nThe AlbumGrid component displays a responsive grid of album tiles with support for:\n- Responsive layout (1 column mobile, 2 columns tablet, 3 columns desktop)\n- Keyboard navigation with arrow keys, Home, End\n- Accessibility features including ARIA labels and live regions\n- Loading states with skeleton placeholders\n- Drag and drop reordering\n        `,\n      },\n    },\n    viewport: {\n      defaultViewport: 'responsive',\n    },\n  },\n  tags: ['autodocs'],\n  argTypes: {\n    albums: {\n      description: 'Array of album data objects to display',\n      control: { type: 'object' },\n    },\n    onAlbumClick: {\n      description: 'Callback function called when an album is clicked',\n      action: 'album-clicked',\n    },\n    onAlbumReorder: {\n      description: 'Callback function called when albums are reordered',", "metadata": {}}
{"id": "157", "text": "},\n    },\n    viewport: {\n      defaultViewport: 'responsive',\n    },\n  },\n  tags: ['autodocs'],\n  argTypes: {\n    albums: {\n      description: 'Array of album data objects to display',\n      control: { type: 'object' },\n    },\n    onAlbumClick: {\n      description: 'Callback function called when an album is clicked',\n      action: 'album-clicked',\n    },\n    onAlbumReorder: {\n      description: 'Callback function called when albums are reordered',\n      action: 'album-reordered',\n    },\n    onAlbumDelete: {\n      description: 'Optional callback function for deleting albums',\n      action: 'album-deleted',\n    },\n    loading: {\n      description: 'Loading state indicator',\n      control: { type: 'boolean' },\n    },\n    className: {\n      description: 'Additional CSS classes to apply',\n      control: { type: 'text' },\n    },\n  },", "metadata": {}}
{"id": "158", "text": "},\n    onAlbumReorder: {\n      description: 'Callback function called when albums are reordered',\n      action: 'album-reordered',\n    },\n    onAlbumDelete: {\n      description: 'Optional callback function for deleting albums',\n      action: 'album-deleted',\n    },\n    loading: {\n      description: 'Loading state indicator',\n      control: { type: 'boolean' },\n    },\n    className: {\n      description: 'Additional CSS classes to apply',\n      control: { type: 'text' },\n    },\n  },\n  args: {\n    onAlbumClick: (albumId: number) => console.log(`Album ${albumId} clicked`),\n    onAlbumReorder: (albumId: number, newOrder: number) =>\n      console.log(`Album ${albumId} moved to order ${newOrder}`),\n  },", "metadata": {}}
{"id": "159", "text": "loading: {\n      description: 'Loading state indicator',\n      control: { type: 'boolean' },\n    },\n    className: {\n      description: 'Additional CSS classes to apply',\n      control: { type: 'text' },\n    },\n  },\n  args: {\n    onAlbumClick: (albumId: number) => console.log(`Album ${albumId} clicked`),\n    onAlbumReorder: (albumId: number, newOrder: number) =>\n      console.log(`Album ${albumId} moved to order ${newOrder}`),\n  },\n  decorators: [\n    (Story) => (\n      <div className=\"p-8 min-h-screen bg-gray-50\">\n        <Story />\n      </div>\n    ),\n  ],\n}\n\nexport default meta\ntype Story = StoryObj<typeof meta>\n\n// Default grid with few albums\nexport const Default: Story = {\n  args: {\n    albums: namedAlbums,\n  },\n}", "metadata": {}}
{"id": "160", "text": "onAlbumReorder: (albumId: number, newOrder: number) =>\n      console.log(`Album ${albumId} moved to order ${newOrder}`),\n  },\n  decorators: [\n    (Story) => (\n      <div className=\"p-8 min-h-screen bg-gray-50\">\n        <Story />\n      </div>\n    ),\n  ],\n}\n\nexport default meta\ntype Story = StoryObj<typeof meta>\n\n// Default grid with few albums\nexport const Default: Story = {\n  args: {\n    albums: namedAlbums,\n  },\n}\n\n// Loading state\nexport const Loading: Story = {\n  args: {\n    albums: [],\n    loading: true,\n  },\n}\n\n// Empty state\nexport const Empty: Story = {\n  args: {\n    albums: [],\n    loading: false,\n  },\n}", "metadata": {}}
{"id": "161", "text": "],\n}\n\nexport default meta\ntype Story = StoryObj<typeof meta>\n\n// Default grid with few albums\nexport const Default: Story = {\n  args: {\n    albums: namedAlbums,\n  },\n}\n\n// Loading state\nexport const Loading: Story = {\n  args: {\n    albums: [],\n    loading: true,\n  },\n}\n\n// Empty state\nexport const Empty: Story = {\n  args: {\n    albums: [],\n    loading: false,\n  },\n}\n\n// Many albums (scrollable)\nexport const ManyAlbums: Story = {\n  args: {\n    albums: manyAlbums,\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: 'Grid with many albums to demonstrate responsive behavior and scrolling.',\n      },\n    },\n  },\n}", "metadata": {}}
{"id": "162", "text": "// Loading state\nexport const Loading: Story = {\n  args: {\n    albums: [],\n    loading: true,\n  },\n}\n\n// Empty state\nexport const Empty: Story = {\n  args: {\n    albums: [],\n    loading: false,\n  },\n}\n\n// Many albums (scrollable)\nexport const ManyAlbums: Story = {\n  args: {\n    albums: manyAlbums,\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: 'Grid with many albums to demonstrate responsive behavior and scrolling.',\n      },\n    },\n  },\n}\n\n// With delete functionality\nexport const WithDelete: Story = {\n  args: {\n    albums: namedAlbums,\n    onAlbumDelete: (albumId: number) => console.log(`Delete album ${albumId}`),\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: 'Albums with delete buttons visible on hover.',\n      },\n    },\n  },\n}", "metadata": {}}
{"id": "163", "text": "// With delete functionality\nexport const WithDelete: Story = {\n  args: {\n    albums: namedAlbums,\n    onAlbumDelete: (albumId: number) => console.log(`Delete album ${albumId}`),\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: 'Albums with delete buttons visible on hover.',\n      },\n    },\n  },\n}\n\n// Responsive demonstration\nexport const ResponsiveDemo: Story = {\n  args: {\n    albums: sampleAlbums,\n  },\n  parameters: {\n    viewport: {\n      viewports: {\n        mobile: { name: 'Mobile', styles: { width: '375px', height: '667px' } },\n        tablet: { name: 'Tablet', styles: { width: '768px', height: '1024px' } },\n        desktop: { name: 'Desktop', styles: { width: '1200px', height: '800px' } },\n      },\n      defaultViewport: 'mobile',\n    },\n    docs: {\n      description: {\n        story: `\nResponsive grid layout:\n- Mobile (< 640px): 1 column\n- Tablet (640px - 1024px): 2 columns\n- Desktop (> 1024px): 3 columns", "metadata": {}}
{"id": "164", "text": "Try changing the viewport using the toolbar to see the responsive behavior.\n        `,\n      },\n    },\n  },\n}\n\n// Accessibility focused\nexport const AccessibilityDemo: Story = {\n  args: {\n    albums: namedAlbums.slice(0, 6),\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: `\nAccessibility features demonstration:\n- Tab navigation support\n- Arrow key navigation (Left/Right/Up/Down)\n- Home/End key support for first/last items\n- ARIA labels and grid role\n- Screen reader announcements", "metadata": {}}
{"id": "165", "text": "Try changing the viewport using the toolbar to see the responsive behavior.\n        `,\n      },\n    },\n  },\n}\n\n// Accessibility focused\nexport const AccessibilityDemo: Story = {\n  args: {\n    albums: namedAlbums.slice(0, 6),\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: `\nAccessibility features demonstration:\n- Tab navigation support\n- Arrow key navigation (Left/Right/Up/Down)\n- Home/End key support for first/last items\n- ARIA labels and grid role\n- Screen reader announcements\n\nTry using keyboard navigation: Tab to focus grid, then use arrow keys to navigate between albums.\n        `,\n      },\n    },\n  },\n  play: async ({ canvasElement }) => {\n    // Auto-focus the grid for accessibility demo\n    const grid = canvasElement.querySelector('[role=\"grid\"]') as HTMLElement\n    if (grid) {\n      grid.focus()\n      // Focus first album tile\n      const firstTile = grid.querySelector('[role=\"button\"]') as HTMLElement\n      if (firstTile) {\n        firstTile.focus()\n      }\n    }\n  },\n}", "metadata": {}}
{"id": "166", "text": "Try using keyboard navigation: Tab to focus grid, then use arrow keys to navigate between albums.\n        `,\n      },\n    },\n  },\n  play: async ({ canvasElement }) => {\n    // Auto-focus the grid for accessibility demo\n    const grid = canvasElement.querySelector('[role=\"grid\"]') as HTMLElement\n    if (grid) {\n      grid.focus()\n      // Focus first album tile\n      const firstTile = grid.querySelector('[role=\"button\"]') as HTMLElement\n      if (firstTile) {\n        firstTile.focus()\n      }\n    }\n  },\n}\n\n// Single album\nexport const SingleAlbum: Story = {\n  args: {\n    albums: [namedAlbums[0]],\n  },\n}\n\n// Loading with existing albums (progressive loading)\nexport const ProgressiveLoading: Story = {\n  args: {\n    albums: namedAlbums.slice(0, 3),\n    loading: true,\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: 'Demonstrates progressive loading where some albums are shown while more are loading.',\n      },\n    },\n  },\n}", "metadata": {}}
{"id": "167", "text": "// Single album\nexport const SingleAlbum: Story = {\n  args: {\n    albums: [namedAlbums[0]],\n  },\n}\n\n// Loading with existing albums (progressive loading)\nexport const ProgressiveLoading: Story = {\n  args: {\n    albums: namedAlbums.slice(0, 3),\n    loading: true,\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: 'Demonstrates progressive loading where some albums are shown while more are loading.',\n      },\n    },\n  },\n}\n\n// Custom styling\nexport const CustomStyling: Story = {\n  args: {\n    albums: namedAlbums,\n    className: 'gap-8 grid-cols-1 sm:grid-cols-1 lg:grid-cols-2',\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: 'Grid with custom spacing and column configuration (2 columns max instead of 3).',\n      },\n    },\n  },\n}", "metadata": {}}
{"id": "168", "text": "/**\n * VirtualizedAlbumGrid Component\n * High-performance album grid using react-window for large datasets\n */\n\nimport { useCallback, useRef, useMemo, useEffect, useState } from 'react'\nimport { Grid } from 'react-window'\nimport { AlbumGridProps } from '../../types'\nimport AlbumTile from '../AlbumTile'\nimport { Skeleton } from '../ui/skeleton'\nimport { cn } from '../../lib/utils'\nimport { measureRenderTime } from '../../utils/performanceMonitor'\n\ninterface VirtualizedAlbumGridProps extends AlbumGridProps {\n  itemHeight?: number\n  itemWidth?: number\n  containerHeight?: number\n  overscanRowCount?: number\n}\n\ninterface GridItemData {\n  albums: AlbumGridProps['albums']\n  columnCount: number\n  onAlbumClick: AlbumGridProps['onAlbumClick']\n  onAlbumReorder: AlbumGridProps['onAlbumReorder']\n  onAlbumDelete: AlbumGridProps['onAlbumDelete']\n  itemWidth: number\n  itemHeight: number\n}", "metadata": {}}
{"id": "169", "text": "interface VirtualizedAlbumGridProps extends AlbumGridProps {\n  itemHeight?: number\n  itemWidth?: number\n  containerHeight?: number\n  overscanRowCount?: number\n}\n\ninterface GridItemData {\n  albums: AlbumGridProps['albums']\n  columnCount: number\n  onAlbumClick: AlbumGridProps['onAlbumClick']\n  onAlbumReorder: AlbumGridProps['onAlbumReorder']\n  onAlbumDelete: AlbumGridProps['onAlbumDelete']\n  itemWidth: number\n  itemHeight: number\n}\n\n// Grid cell renderer component\nconst GridCell = ({\n  columnIndex,\n  rowIndex,\n  style,\n  data\n}: {\n  columnIndex: number\n  rowIndex: number\n  style: React.CSSProperties\n  data: GridItemData\n}) => {\n  const { albums, columnCount, onAlbumClick, onAlbumDelete, itemWidth, itemHeight } = data\n  const index = rowIndex * columnCount + columnIndex", "metadata": {}}
{"id": "170", "text": "// Grid cell renderer component\nconst GridCell = ({\n  columnIndex,\n  rowIndex,\n  style,\n  data\n}: {\n  columnIndex: number\n  rowIndex: number\n  style: React.CSSProperties\n  data: GridItemData\n}) => {\n  const { albums, columnCount, onAlbumClick, onAlbumDelete, itemWidth, itemHeight } = data\n  const index = rowIndex * columnCount + columnIndex\n\n  // Return empty cell if no album at this index\n  if (index >= albums.length) {\n    return <div style={style} />\n  }\n\n  const album = albums[index]", "metadata": {}}
{"id": "171", "text": "// Return empty cell if no album at this index\n  if (index >= albums.length) {\n    return <div style={style} />\n  }\n\n  const album = albums[index]\n\n  return (\n    <div\n      style={{\n        ...style,\n        padding: '12px', // Gap between items\n        boxSizing: 'border-box'\n      }}\n    >\n      <div\n        style={{\n          width: itemWidth - 24, // Account for padding\n          height: itemHeight - 24\n        }}\n      >\n        <AlbumTile\n          album={album}\n          thumbnailSrc={album.thumbnailPhotoId ? `/api/photos/${album.thumbnailPhotoId}/thumbnail` : undefined}\n          onClick={() => onAlbumClick(album.id)}\n          onDelete={onAlbumDelete ? () => onAlbumDelete(album.id) : undefined}\n          data-testid={`album-tile-${album.id}`}\n          className=\"w-full h-full\"\n        />\n      </div>\n    </div>\n  )\n}", "metadata": {}}
{"id": "172", "text": "const VirtualizedAlbumGrid = ({\n  albums,\n  onAlbumClick,\n  onAlbumReorder,\n  onAlbumDelete,\n  loading = false,\n  className = '',\n  itemHeight = 280,\n  itemWidth = 320,\n  containerHeight = 600,\n  overscanRowCount = 3,\n  ...props\n}: VirtualizedAlbumGridProps) => {\n  const gridRef = useRef<Grid>(null)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const [containerSize, setContainerSize] = useState({ width: 0, height: containerHeight })\n\n  // Calculate grid dimensions based on container size\n  const { columnCount, rowCount } = useMemo(() => {\n    const availableWidth = containerSize.width || 960 // Default width\n    const cols = Math.max(1, Math.floor(availableWidth / itemWidth))\n    const rows = Math.ceil(albums.length / cols)\n\n    return {\n      columnCount: cols,\n      rowCount: rows\n    }\n  }, [containerSize.width, itemWidth, albums.length])", "metadata": {}}
{"id": "173", "text": "// Calculate grid dimensions based on container size\n  const { columnCount, rowCount } = useMemo(() => {\n    const availableWidth = containerSize.width || 960 // Default width\n    const cols = Math.max(1, Math.floor(availableWidth / itemWidth))\n    const rows = Math.ceil(albums.length / cols)\n\n    return {\n      columnCount: cols,\n      rowCount: rows\n    }\n  }, [containerSize.width, itemWidth, albums.length])\n\n  // Create data object for grid cells\n  const itemData: GridItemData = useMemo(() => ({\n    albums,\n    columnCount,\n    onAlbumClick,\n    onAlbumReorder,\n    onAlbumDelete,\n    itemWidth,\n    itemHeight\n  }), [albums, columnCount, onAlbumClick, onAlbumReorder, onAlbumDelete, itemWidth, itemHeight])", "metadata": {}}
{"id": "174", "text": "return {\n      columnCount: cols,\n      rowCount: rows\n    }\n  }, [containerSize.width, itemWidth, albums.length])\n\n  // Create data object for grid cells\n  const itemData: GridItemData = useMemo(() => ({\n    albums,\n    columnCount,\n    onAlbumClick,\n    onAlbumReorder,\n    onAlbumDelete,\n    itemWidth,\n    itemHeight\n  }), [albums, columnCount, onAlbumClick, onAlbumReorder, onAlbumDelete, itemWidth, itemHeight])\n\n  // Handle container resize\n  useEffect(() => {\n    const handleResize = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect()\n        setContainerSize({ width: rect.width, height: containerHeight })\n      }\n    }\n\n    handleResize()\n    window.addEventListener('resize', handleResize)\n\n    return () => window.removeEventListener('resize', handleResize)\n  }, [containerHeight])", "metadata": {}}
{"id": "175", "text": "// Handle container resize\n  useEffect(() => {\n    const handleResize = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect()\n        setContainerSize({ width: rect.width, height: containerHeight })\n      }\n    }\n\n    handleResize()\n    window.addEventListener('resize', handleResize)\n\n    return () => window.removeEventListener('resize', handleResize)\n  }, [containerHeight])\n\n  // Keyboard navigation handler\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (!gridRef.current) return\n\n    const totalItems = albums.length\n    const currentFocus = document.activeElement\n    const focusedTile = currentFocus?.closest('[data-testid^=\"album-tile-\"]')\n\n    if (!focusedTile) return\n\n    const testId = focusedTile.getAttribute('data-testid')\n    const albumId = testId?.replace('album-tile-', '')\n    const currentIndex = albums.findIndex(album => album.id.toString() === albumId)\n\n    if (currentIndex === -1) return\n\n    let nextIndex = currentIndex", "metadata": {}}
{"id": "176", "text": "const totalItems = albums.length\n    const currentFocus = document.activeElement\n    const focusedTile = currentFocus?.closest('[data-testid^=\"album-tile-\"]')\n\n    if (!focusedTile) return\n\n    const testId = focusedTile.getAttribute('data-testid')\n    const albumId = testId?.replace('album-tile-', '')\n    const currentIndex = albums.findIndex(album => album.id.toString() === albumId)\n\n    if (currentIndex === -1) return\n\n    let nextIndex = currentIndex\n\n    switch (e.key) {\n      case 'ArrowRight':\n        e.preventDefault()\n        nextIndex = Math.min(currentIndex + 1, totalItems - 1)\n        break\n      case 'ArrowLeft':\n        e.preventDefault()\n        nextIndex = Math.max(currentIndex - 1, 0)\n        break\n      case 'ArrowDown':\n        e.preventDefault()\n        nextIndex = Math.min(currentIndex + columnCount, totalItems - 1)\n        break\n      case 'ArrowUp':\n        e.preventDefault()\n        nextIndex = Math.max(currentIndex - columnCount, 0)\n        break\n      case 'Home':\n        e.preventDefault()\n        nextIndex = 0\n        break\n      case 'End':\n        e.preventDefault()\n        nextIndex = totalItems - 1\n        break\n      default:\n        return\n    }", "metadata": {}}
{"id": "177", "text": "if (nextIndex !== currentIndex) {\n      // Scroll to the new item\n      const newRow = Math.floor(nextIndex / columnCount)\n      const newCol = nextIndex % columnCount\n\n      gridRef.current?.scrollToItem({\n        rowIndex: newRow,\n        columnIndex: newCol,\n        align: 'smart'\n      })\n\n      // Focus the new item after a short delay to allow scrolling\n      setTimeout(() => {\n        const newTile = document.querySelector(`[data-testid=\"album-tile-${albums[nextIndex].id}\"]`) as HTMLElement\n        if (newTile && newTile.focus) {\n          newTile.focus()\n        }\n      }, 100)\n    }\n  }, [albums, columnCount])\n\n  if (loading) {\n    return (\n      <div\n        className={cn(\n          \"grid gap-6\",\n          \"grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\",\n          \"auto-rows-max\",", "metadata": {}}
{"id": "178", "text": "if (loading) {\n    return (\n      <div\n        className={cn(\n          \"grid gap-6\",\n          \"grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\",\n          \"auto-rows-max\",\n          className\n        )}\n        role=\"region\"\n        aria-label=\"Loading albums\"\n        aria-live=\"polite\"\n        {...props}\n      >\n        {/* Loading skeleton */}\n        {Array.from({ length: 6 }).map((_,", "metadata": {}}
{"id": "179", "text": "if (loading) {\n    return (\n      <div\n        className={cn(\n          \"grid gap-6\",\n          \"grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\",\n          \"auto-rows-max\",\n          className\n        )}\n        role=\"region\"\n        aria-label=\"Loading albums\"\n        aria-live=\"polite\"\n        {...props}\n      >\n        {/* Loading skeleton */}\n        {Array.from({ length: 6 }).map((_, index) => (\n          <div\n            key={`skeleton-${index}`}\n            className=\"bg-card rounded-lg shadow-sm overflow-hidden border\"\n            aria-hidden=\"true\"\n          >\n            <Skeleton className=\"aspect-square\" />\n            <div className=\"p-4 space-y-2\">\n              <Skeleton className=\"h-5 w-3/4\" />\n              <Skeleton className=\"h-4 w-1/2\" />\n              <Skeleton className=\"h-3 w-1/3\" />\n            </div>\n          </div>\n        ))}\n        <div className=\"sr-only\">Loading your photo albums.", "metadata": {}}
{"id": "180", "text": "index) => (\n          <div\n            key={`skeleton-${index}`}\n            className=\"bg-card rounded-lg shadow-sm overflow-hidden border\"\n            aria-hidden=\"true\"\n          >\n            <Skeleton className=\"aspect-square\" />\n            <div className=\"p-4 space-y-2\">\n              <Skeleton className=\"h-5 w-3/4\" />\n              <Skeleton className=\"h-4 w-1/2\" />\n              <Skeleton className=\"h-3 w-1/3\" />\n            </div>\n          </div>\n        ))}\n        <div className=\"sr-only\">Loading your photo albums...</div>\n      </div>\n    )\n  }\n\n  if (albums.", "metadata": {}}
{"id": "181", "text": "..</div>\n      </div>\n    )\n  }\n\n  if (albums.length === 0) {\n    return (\n      <div\n        className=\"text-center py-12\"\n        role=\"region\"\n        aria-label=\"Empty albums state\"\n      >\n        <div className=\"mx-auto w-24 h-24 bg-gray-100 rounded-full flex items-center justify-center mb-4\">\n          <svg\n            className=\"w-12 h-12 text-gray-400\"\n            fill=\"currentColor\"\n            viewBox=\"0 0 20 20\"\n            xmlns=\"http://www.w3.", "metadata": {}}
{"id": "182", "text": "..</div>\n      </div>\n    )\n  }\n\n  if (albums.length === 0) {\n    return (\n      <div\n        className=\"text-center py-12\"\n        role=\"region\"\n        aria-label=\"Empty albums state\"\n      >\n        <div className=\"mx-auto w-24 h-24 bg-gray-100 rounded-full flex items-center justify-center mb-4\">\n          <svg\n            className=\"w-12 h-12 text-gray-400\"\n            fill=\"currentColor\"\n            viewBox=\"0 0 20 20\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            aria-hidden=\"true\"\n          >\n            <path\n              fillRule=\"evenodd\"\n              d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\"\n              clipRule=\"evenodd\"\n            />\n          </svg>\n        </div>\n        <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No albums found</h3>\n        <p className=\"text-gray-500\">Upload photos to get started</p>\n      </div>\n    )\n  }", "metadata": {}}
{"id": "183", "text": "return (\n    <div\n      ref={containerRef}\n      className={cn(\"relative\", className)}\n      role=\"grid\"\n      aria-label={`Virtualized photo albums grid containing ${albums.length} albums`}\n      onKeyDown={handleKeyDown}\n      tabIndex={0}\n      {...props}\n    >\n      {containerSize.width > 0 && (\n        <Grid\n          ref={gridRef}\n          columnCount={columnCount}\n          columnWidth={itemWidth}\n          height={containerSize.height}\n          rowCount={rowCount}\n          rowHeight={itemHeight}\n          width={containerSize.width}\n          itemData={itemData}\n          overscanRowCount={overscanRowCount}\n          style={{\n            outline: 'none' // Remove focus outline from grid container\n          }}\n        >\n          {(props: { columnIndex: number; rowIndex: number; style: React.CSSProperties; data: GridItemData }) =>\n            measureRenderTime(() => (\n              <GridCell\n                columnIndex={props.columnIndex}\n                rowIndex={props.rowIndex}\n                style={props.", "metadata": {}}
{"id": "184", "text": "height}\n          rowCount={rowCount}\n          rowHeight={itemHeight}\n          width={containerSize.width}\n          itemData={itemData}\n          overscanRowCount={overscanRowCount}\n          style={{\n            outline: 'none' // Remove focus outline from grid container\n          }}\n        >\n          {(props: { columnIndex: number; rowIndex: number; style: React.CSSProperties; data: GridItemData }) =>\n            measureRenderTime(() => (\n              <GridCell\n                columnIndex={props.columnIndex}\n                rowIndex={props.rowIndex}\n                style={props.style}\n                data={props.data}\n              />\n            ))\n          }\n        </Grid>\n      )}\n\n      {/* Performance indicator for development */}\n      {process.env.NODE_ENV === 'development' && (\n        <div className=\"absolute top-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded\">\n          Virtualized: {albums.length} items, {columnCount}×{rowCount} grid\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport default VirtualizedAlbumGrid", "metadata": {}}
{"id": "185", "text": "import { useCallback, useRef } from 'react'\nimport { AlbumGridProps } from '../../types'\nimport AlbumTile from '../AlbumTile'\nimport VirtualizedAlbumGrid from './VirtualizedAlbumGrid'\nimport { Skeleton } from '../ui/skeleton'\nimport { cn } from '../../lib/utils'\nimport { useSmartVirtualization } from '../../hooks/useVirtualization'\nimport { useAlbumImagePreloading } from '../../hooks/useImagePreloading'\n\nconst AlbumGrid = ({\n  albums,\n  onAlbumClick,\n  onAlbumReorder,\n  onAlbumDelete,\n  loading = false,\n  className = '',\n  ...props\n}: AlbumGridProps) => {\n  const gridRef = useRef<HTMLDivElement>(null)\n\n  // Smart virtualization decision based on album count and performance\n  const virtualization = useSmartVirtualization(albums.length, 280, 320, {\n    itemThreshold: 50,\n    heightThreshold: 2000\n  })", "metadata": {}}
{"id": "186", "text": "const AlbumGrid = ({\n  albums,\n  onAlbumClick,\n  onAlbumReorder,\n  onAlbumDelete,\n  loading = false,\n  className = '',\n  ...props\n}: AlbumGridProps) => {\n  const gridRef = useRef<HTMLDivElement>(null)\n\n  // Smart virtualization decision based on album count and performance\n  const virtualization = useSmartVirtualization(albums.length, 280, 320, {\n    itemThreshold: 50,\n    heightThreshold: 2000\n  })\n\n  // Image preloading for smooth user experience\n  const { preloadState, preloadStats } = useAlbumImagePreloading(albums, {\n    enableThumbnailPreloading: true,\n    preloadAhead: virtualization.shouldVirtualize ? 20 : 10,\n    priorities: {\n      thumbnail: 'high',\n      fullImage: 'low'\n    },\n    smartPreloading: true\n  })", "metadata": {}}
{"id": "187", "text": "// Image preloading for smooth user experience\n  const { preloadState, preloadStats } = useAlbumImagePreloading(albums, {\n    enableThumbnailPreloading: true,\n    preloadAhead: virtualization.shouldVirtualize ? 20 : 10,\n    priorities: {\n      thumbnail: 'high',\n      fullImage: 'low'\n    },\n    smartPreloading: true\n  })\n\n  // Use virtualized grid for large datasets\n  if (virtualization.shouldVirtualize && !loading) {\n    return (\n      <VirtualizedAlbumGrid\n        albums={albums}\n        onAlbumClick={onAlbumClick}\n        onAlbumReorder={onAlbumReorder}\n        onAlbumDelete={onAlbumDelete}\n        loading={loading}\n        className={className}\n        containerHeight={virtualization.containerHeight}\n        itemWidth={virtualization.itemDimensions.width}\n        itemHeight={virtualization.itemDimensions.height}\n        {...props}\n      />\n    )\n  }\n\n  // Keyboard navigation handler\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (!gridRef.current) return", "metadata": {}}
{"id": "188", "text": "// Keyboard navigation handler\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (!gridRef.current) return\n\n    const tiles = Array.from(gridRef.current.querySelectorAll('[role=\"button\"]')) as HTMLElement[]\n    const currentIndex = tiles.findIndex(tile => tile === document.activeElement)\n\n    let nextIndex = currentIndex\n    const cols = getGridColumns()", "metadata": {}}
{"id": "189", "text": "// Keyboard navigation handler\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (!gridRef.current) return\n\n    const tiles = Array.from(gridRef.current.querySelectorAll('[role=\"button\"]')) as HTMLElement[]\n    const currentIndex = tiles.findIndex(tile => tile === document.activeElement)\n\n    let nextIndex = currentIndex\n    const cols = getGridColumns()\n\n    switch (e.key) {\n      case 'ArrowRight':\n        e.preventDefault()\n        nextIndex = Math.min(currentIndex + 1, tiles.length - 1)\n        break\n      case 'ArrowLeft':\n        e.preventDefault()\n        nextIndex = Math.max(currentIndex - 1, 0)\n        break\n      case 'ArrowDown':\n        e.preventDefault()\n        nextIndex = Math.min(currentIndex + cols, tiles.length - 1)\n        break\n      case 'ArrowUp':\n        e.preventDefault()\n        nextIndex = Math.max(currentIndex - cols, 0)\n        break\n      case 'Home':\n        e.preventDefault()\n        nextIndex = 0\n        break\n      case 'End':\n        e.preventDefault()\n        nextIndex = tiles.length - 1\n        break\n      default:\n        return\n    }", "metadata": {}}
{"id": "190", "text": "if (nextIndex !== currentIndex && tiles[nextIndex]) {\n      tiles[nextIndex].focus()\n    }\n  }, [])\n\n  // Helper function to determine grid columns based on screen size\n  const getGridColumns = useCallback(() => {\n    if (!gridRef.current) return 3\n\n    const styles = window.getComputedStyle(gridRef.current)\n    const cols = styles.gridTemplateColumns.split(' ').length\n    return cols\n  }, [])\n  if (loading) {\n    return (\n      <div\n        className={cn(\n          \"grid gap-6\",\n          \"grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\",\n          \"auto-rows-max\",\n          className\n        )}\n        role=\"region\"\n        aria-label=\"Loading albums\"\n        aria-live=\"polite\"\n        {...props}\n      >\n        {/* Loading skeleton */}\n        {Array.from({ length: 6 }).map((_,", "metadata": {}}
{"id": "191", "text": "gridTemplateColumns.split(' ').length\n    return cols\n  }, [])\n  if (loading) {\n    return (\n      <div\n        className={cn(\n          \"grid gap-6\",\n          \"grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\",\n          \"auto-rows-max\",\n          className\n        )}\n        role=\"region\"\n        aria-label=\"Loading albums\"\n        aria-live=\"polite\"\n        {...props}\n      >\n        {/* Loading skeleton */}\n        {Array.from({ length: 6 }).map((_, index) => (\n          <div\n            key={`skeleton-${index}`}\n            className=\"bg-card rounded-lg shadow-sm overflow-hidden border\"\n            aria-hidden=\"true\"\n          >\n            <Skeleton className=\"aspect-square\" />\n            <div className=\"p-4 space-y-2\">\n              <Skeleton className=\"h-5 w-3/4\" />\n              <Skeleton className=\"h-4 w-1/2\" />\n              <Skeleton className=\"h-3 w-1/3\" />\n            </div>\n          </div>\n        ))}\n        <div className=\"sr-only\">Loading your photo albums.", "metadata": {}}
{"id": "192", "text": "index) => (\n          <div\n            key={`skeleton-${index}`}\n            className=\"bg-card rounded-lg shadow-sm overflow-hidden border\"\n            aria-hidden=\"true\"\n          >\n            <Skeleton className=\"aspect-square\" />\n            <div className=\"p-4 space-y-2\">\n              <Skeleton className=\"h-5 w-3/4\" />\n              <Skeleton className=\"h-4 w-1/2\" />\n              <Skeleton className=\"h-3 w-1/3\" />\n            </div>\n          </div>\n        ))}\n        <div className=\"sr-only\">Loading your photo albums...</div>\n      </div>\n    )\n  }\n\n  if (albums.", "metadata": {}}
{"id": "193", "text": "..</div>\n      </div>\n    )\n  }\n\n  if (albums.length === 0) {\n    return (\n      <div\n        className=\"text-center py-12\"\n        role=\"region\"\n        aria-label=\"Empty albums state\"\n      >\n        <div className=\"mx-auto w-24 h-24 bg-gray-100 rounded-full flex items-center justify-center mb-4\">\n          <svg\n            className=\"w-12 h-12 text-gray-400\"\n            fill=\"currentColor\"\n            viewBox=\"0 0 20 20\"\n            xmlns=\"http://www.w3.", "metadata": {}}
{"id": "194", "text": "..</div>\n      </div>\n    )\n  }\n\n  if (albums.length === 0) {\n    return (\n      <div\n        className=\"text-center py-12\"\n        role=\"region\"\n        aria-label=\"Empty albums state\"\n      >\n        <div className=\"mx-auto w-24 h-24 bg-gray-100 rounded-full flex items-center justify-center mb-4\">\n          <svg\n            className=\"w-12 h-12 text-gray-400\"\n            fill=\"currentColor\"\n            viewBox=\"0 0 20 20\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            aria-hidden=\"true\"\n          >\n            <path\n              fillRule=\"evenodd\"\n              d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\"\n              clipRule=\"evenodd\"\n            />\n          </svg>\n        </div>\n        <h3 className=\"text-lg font-medium text-gray-900 mb-2\">No albums found</h3>\n        <p className=\"text-gray-500\">Upload photos to get started</p>\n      </div>\n    )\n  }", "metadata": {}}
{"id": "195", "text": "return (\n    <div\n      ref={gridRef}\n      className={cn(\n        \"grid gap-6\",\n        \"grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\",\n        \"auto-rows-max\",\n        className\n      )}\n      role=\"grid\"\n      aria-label={`Photo albums grid containing ${albums.length} albums`}\n      onKeyDown={handleKeyDown}\n      {...props}\n    >\n      {albums.map((album, index) => (\n        <AlbumTile\n          key={album.id}\n          album={album}\n          thumbnailSrc={album.thumbnailPhotoId ? `/api/photos/${album.thumbnailPhotoId}/thumbnail` : undefined}\n          onClick={() => onAlbumClick(album.id)}\n          onDelete={onAlbumDelete ? () => onAlbumDelete(album.id) : undefined}\n          data-testid={`album-tile-${album.id}`}\n          aria-setsize={albums.length}\n          aria-posinset={index + 1}\n        />\n      ))}", "metadata": {}}
{"id": "196", "text": "{/* Performance indicator for development */}\n      {process.env.NODE_ENV === 'development' && preloadState.isPreloading && (\n        <div className=\"fixed bottom-4 right-4 bg-blue-500 text-white text-xs px-3 py-2 rounded-lg shadow-lg\">\n          <div className=\"flex items-center space-x-2\">\n            <div className=\"animate-spin w-3 h-3 border border-white border-t-transparent rounded-full\" />\n            <span>Preloading images... ({preloadState.preloadingCount})</span>\n          </div>\n        </div>\n      )}", "metadata": {}}
{"id": "197", "text": "{/* Performance indicator for development */}\n      {process.env.NODE_ENV === 'development' && preloadState.isPreloading && (\n        <div className=\"fixed bottom-4 right-4 bg-blue-500 text-white text-xs px-3 py-2 rounded-lg shadow-lg\">\n          <div className=\"flex items-center space-x-2\">\n            <div className=\"animate-spin w-3 h-3 border border-white border-t-transparent rounded-full\" />\n            <span>Preloading images... ({preloadState.preloadingCount})</span>\n          </div>\n        </div>\n      )}\n\n      {/* Preload stats for development */}\n      {process.env.NODE_ENV === 'development' && preloadStats.total > 0 && (\n        <div className=\"fixed bottom-16 right-4 bg-green-500 text-white text-xs px-3 py-2 rounded-lg shadow-lg\">\n          <div>Preloaded: {preloadStats.successful}/{preloadStats.total}</div>\n          <div>Cache hit rate: {(preloadStats.cacheHitRate * 100).toFixed(1)}%</div>\n        </div>\n      )}\n    </div>\n  )\n}", "metadata": {}}
{"id": "198", "text": "{/* Preload stats for development */}\n      {process.env.NODE_ENV === 'development' && preloadStats.total > 0 && (\n        <div className=\"fixed bottom-16 right-4 bg-green-500 text-white text-xs px-3 py-2 rounded-lg shadow-lg\">\n          <div>Preloaded: {preloadStats.successful}/{preloadStats.total}</div>\n          <div>Cache hit rate: {(preloadStats.cacheHitRate * 100).toFixed(1)}%</div>\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport default AlbumGrid", "metadata": {}}
{"id": "199", "text": "import type { Meta, StoryObj } from '@storybook/react'\nimport AlbumTile from './index'\nimport { Album } from '../../types'\n\n// Sample album data for stories\nconst sampleAlbum: Album = {\n  id: 1,\n  name: 'Summer Vacation 2024',\n  captureDate: new Date('2024-07-15'),\n  displayOrder: 1,\n  thumbnailPhotoId: 101,\n  photoCount: 24,\n  createdAt: new Date('2024-07-15T10:00:00Z'),\n  updatedAt: new Date('2024-07-15T10:00:00Z'),\n}", "metadata": {}}
{"id": "200", "text": "// Sample album data for stories\nconst sampleAlbum: Album = {\n  id: 1,\n  name: 'Summer Vacation 2024',\n  captureDate: new Date('2024-07-15'),\n  displayOrder: 1,\n  thumbnailPhotoId: 101,\n  photoCount: 24,\n  createdAt: new Date('2024-07-15T10:00:00Z'),\n  updatedAt: new Date('2024-07-15T10:00:00Z'),\n}\n\nconst largePhlotoCountAlbum: Album = {\n  id: 2,\n  name: 'Wedding Day - Sarah & John',\n  captureDate: new Date('2024-06-10'),\n  displayOrder: 2,\n  thumbnailPhotoId: 102,\n  photoCount: 1847,\n  createdAt: new Date('2024-06-10T14:00:00Z'),\n  updatedAt: new Date('2024-06-10T14:00:00Z'),\n}", "metadata": {}}
{"id": "201", "text": "const largePhlotoCountAlbum: Album = {\n  id: 2,\n  name: 'Wedding Day - Sarah & John',\n  captureDate: new Date('2024-06-10'),\n  displayOrder: 2,\n  thumbnailPhotoId: 102,\n  photoCount: 1847,\n  createdAt: new Date('2024-06-10T14:00:00Z'),\n  updatedAt: new Date('2024-06-10T14:00:00Z'),\n}\n\nconst noThumbnailAlbum: Album = {\n  id: 3,\n  name: 'Quick Snapshots',\n  captureDate: new Date('2024-08-20'),\n  displayOrder: 3,\n  thumbnailPhotoId: null,\n  photoCount: 3,\n  createdAt: new Date('2024-08-20T09:00:00Z'),\n  updatedAt: new Date('2024-08-20T09:00:00Z'),\n}", "metadata": {}}
{"id": "202", "text": "const noThumbnailAlbum: Album = {\n  id: 3,\n  name: 'Quick Snapshots',\n  captureDate: new Date('2024-08-20'),\n  displayOrder: 3,\n  thumbnailPhotoId: null,\n  photoCount: 3,\n  createdAt: new Date('2024-08-20T09:00:00Z'),\n  updatedAt: new Date('2024-08-20T09:00:00Z'),\n}\n\nconst meta: Meta<typeof AlbumTile> = {\n  title: 'Components/AlbumTile',\n  component: AlbumTile,\n  parameters: {\n    layout: 'centered',\n    docs: {\n      description: {\n        component: `\nA tile component that displays album information including thumbnail, name, photo count, and date.\nSupports accessibility features like ARIA labels, keyboard navigation, and focus management.", "metadata": {}}
{"id": "203", "text": "const meta: Meta<typeof AlbumTile> = {\n  title: 'Components/AlbumTile',\n  component: AlbumTile,\n  parameters: {\n    layout: 'centered',\n    docs: {\n      description: {\n        component: `\nA tile component that displays album information including thumbnail, name, photo count, and date.\nSupports accessibility features like ARIA labels, keyboard navigation, and focus management.\n        `,\n      },\n    },\n  },\n  tags: ['autodocs'],\n  argTypes: {\n    album: {\n      description: 'Album data object containing all album information',\n      control: { type: 'object' },\n    },\n    thumbnailSrc: {\n      description: 'URL or data URL for the album thumbnail image',\n      control: { type: 'text' },\n    },\n    onClick: {\n      description: 'Callback function called when the album tile is clicked',\n      action: 'clicked',\n    },\n    onDelete: {\n      description: 'Optional callback function for deleting the album',\n      action: 'deleted',\n    },\n    isDragging: {\n      description: 'Visual state indicating if the tile is being dragged',\n      control: { type: 'boolean' },\n    },\n    className: {\n      description: 'Additional CSS classes to apply to the component',\n      control: { type: 'text' },\n    },\n  },\n  args: {\n    onClick: () => console.log('Album clicked'),\n  },\n}", "metadata": {}}
{"id": "204", "text": "export default meta\ntype Story = StoryObj<typeof meta>\n\n// Default story with thumbnail\nexport const Default: Story = {\n  args: {\n    album: sampleAlbum,\n    thumbnailSrc: 'https://picsum.photos/300/300?random=1',\n  },\n}\n\n// Large photo count\nexport const LargePhotoCount: Story = {\n  args: {\n    album: largePhlotoCountAlbum,\n    thumbnailSrc: 'https://picsum.photos/300/300?random=2',\n  },\n}\n\n// No thumbnail (fallback state)\nexport const NoThumbnail: Story = {\n  args: {\n    album: noThumbnailAlbum,\n    thumbnailSrc: undefined,\n  },\n}\n\n// With delete button\nexport const WithDeleteButton: Story = {\n  args: {\n    album: sampleAlbum,\n    thumbnailSrc: 'https://picsum.photos/300/300?random=3',\n    onDelete: () => console.log('Delete clicked'),\n  },\n}", "metadata": {}}
{"id": "205", "text": "// No thumbnail (fallback state)\nexport const NoThumbnail: Story = {\n  args: {\n    album: noThumbnailAlbum,\n    thumbnailSrc: undefined,\n  },\n}\n\n// With delete button\nexport const WithDeleteButton: Story = {\n  args: {\n    album: sampleAlbum,\n    thumbnailSrc: 'https://picsum.photos/300/300?random=3',\n    onDelete: () => console.log('Delete clicked'),\n  },\n}\n\n// Dragging state\nexport const Dragging: Story = {\n  args: {\n    album: sampleAlbum,\n    thumbnailSrc: 'https://picsum.photos/300/300?random=4',\n    isDragging: true,\n  },\n}\n\n// Error loading thumbnail\nexport const ThumbnailError: Story = {\n  args: {\n    album: sampleAlbum,\n    thumbnailSrc: 'https://invalid-url/404.jpg',\n  },\n}", "metadata": {}}
{"id": "206", "text": "// Dragging state\nexport const Dragging: Story = {\n  args: {\n    album: sampleAlbum,\n    thumbnailSrc: 'https://picsum.photos/300/300?random=4',\n    isDragging: true,\n  },\n}\n\n// Error loading thumbnail\nexport const ThumbnailError: Story = {\n  args: {\n    album: sampleAlbum,\n    thumbnailSrc: 'https://invalid-url/404.jpg',\n  },\n}\n\n// Accessibility focused\nexport const AccessibilityFocused: Story = {\n  args: {\n    album: sampleAlbum,\n    thumbnailSrc: 'https://picsum.photos/300/300?random=5',\n  },\n  parameters: {\n    docs: {\n      description: {\n        story: `\nThis story demonstrates the accessibility features of the AlbumTile component.\nTry tabbing to focus on the tile and using Enter or Space to activate it.\n        `,\n      },\n    },\n  },\n  play: async ({ canvasElement }) => {\n    // Auto-focus the tile for accessibility demo\n    const tile = canvasElement.querySelector('[role=\"button\"]') as HTMLElement\n    if (tile) {\n      tile.focus()\n    }\n  },\n}", "metadata": {}}
{"id": "207", "text": "// Interactive group\nexport const InteractiveGroup: Story = {\n  render: () => (\n    <div className=\"grid grid-cols-2 gap-4 max-w-2xl\">\n      <AlbumTile\n        album={sampleAlbum}\n        thumbnailSrc=\"https://picsum.photos/300/300?random=6\"\n        onClick={() => console.log('Summer Vacation clicked')}\n        onDelete={() => console.log('Delete Summer Vacation')}\n      />\n      <AlbumTile\n        album={largePhlotoCountAlbum}\n        thumbnailSrc=\"https://picsum.photos/300/300?random=7\"\n        onClick={() => console.log('Wedding clicked')}\n      />\n      <AlbumTile\n        album={noThumbnailAlbum}\n        onClick={() => console.log('Quick Snapshots clicked')}\n      />\n      <AlbumTile\n        album={{...sampleAlbum, id: 4, name: 'Birthday Party', photoCount: 67}}\n        thumbnailSrc=\"https://picsum.photos/300/300?random=8\"\n        onClick={() => console.", "metadata": {}}
{"id": "208", "text": "photos/300/300?random=7\"\n        onClick={() => console.log('Wedding clicked')}\n      />\n      <AlbumTile\n        album={noThumbnailAlbum}\n        onClick={() => console.log('Quick Snapshots clicked')}\n      />\n      <AlbumTile\n        album={{...sampleAlbum, id: 4, name: 'Birthday Party', photoCount: 67}}\n        thumbnailSrc=\"https://picsum.photos/300/300?random=8\"\n        onClick={() => console.log('Birthday clicked')}\n        isDragging={true}\n      />\n    </div>\n  ),\n  parameters: {\n    docs: {\n      description: {\n        story: `\nMultiple album tiles demonstrating different states including:\n- Standard tile with delete button\n- Large photo count\n- No thumbnail fallback\n- Dragging state\n        `,\n      },\n    },\n  },\n}", "metadata": {}}
{"id": "209", "text": "import { useState, useCallback } from 'react'\nimport { Card, CardContent } from '../ui/card'\nimport { AlbumTileProps } from '../../types'\nimport { cn } from '../../lib/utils'\n\nconst AlbumTile = ({\n  album,\n  thumbnailSrc,\n  onClick,\n  onDelete,\n  isDragging = false,\n  dragHandleProps,\n  className,\n  'data-testid': testId,\n  ...props\n}: AlbumTileProps) => {\n  const [imageLoaded, setImageLoaded] = useState(false)\n  const [imageError, setImageError] = useState(false)\n\n  const handleImageLoad = useCallback(() => {\n    setImageLoaded(true)\n  }, [])\n\n  const handleImageError = useCallback(() => {\n    setImageError(true)\n    setImageLoaded(true)\n  }, [])\n\n  const handleClick = useCallback(() => {\n    if (!isDragging) {\n      onClick()\n    }\n  }, [onClick, isDragging])", "metadata": {}}
{"id": "210", "text": "const handleImageLoad = useCallback(() => {\n    setImageLoaded(true)\n  }, [])\n\n  const handleImageError = useCallback(() => {\n    setImageError(true)\n    setImageLoaded(true)\n  }, [])\n\n  const handleClick = useCallback(() => {\n    if (!isDragging) {\n      onClick()\n    }\n  }, [onClick, isDragging])\n\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault()\n      handleClick()\n    }\n  }, [handleClick])", "metadata": {}}
{"id": "211", "text": "const handleImageLoad = useCallback(() => {\n    setImageLoaded(true)\n  }, [])\n\n  const handleImageError = useCallback(() => {\n    setImageError(true)\n    setImageLoaded(true)\n  }, [])\n\n  const handleClick = useCallback(() => {\n    if (!isDragging) {\n      onClick()\n    }\n  }, [onClick, isDragging])\n\n  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault()\n      handleClick()\n    }\n  }, [handleClick])\n\n  return (\n    <Card\n      className={cn(\n        \"group cursor-pointer transition-all duration-200 hover:shadow-md focus-within:ring-2 focus-within:ring-blue-500 focus-within:ring-offset-2\",\n        isDragging && \"opacity-50 transform rotate-3 scale-105 shadow-lg\",\n        className\n      )}\n      onClick={handleClick}\n      tabIndex={0}\n      role=\"button\"\n      aria-label={`View album ${album.name} with ${album.photoCount} photos`}\n      onKeyDown={handleKeyDown}\n      data-testid={testId}\n      {...dragHandleProps}\n      {...props}\n    >\n      <CardContent className=\"p-4\">\n        {/* Thumbnail container with aspect ratio */}\n        <div className=\"aspect-square relative mb-3 overflow-hidden rounded-lg bg-gray-100\">\n          {thumbnailSrc && !imageError ? (\n            <>\n              {/* Loading skeleton */}\n              {!imageLoaded && (\n                <div className=\"absolute inset-0 bg-gray-200 animate-pulse rounded-lg\" />\n              )}", "metadata": {}}
{"id": "212", "text": "{/* Lazy loaded thumbnail image */}\n              <img\n                src={thumbnailSrc}\n                alt={`${album.name} thumbnail`}\n                className={cn(\n                  \"w-full h-full object-cover transition-opacity duration-300\",\n                  imageLoaded ? \"opacity-100\" : \"opacity-0\"\n                )}\n                loading=\"lazy\"\n                onLoad={handleImageLoad}\n                onError={handleImageError}\n              />\n            </>\n          ) : (\n            /* Fallback when no thumbnail or error */\n            <div\n              className=\"bg-muted flex items-center justify-center w-full h-full text-gray-400\"\n              data-testid={imageError ?", "metadata": {}}
{"id": "213", "text": "\"opacity-100\" : \"opacity-0\"\n                )}\n                loading=\"lazy\"\n                onLoad={handleImageLoad}\n                onError={handleImageError}\n              />\n            </>\n          ) : (\n            /* Fallback when no thumbnail or error */\n            <div\n              className=\"bg-muted flex items-center justify-center w-full h-full text-gray-400\"\n              data-testid={imageError ? \"album-thumbnail-error\" : \"album-thumbnail-placeholder\"}\n            >\n              <svg\n                className=\"w-12 h-12\"\n                fill=\"currentColor\"\n                viewBox=\"0 0 20 20\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\"\n                  clipRule=\"evenodd\"\n                />\n              </svg>\n            </div>\n          )}\n        </div>", "metadata": {}}
{"id": "214", "text": "{/* Album metadata */}\n        <div className=\"space-y-1\">\n          <h3 className=\"font-semibold text-gray-900 truncate group-hover:text-blue-600 transition-colors\">\n            {album.name}\n          </h3>\n          <p className=\"text-sm text-gray-500\">\n            {album.photoCount.toLocaleString()} {album.photoCount === 1 ? 'photo' : 'photos'}\n          </p>\n          <p className=\"text-xs text-gray-400\">\n            {album.captureDate.toLocaleDateString('en-CA')}\n          </p>\n        </div>", "metadata": {}}
{"id": "215", "text": "{/* Album metadata */}\n        <div className=\"space-y-1\">\n          <h3 className=\"font-semibold text-gray-900 truncate group-hover:text-blue-600 transition-colors\">\n            {album.name}\n          </h3>\n          <p className=\"text-sm text-gray-500\">\n            {album.photoCount.toLocaleString()} {album.photoCount === 1 ? 'photo' : 'photos'}\n          </p>\n          <p className=\"text-xs text-gray-400\">\n            {album.captureDate.toLocaleDateString('en-CA')}\n          </p>\n        </div>\n\n        {/* Optional delete button */}\n        {onDelete && (\n          <button\n            onClick={(e) => {\n              e.stopPropagation()\n              onDelete()\n            }}\n            className=\"absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity bg-red-500 hover:bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs\"\n            aria-label={`Delete album ${album.name}`}\n            tabIndex={-1}\n          >\n            ×\n          </button>\n        )}\n      </CardContent>\n    </Card>\n  )\n}", "metadata": {}}
{"id": "216", "text": "{/* Optional delete button */}\n        {onDelete && (\n          <button\n            onClick={(e) => {\n              e.stopPropagation()\n              onDelete()\n            }}\n            className=\"absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity bg-red-500 hover:bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs\"\n            aria-label={`Delete album ${album.name}`}\n            tabIndex={-1}\n          >\n            ×\n          </button>\n        )}\n      </CardContent>\n    </Card>\n  )\n}\n\nexport default AlbumTile", "metadata": {}}
{"id": "217", "text": "import React, { useEffect, useRef } from 'react';\nimport { Image, User } from '../../types';\nimport { ImageMetadata } from '../ImageMetadata/ImageMetadata';\nimport { useImageDetail, useImageDetailById, useImageFile } from '../../hooks/useImageDetail';\nimport { useFocusTrap, useAriaAnnouncement } from '../../hooks/useFocusTrap';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '../../components/ui/dialog';\nimport { Button } from '../../components/ui/button';\nimport { X, Download, RotateCcw } from 'lucide-react';\n\ninterface ImageDetailModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  image?: Image | null;\n  imageId?: string | null;\n  user?: User | null;\n  className?: string;\n}", "metadata": {}}
{"id": "218", "text": "interface ImageDetailModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  image?: Image | null;\n  imageId?: string | null;\n  user?: User | null;\n  className?: string;\n}\n\nexport function ImageDetailModal({ \n  isOpen, \n  onClose, \n  image: initialImage, \n  imageId,\n  user,\n  className = '' \n}: ImageDetailModalProps) {\n  const { state, setImage, setLoading, setError } = useImageDetail();\n  const { getImageById, isLoading: isLoadingImage } = useImageDetailById();\n  const { getImageFile, isLoading: isLoadingFile, error: fileError } = useImageFile();\n  \n  const [imageUrl, setImageUrl] = useState<string | null>(null);\n  const [rotation, setRotation] = useState(0);\n  const [imageLoadError, setImageLoadError] = useState(false);\n  const modalRef = useFocusTrap(isOpen);\n  const { announce, AnnouncementRegion } = useAriaAnnouncement();", "metadata": {}}
{"id": "219", "text": "useEffect(() => {\n    // Announce when modal opens/closes\\n    if (isOpen) {\\n      announce('Image detail view opened');\\n    }\\n\\n    const loadImageData = async () => {\n      if (!isOpen) return;\n\n      // If we have an image prop, use it directly\n      if (initialImage) {\n        setImage(initialImage);\n        setImageUrl(initialImage.url);\n        setImageLoadError(false);\n        return;\n      }", "metadata": {}}
{"id": "220", "text": "useEffect(() => {\n    // Announce when modal opens/closes\\n    if (isOpen) {\\n      announce('Image detail view opened');\\n    }\\n\\n    const loadImageData = async () => {\n      if (!isOpen) return;\n\n      // If we have an image prop, use it directly\n      if (initialImage) {\n        setImage(initialImage);\n        setImageUrl(initialImage.url);\n        setImageLoadError(false);\n        return;\n      }\n\n      // If we have an imageId, fetch the image data\n      if (imageId) {\n        setLoading(true);\n        try {\n          const imageData = await getImageById(imageId);\n          if (imageData) {\n            setImage(imageData);\n            \n            // Fetch the actual image file\n            const fileUrl = await getImageFile(imageId);\n            setImageLoadError(false);\n            if (fileUrl) {\n              setImageUrl(fileUrl);\n            } else {\n              // Fallback to the URL from image data\n              setImageUrl(imageData.url);\n            }\n          } else {\n            setError('Image not found');\n          }\n        } catch (err) {\n          setError(err instanceof Error ? err.message : 'Failed to load image');\n        }\n        setLoading(false);\n      }\n    };", "metadata": {}}
{"id": "221", "text": "loadImageData();\n  }, [isOpen, initialImage, imageId, getImageById, getImageFile, setImage, setLoading, setError, announce]);\n\n  useEffect(() => {\n    // Cleanup image URL when modal closes or component unmounts\n    return () => {\n      if (imageUrl && imageUrl.startsWith('blob:')) {\n        URL.revokeObjectURL(imageUrl);\n      }\n    };\n  }, [imageUrl]);\n\n  useEffect(() => {\n    const handleEscape = (event: KeyboardEvent) => {\n      if (event.key === 'Escape' && isOpen) {\n        onClose();\n      }\n    };\n\n    const handleClickOutside = (event: MouseEvent) => {\n      if (modalRef.current && !modalRef.current.contains(event.target as Node) && isOpen) {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape);\n      document.addEventListener('mousedown', handleClickOutside);\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [isOpen, onClose]);", "metadata": {}}
{"id": "222", "text": "const handleClickOutside = (event: MouseEvent) => {\n      if (modalRef.current && !modalRef.current.contains(event.target as Node) && isOpen) {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape);\n      document.addEventListener('mousedown', handleClickOutside);\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [isOpen, onClose]);\n\n  const handleDownload = () => {\n    if (imageUrl && state.selectedImage) {\n      const link = document.createElement('a');\n      link.href = imageUrl;\n      link.download = state.selectedImage.filename;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  };\n\n  const handleRotate = () => {\n    setRotation(prev => (prev + 90) % 360);\n    announce(`Image rotated ${(rotation + 90) % 360} degrees`);\n  };", "metadata": {}}
{"id": "223", "text": "const handleDownload = () => {\n    if (imageUrl && state.selectedImage) {\n      const link = document.createElement('a');\n      link.href = imageUrl;\n      link.download = state.selectedImage.filename;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  };\n\n  const handleRotate = () => {\n    setRotation(prev => (prev + 90) % 360);\n    announce(`Image rotated ${(rotation + 90) % 360} degrees`);\n  };\n\n  const isLoading = state.isLoading || isLoadingImage;\n  const isFileLoading = isLoadingFile && !imageLoadError;\n  const error = state.error || fileError;\n\n  if (!isOpen) return null;", "metadata": {}}
{"id": "224", "text": "const handleRotate = () => {\n    setRotation(prev => (prev + 90) % 360);\n    announce(`Image rotated ${(rotation + 90) % 360} degrees`);\n  };\n\n  const isLoading = state.isLoading || isLoadingImage;\n  const isFileLoading = isLoadingFile && !imageLoadError;\n  const error = state.error || fileError;\n\n  if (!isOpen) return null;\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onClose}>\n      <DialogContent\n        ref={modalRef}\n        className={`max-w-7xl w-full max-h-[90vh] p-0 ${className}`}\n        aria-modal=\"true\"\n        role=\"dialog\"\n        aria-labelledby=\"modal-title\"\n      >\n        <DialogHeader className=\"p-6 pb-0\">\n          <DialogTitle \n            id=\"modal-title\" \n            className=\"sr-only\"\n          >\n            Image Detail View\n          </DialogTitle>\n          <div className=\"flex justify-between items-center\">\n            <h2 className=\"text-xl font-semibold\">\n              {state.selectedImage?.", "metadata": {}}
{"id": "225", "text": "selectedImage?.filename || 'Image Details'}\n            </h2>\n            <div className=\"flex gap-2\">\n              <Button \n                variant=\"outline\" \n                size=\"icon\" \n                onClick={handleRotate}\n                aria-label=\"Rotate image\"\n              >\n                <RotateCcw className=\"h-4 w-4\" />\n              </Button>\n              <Button \n                variant=\"outline\" \n                size=\"icon\" \n                onClick={handleDownload}\n                disabled={!state.", "metadata": {}}
{"id": "226", "text": "selectedImage?.filename || 'Image Details'}\n            </h2>\n            <div className=\"flex gap-2\">\n              <Button \n                variant=\"outline\" \n                size=\"icon\" \n                onClick={handleRotate}\n                aria-label=\"Rotate image\"\n              >\n                <RotateCcw className=\"h-4 w-4\" />\n              </Button>\n              <Button \n                variant=\"outline\" \n                size=\"icon\" \n                onClick={handleDownload}\n                disabled={!state.selectedImage || !imageUrl}\n                aria-label=\"Download image\"\n              >\n                <Download className=\"h-4 w-4\" />\n              </Button>\n              <Button \n                variant=\"outline\" \n                size=\"icon\" \n                onClick={onClose}\n                aria-label=\"Close\"\n              >\n                <X className=\"h-4 w-4\" />\n              </Button>\n            </div>\n          </div>\n        </DialogHeader>\n        \n        <div className=\"flex flex-col lg:flex-row h-[calc(90vh-120px)]\">\n          {/* Image Display */}\n          <div className=\"flex-1 flex items-center justify-center bg-black p-2 sm:p-4 overflow-hidden order-1 lg:order-none\">\n            {isLoading ?", "metadata": {}}
{"id": "227", "text": "(\n              <div className=\"text-white\">\n                <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-2\"></div>\n                <p>Loading image...</p>\n              </div>\n            ) : error ? (\n              <div className=\"text-red-500 text-center p-4\">\n                <p className=\"mb-2\">Error loading image</p>\n                <p className=\"text-sm\">{error}</p>\n              </div>\n            ) : imageUrl && state.selectedImage ? (\n              <div className=\"relative max-w-full max-h-full\">\n                {imageLoadError ?", "metadata": {}}
{"id": "228", "text": "(\n              <div className=\"text-red-500 text-center p-4\">\n                <p className=\"mb-2\">Error loading image</p>\n                <p className=\"text-sm\">{error}</p>\n              </div>\n            ) : imageUrl && state.selectedImage ? (\n              <div className=\"relative max-w-full max-h-full\">\n                {imageLoadError ? (\n                  <div className=\"flex flex-col items-center justify-center h-full text-white p-8\">\n                    <div className=\"text-6xl mb-4\">🖼️</div>\n                    <p className=\"text-xl mb-2\">Failed to load image</p>\n                    <p className=\"text-sm text-gray-300 mb-4\">\n                      The image could not be displayed\n                    </p>\n                    <Button\n                      variant=\"outline\"\n                      onClick={() => {\n                        setImageLoadError(false);\n                        // Try to reload by resetting the URL\n                        const tempUrl = imageUrl;\n                        setImageUrl(null);\n                        setTimeout(() => setImageUrl(tempUrl), 100);", "metadata": {}}
{"id": "229", "text": "// Try to reload by resetting the URL\n                        const tempUrl = imageUrl;\n                        setImageUrl(null);\n                        setTimeout(() => setImageUrl(tempUrl), 100);\n                      }}\n                    >\n                      Retry\n                    </Button>\n                  </div>\n                ) : (\n                  <>\n                    <img\n                      src={imageUrl}\n                      alt={state.selectedImage.caption || state.selectedImage.filename}\n                      className=\"max-w-full max-h-full object-contain transition-opacity duration-300\"\n                      style={{ transform: `rotate(${rotation}deg)` }}\n                      draggable={false}\n                      onLoad={() => setImageLoadError(false)}\n                      onError={() => {\n                        setImageLoadError(true);\n                        announce('Failed to load image');\n                      }}\n                    />\n                    <div className=\"absolute bottom-4 left-4 bg-black/50 text-white px-3 py-1 rounded text-sm\">\n                      {state.selectedImage.width && state.selectedImage.height && (\n                        <span>{state.selectedImage.width} × {state.selectedImage.", "metadata": {}}
{"id": "230", "text": "announce('Failed to load image');\n                      }}\n                    />\n                    <div className=\"absolute bottom-4 left-4 bg-black/50 text-white px-3 py-1 rounded text-sm\">\n                      {state.selectedImage.width && state.selectedImage.height && (\n                        <span>{state.selectedImage.width} × {state.selectedImage.height} px</span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            ) : (\n              <div className=\"text-gray-500\">No image selected</div>\n            )}\n          </div>\n          \n          {/* Metadata Panel */}\n          <div className=\"lg:w-96 w-full max-w-full border-t lg:border-t-0 lg:border-l overflow-y-auto order-2 lg:order-none max-h-[50vh] lg:max-h-none\">\n            {state.selectedImage ?", "metadata": {}}
{"id": "231", "text": "height && (\n                        <span>{state.selectedImage.width} × {state.selectedImage.height} px</span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            ) : (\n              <div className=\"text-gray-500\">No image selected</div>\n            )}\n          </div>\n          \n          {/* Metadata Panel */}\n          <div className=\"lg:w-96 w-full max-w-full border-t lg:border-t-0 lg:border-l overflow-y-auto order-2 lg:order-none max-h-[50vh] lg:max-h-none\">\n            {state.selectedImage ? (\n              <div className=\"p-4\">\n                <ImageMetadata \n                  image={state.selectedImage} \n                  user={user} \n                  className=\"border-0 shadow-none\"\n                />\n                \n                {state.selectedImage.caption && (\n                  <div className=\"mt-4 p-4 bg-muted rounded-lg\">\n                    <h3 className=\"font-semibold text-sm mb-2\">Caption</h3>\n                    <p className=\"text-sm\">{state.selectedImage.caption}</p>\n                  </div>\n                )}\n              </div>\n            ) : isLoading ?", "metadata": {}}
{"id": "232", "text": "selectedImage ? (\n              <div className=\"p-4\">\n                <ImageMetadata \n                  image={state.selectedImage} \n                  user={user} \n                  className=\"border-0 shadow-none\"\n                />\n                \n                {state.selectedImage.caption && (\n                  <div className=\"mt-4 p-4 bg-muted rounded-lg\">\n                    <h3 className=\"font-semibold text-sm mb-2\">Caption</h3>\n                    <p className=\"text-sm\">{state.selectedImage.caption}</p>\n                  </div>\n                )}\n              </div>\n            ) : isLoading ? (\n              <div className=\"p-4\">\n                <div className=\"animate-pulse space-y-4\">\n                  <div className=\"h-4 bg-gray-200 rounded w-3/4\"></div>\n                  <div className=\"h-4 bg-gray-200 rounded w-1/2\"></div>\n                  <div className=\"h-4 bg-gray-200 rounded w-5/6\"></div>\n                </div>\n              </div>\n            ) : (\n              <div className=\"p-4 text-center text-muted-foreground\">\n                No image data available\n              </div>\n            )}\n          </div>\n        </div>\n      </DialogContent>\n    </Dialog>", "metadata": {}}
{"id": "233", "text": "<AnnouncementRegion />\n  );\n}\n\n// Export a default version for easier importing\nexport default ImageDetailModal;", "metadata": {}}
{"id": "234", "text": "import React from 'react';\nimport { Image } from '../../types/image';\nimport { useImageDetail } from '../../hooks/useImageDetail';\nimport { Card, CardContent } from '../../components/ui/card';\nimport { ImageMetadataCompact } from '../ImageMetadata/ImageMetadata';\n\ninterface ImageGalleryProps {\n  images: Image[];\n  loading?: boolean;\n  error?: string | null;\n  className?: string;\n  onImageClick?: (image: Image) => void;\n}\n\nexport function ImageGallery({ \n  images, \n  loading = false, \n  error = null,\n  className = '',\n  onImageClick\n}: ImageGalleryProps) {\n  const { openDetail } = useImageDetail();\n\n  const handleImageClick = (image: Image) => {\n    if (onImageClick) {\n      onImageClick(image);\n    } else {\n      // Default behavior: open detail view with image ID\n      openDetail(image.id);\n    }\n  };", "metadata": {}}
{"id": "235", "text": "export function ImageGallery({ \n  images, \n  loading = false, \n  error = null,\n  className = '',\n  onImageClick\n}: ImageGalleryProps) {\n  const { openDetail } = useImageDetail();\n\n  const handleImageClick = (image: Image) => {\n    if (onImageClick) {\n      onImageClick(image);\n    } else {\n      // Default behavior: open detail view with image ID\n      openDetail(image.id);\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className={`grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 ${className}`}>\n        {Array.from({ length: 8 }).map((_, index) => (\n          <Card key={index} className=\"aspect-square\">\n            <CardContent className=\"p-0 h-full\">\n              <div className=\"animate-pulse bg-gray-200 w-full h-full rounded-lg\"></div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n    );\n  }", "metadata": {}}
{"id": "236", "text": "if (loading) {\n    return (\n      <div className={`grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 ${className}`}>\n        {Array.from({ length: 8 }).map((_, index) => (\n          <Card key={index} className=\"aspect-square\">\n            <CardContent className=\"p-0 h-full\">\n              <div className=\"animate-pulse bg-gray-200 w-full h-full rounded-lg\"></div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className={`text-center p-8 ${className}`}>\n        <p className=\"text-red-500 mb-2\">Error loading images</p>\n        <p className=\"text-sm text-muted-foreground\">{error}</p>\n      </div>\n    );\n  }", "metadata": {}}
{"id": "237", "text": "if (error) {\n    return (\n      <div className={`text-center p-8 ${className}`}>\n        <p className=\"text-red-500 mb-2\">Error loading images</p>\n        <p className=\"text-sm text-muted-foreground\">{error}</p>\n      </div>\n    );\n  }\n\n  if (images.length === 0) {\n    return (\n      <div className={`text-center p-8 ${className}`}>\n        <p className=\"text-muted-foreground\">No images found</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`gallery-container ${className}`}>\n      <div className=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4\">\n        {images.map((image) => (\n          <Card \n            key={image.id} \n            className=\"group cursor-pointer overflow-hidden hover:shadow-lg transition-all duration-200\"\n            onClick={() => handleImageClick(image)}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => {\n              if (e.", "metadata": {}}
{"id": "238", "text": "return (\n    <div className={`gallery-container ${className}`}>\n      <div className=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4\">\n        {images.map((image) => (\n          <Card \n            key={image.id} \n            className=\"group cursor-pointer overflow-hidden hover:shadow-lg transition-all duration-200\"\n            onClick={() => handleImageClick(image)}\n            role=\"button\"\n            tabIndex={0}\n            onKeyDown={(e) => {\n              if (e.key === 'Enter' || e.key === ' ') {\n                e.preventDefault();\n                handleImageClick(image);\n              }\n            }}\n            aria-label={`View ${image.caption || image.filename}`}\n          >\n            <CardContent className=\"p-0 relative h-48\">\n              {/* Image Thumbnail */}\n              <img\n                src={image.url}\n                alt={image.caption || image.", "metadata": {}}
{"id": "239", "text": "key === 'Enter' || e.key === ' ') {\n                e.preventDefault();\n                handleImageClick(image);\n              }\n            }}\n            aria-label={`View ${image.caption || image.filename}`}\n          >\n            <CardContent className=\"p-0 relative h-48\">\n              {/* Image Thumbnail */}\n              <img\n                src={image.url}\n                alt={image.caption || image.filename}\n                className=\"w-full h-full object-cover\"\n                loading=\"lazy\"\n              />\n              \n              {/* Hover Overlay */}\n              <div className=\"absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center\">\n                <div className=\"text-white text-center p-4\">\n                  <p className=\"font-medium truncate\">\n                    {image.caption || image.filename}\n                  </p>\n                  <ImageMetadataCompact image={image} className=\"text-white/80 mt-2\" />\n                </div>\n              </div>\n              \n              {/* Image Badge */}\n              {image.tags.", "metadata": {}}
{"id": "240", "text": "caption || image.filename}\n                  </p>\n                  <ImageMetadataCompact image={image} className=\"text-white/80 mt-2\" />\n                </div>\n              </div>\n              \n              {/* Image Badge */}\n              {image.tags.length > 0 && (\n                <div className=\"absolute top-2 right-2\">\n                  <span className=\"bg-black/70 text-white text-xs px-2 py-1 rounded\">\n                    {image.tags.length} {image.tags.length === 1 ? 'tag' : 'tags'}\n                  </span>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// Export a memoized version for performance\nexport const MemoizedImageGallery = React.memo(ImageGallery);\n\n// Gallery with additional features\ninterface EnhancedGalleryProps extends ImageGalleryProps {\n  selectable?: boolean;\n  selectedImages?: Set<string>;\n  onSelectionChange?: (selectedIds: Set<string>) => void;\n}", "metadata": {}}
{"id": "241", "text": "tags.length} {image.tags.length === 1 ? 'tag' : 'tags'}\n                  </span>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// Export a memoized version for performance\nexport const MemoizedImageGallery = React.memo(ImageGallery);\n\n// Gallery with additional features\ninterface EnhancedGalleryProps extends ImageGalleryProps {\n  selectable?: boolean;\n  selectedImages?: Set<string>;\n  onSelectionChange?: (selectedIds: Set<string>) => void;\n}\n\nexport function EnhancedGallery({\n  images,\n  selectable = false,\n  selectedImages = new Set(),\n  onSelectionChange,\n  ...props\n}: EnhancedGalleryProps) {\n  const handleImageClick = (image: Image) => {\n    if (selectable) {\n      const newSelected = new Set(selectedImages);\n      if (newSelected.has(image.id)) {\n        newSelected.delete(image.id);\n      } else {\n        newSelected.add(image.id);\n      }\n      onSelectionChange?.(newSelected);\n    } else {\n      props.onImageClick?.(image);\n    }\n  };", "metadata": {}}
{"id": "242", "text": "export function EnhancedGallery({\n  images,\n  selectable = false,\n  selectedImages = new Set(),\n  onSelectionChange,\n  ...props\n}: EnhancedGalleryProps) {\n  const handleImageClick = (image: Image) => {\n    if (selectable) {\n      const newSelected = new Set(selectedImages);\n      if (newSelected.has(image.id)) {\n        newSelected.delete(image.id);\n      } else {\n        newSelected.add(image.id);\n      }\n      onSelectionChange?.(newSelected);\n    } else {\n      props.onImageClick?.(image);\n    }\n  };\n\n  return (\n    <ImageGallery\n      {...props}\n      images={images}\n      onImageClick={handleImageClick}\n    />\n  );\n}", "metadata": {}}
{"id": "243", "text": "import React from 'react';\nimport { Image, User } from '../../types';\nimport { Card, CardContent, CardHeader, CardTitle } from '../../components/ui/card';\nimport { Badge } from '../../components/ui/badge';\n\ninterface ImageMetadataProps {\n  image: Image;\n  user?: User | null;\n  className?: string;\n}\n\nexport function ImageMetadata({ image, user, className = '' }: ImageMetadataProps) {\n  const formatFileSize = (bytes: number): string => {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };", "metadata": {}}
{"id": "244", "text": "export function ImageMetadata({ image, user, className = '' }: ImageMetadataProps) {\n  const formatFileSize = (bytes: number): string => {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  const formatDate = (date: Date | string): string => {\n    const d = typeof date === 'string' ? new Date(date) : date;\n    return d.toLocaleDateString(undefined, {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  };", "metadata": {}}
{"id": "245", "text": "const formatDate = (date: Date | string): string => {\n    const d = typeof date === 'string' ? new Date(date) : date;\n    return d.toLocaleDateString(undefined, {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  };\n\n  const formatDimensions = (width?: number, height?: number): string => {\n    if (!width || !height) return 'Unknown';\n    return `${width.toLocaleString()} × ${height.toLocaleString()} px`;\n  };\n\n  return (\n    <Card className={`w-full ${className}`}>\n      <CardHeader>\n        <CardTitle className=\"text-lg\">Image Details</CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div>\n          <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Filename</h3>\n          <p className=\"text-sm font-mono break-all\">{image.filename}</p>\n        </div>", "metadata": {}}
{"id": "246", "text": "return (\n    <Card className={`w-full ${className}`}>\n      <CardHeader>\n        <CardTitle className=\"text-lg\">Image Details</CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div>\n          <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Filename</h3>\n          <p className=\"text-sm font-mono break-all\">{image.filename}</p>\n        </div>\n\n        {image.caption && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Caption</h3>\n            <p className=\"text-sm\">{image.caption}</p>\n          </div>\n        )}", "metadata": {}}
{"id": "247", "text": "{image.caption && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Caption</h3>\n            <p className=\"text-sm\">{image.caption}</p>\n          </div>\n        )}\n\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">File Size</h3>\n            <p className=\"text-sm\">{formatFileSize(image.fileSize)}</p>\n          </div>\n          \n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">File Type</h3>\n            <p className=\"text-sm\">{image.mimeType.split('/')[1]?.toUpperCase() || image.mimeType}</p>\n          </div>\n        </div>\n\n        <div>\n          <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Dimensions</h3>\n          <p className=\"text-sm\">{formatDimensions(image.width, image.height)}</p>\n        </div>", "metadata": {}}
{"id": "248", "text": "<div>\n          <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Dimensions</h3>\n          <p className=\"text-sm\">{formatDimensions(image.width, image.height)}</p>\n        </div>\n\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Uploaded</h3>\n            <p className=\"text-sm\">{formatDate(image.uploadedAt)}</p>\n          </div>\n          \n          {image.capturedAt && (\n            <div>\n              <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Captured</h3>\n              <p className=\"text-sm\">{formatDate(image.capturedAt)}</p>\n            </div>\n          )}\n        </div>", "metadata": {}}
{"id": "249", "text": "<div className=\"grid grid-cols-2 gap-4\">\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Uploaded</h3>\n            <p className=\"text-sm\">{formatDate(image.uploadedAt)}</p>\n          </div>\n          \n          {image.capturedAt && (\n            <div>\n              <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Captured</h3>\n              <p className=\"text-sm\">{formatDate(image.capturedAt)}</p>\n            </div>\n          )}\n        </div>\n\n        {user && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Uploaded By</h3>\n            <div className=\"flex items-center gap-2\">\n              {user.avatarUrl && (\n                <img \n                  src={user.avatarUrl} \n                  alt={user.displayName || user.username}\n                  className=\"w-6 h-6 rounded-full\"\n                />\n              )}\n              <p className=\"text-sm\">\n                {user.displayName || user.username}\n              </p>\n            </div>\n          </div>\n        )}", "metadata": {}}
{"id": "250", "text": "{user && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Uploaded By</h3>\n            <div className=\"flex items-center gap-2\">\n              {user.avatarUrl && (\n                <img \n                  src={user.avatarUrl} \n                  alt={user.displayName || user.username}\n                  className=\"w-6 h-6 rounded-full\"\n                />\n              )}\n              <p className=\"text-sm\">\n                {user.displayName || user.username}\n              </p>\n            </div>\n          </div>\n        )}\n\n        {image.cameraModel && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Camera</h3>\n            <p className=\"text-sm\">{image.cameraModel}</p>\n          </div>\n        )}\n\n        {image.location && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Location</h3>\n            <p className=\"text-sm\">{image.location}</p>\n          </div>\n        )}", "metadata": {}}
{"id": "251", "text": "{image.cameraModel && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Camera</h3>\n            <p className=\"text-sm\">{image.cameraModel}</p>\n          </div>\n        )}\n\n        {image.location && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-1\">Location</h3>\n            <p className=\"text-sm\">{image.location}</p>\n          </div>\n        )}\n\n        {image.tags.length > 0 && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-2\">Tags</h3>\n            <div className=\"flex flex-wrap gap-1\">\n              {image.tags.map((tag, index) => (\n                <Badge key={index} variant=\"secondary\" className=\"text-xs\">\n                  {tag}\n                </Badge>\n              ))}\n            </div>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n}", "metadata": {}}
{"id": "252", "text": "{image.tags.length > 0 && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-2\">Tags</h3>\n            <div className=\"flex flex-wrap gap-1\">\n              {image.tags.map((tag, index) => (\n                <Badge key={index} variant=\"secondary\" className=\"text-xs\">\n                  {tag}\n                </Badge>\n              ))}\n            </div>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n\ninterface ImageMetadataCompactProps {\n  image: Image;\n  className?: string;\n}", "metadata": {}}
{"id": "253", "text": "{image.tags.length > 0 && (\n          <div>\n            <h3 className=\"font-semibold text-sm text-muted-foreground mb-2\">Tags</h3>\n            <div className=\"flex flex-wrap gap-1\">\n              {image.tags.map((tag, index) => (\n                <Badge key={index} variant=\"secondary\" className=\"text-xs\">\n                  {tag}\n                </Badge>\n              ))}\n            </div>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n\ninterface ImageMetadataCompactProps {\n  image: Image;\n  className?: string;\n}\n\nexport function ImageMetadataCompact({ image, className = '' }: ImageMetadataCompactProps) {\n  const formatFileSize = (bytes: number): string => {\n    if (bytes === 0) return '0 B';\n    \n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];\n  };", "metadata": {}}
{"id": "254", "text": "export function ImageMetadataCompact({ image, className = '' }: ImageMetadataCompactProps) {\n  const formatFileSize = (bytes: number): string => {\n    if (bytes === 0) return '0 B';\n    \n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];\n  };\n\n  return (\n    <div className={`text-xs text-muted-foreground space-y-1 ${className}`}>\n      <div className=\"flex items-center gap-2\">\n        <span>{formatFileSize(image.fileSize)}</span>\n        {image.width && image.height && (\n          <span>•</span>\n        )}\n        {image.width && image.height && (\n          <span>{image.width}×{image.height}</span>\n        )}\n      </div>\n      \n      {image.capturedAt && (\n        <div>\n          Captured: {new Date(image.capturedAt).toLocaleDateString()}\n        </div>\n      )}\n    </div>\n  );\n}", "metadata": {}}
{"id": "255", "text": "import { ArrowLeft, Upload, Settings } from 'lucide-react'\nimport { NavigationProps } from '../../types'\n\ninterface ExtendedNavigationProps extends NavigationProps {\n  onUploadClick?: () => void\n  onSettingsClick?: () => void\n}\n\nconst Navigation = ({\n  currentView,\n  albumName,\n  onBackToAlbums,\n  onExportAlbum,\n  onUploadClick,\n  onSettingsClick,\n  canExport = false,\n  className = ''\n}: ExtendedNavigationProps) => {\n  return (\n    <nav className={className} role=\"navigation\" aria-label=\"Main navigation\">\n      {currentView === 'photos' && (\n        <button\n          onClick={onBackToAlbums}\n          className=\"flex items-center space-x-2 px-3 py-2 rounded-md text-gray-700 hover:text-gray-900 hover:bg-gray-100 transition-colors\"\n          aria-label=\"Back to albums\"\n        >\n          <ArrowLeft size={20} />\n          <span>Albums</span>\n        </button>\n      )}", "metadata": {}}
{"id": "256", "text": "{currentView === 'photos' && albumName && (\n        <span className=\"text-lg font-medium text-gray-900\" aria-label={`Current album: ${albumName}`}>\n          {albumName}\n        </span>\n      )}\n\n      {currentView === 'photos' && canExport && onExportAlbum && (\n        <button\n          onClick={onExportAlbum}\n          className=\"px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors\"\n          aria-label=\"Export album as ZIP\"\n        >\n          Export ZIP\n        </button>\n      )}\n\n      <div className=\"flex items-center space-x-2\">\n        <button\n          onClick={onUploadClick}\n          className=\"flex items-center space-x-2 px-3 py-2 rounded-md text-gray-700 hover:text-gray-900 hover:bg-gray-100 transition-colors\"\n          aria-label=\"Upload photos\"\n        >\n          <Upload size={20} />\n          <span className=\"hidden sm:inline\">Upload</span>\n        </button>", "metadata": {}}
{"id": "257", "text": "<div className=\"flex items-center space-x-2\">\n        <button\n          onClick={onUploadClick}\n          className=\"flex items-center space-x-2 px-3 py-2 rounded-md text-gray-700 hover:text-gray-900 hover:bg-gray-100 transition-colors\"\n          aria-label=\"Upload photos\"\n        >\n          <Upload size={20} />\n          <span className=\"hidden sm:inline\">Upload</span>\n        </button>\n\n        <button\n          onClick={onSettingsClick}\n          className=\"flex items-center space-x-2 px-3 py-2 rounded-md text-gray-700 hover:text-gray-900 hover:bg-gray-100 transition-colors\"\n          aria-label=\"Settings\"\n        >\n          <Settings size={20} />\n          <span className=\"hidden sm:inline\">Settings</span>\n        </button>\n      </div>\n    </nav>\n  )\n}\n\nexport default Navigation", "metadata": {}}
{"id": "258", "text": "import { ReactNode } from 'react'\nimport { ViewState } from '../../types'\nimport Navigation from './Navigation'\n\ninterface LayoutProps {\n  children: ReactNode\n  viewState: ViewState\n  onBackToAlbums: () => void\n}", "metadata": {}}
{"id": "259", "text": "import { ReactNode } from 'react'\nimport { ViewState } from '../../types'\nimport Navigation from './Navigation'\n\ninterface LayoutProps {\n  children: ReactNode\n  viewState: ViewState\n  onBackToAlbums: () => void\n}\n\nconst Layout = ({ children, viewState, onBackToAlbums }: LayoutProps) => {\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <header className=\"bg-white border-b border-gray-200 sticky top-0 z-10\">\n        <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n          <div className=\"flex justify-between items-center h-16\">\n            <div className=\"flex items-center\">\n              <h1 className=\"text-2xl font-bold text-gray-900\">\n                My Photo App\n              </h1>\n            </div>\n            <Navigation\n              currentView={viewState.currentView}\n              onBackToAlbums={onBackToAlbums}\n              className=\"flex items-center space-x-4\"\n            />\n          </div>\n        </div>\n      </header>\n      <main className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\">\n        {children}\n      </main>\n    </div>\n  )\n}", "metadata": {}}
{"id": "260", "text": "export default Layout", "metadata": {}}
{"id": "261", "text": "/**\n * Lazy-loaded components for code splitting\n * Provides optimized loading of heavy components\n */\n\nimport { lazy, ComponentType, Suspense } from 'react'\nimport { Skeleton } from './ui/skeleton'\n\n// Lazy loading wrapper with custom loading component\nfunction withLazyLoading<P extends object>(\n  importFunc: () => Promise<{ default: ComponentType<P> }>,\n  fallback?: React.ComponentType,\n  displayName?: string\n) {\n  const LazyComponent = lazy(importFunc)\n\n  const WrappedComponent = (props: P) => {\n    const FallbackComponent = fallback || DefaultLoadingComponent\n\n    return (\n      <Suspense fallback={<FallbackComponent />}>\n        <LazyComponent {...props} />\n      </Suspense>\n    )\n  }\n\n  WrappedComponent.displayName = displayName || 'LazyComponent'\n\n  return WrappedComponent\n}\n\n// Default loading component\nconst DefaultLoadingComponent = () => (\n  <div className=\"w-full h-64 flex items-center justify-center\">\n    <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500\" />\n  </div>\n)", "metadata": {}}
{"id": "262", "text": "return (\n      <Suspense fallback={<FallbackComponent />}>\n        <LazyComponent {...props} />\n      </Suspense>\n    )\n  }\n\n  WrappedComponent.displayName = displayName || 'LazyComponent'\n\n  return WrappedComponent\n}\n\n// Default loading component\nconst DefaultLoadingComponent = () => (\n  <div className=\"w-full h-64 flex items-center justify-center\">\n    <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500\" />\n  </div>\n)\n\n// Loading component for album grids\nconst AlbumGridLoader = () => (\n  <div className=\"grid gap-6 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 auto-rows-max\">\n    {Array.from({ length: 6 }).map((_, index) => (\n      <div\n        key={`skeleton-${index}`}\n        className=\"bg-card rounded-lg shadow-sm overflow-hidden border\"\n        aria-hidden=\"true\"\n      >\n        <Skeleton className=\"aspect-square\" />\n        <div className=\"p-4 space-y-2\">\n          <Skeleton className=\"h-5 w-3/4\" />\n          <Skeleton className=\"h-4 w-1/2\" />\n          <Skeleton className=\"h-3 w-1/3\" />\n        </div>\n      </div>\n    ))}\n  </div>\n)", "metadata": {}}
{"id": "263", "text": "// Loading component for photo grids\nconst PhotoGridLoader = () => (\n  <div className=\"grid gap-4 grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5\">\n    {Array.from({ length: 20 }).map((_, index) => (\n      <div key={`photo-skeleton-${index}`} className=\"aspect-square\">\n        <Skeleton className=\"w-full h-full rounded-md\" />\n      </div>\n    ))}\n  </div>\n)\n\n// Loading component for modals\nconst ModalLoader = () => (\n  <div className=\"fixed inset-0 bg-black/80 flex items-center justify-center z-50\">\n    <div className=\"bg-white rounded-lg p-6 max-w-lg w-full mx-4\">\n      <Skeleton className=\"h-64 w-full mb-4\" />\n      <Skeleton className=\"h-6 w-3/4 mb-2\" />\n      <Skeleton className=\"h-4 w-1/2\" />\n    </div>\n  </div>\n)", "metadata": {}}
{"id": "264", "text": "// Loading component for modals\nconst ModalLoader = () => (\n  <div className=\"fixed inset-0 bg-black/80 flex items-center justify-center z-50\">\n    <div className=\"bg-white rounded-lg p-6 max-w-lg w-full mx-4\">\n      <Skeleton className=\"h-64 w-full mb-4\" />\n      <Skeleton className=\"h-6 w-3/4 mb-2\" />\n      <Skeleton className=\"h-4 w-1/2\" />\n    </div>\n  </div>\n)\n\n// Lazy-loaded components\nexport const LazyVirtualizedAlbumGrid = withLazyLoading(\n  () => import('./AlbumGrid/VirtualizedAlbumGrid'),\n  AlbumGridLoader,\n  'LazyVirtualizedAlbumGrid'\n)\n\nexport const LazyZoomModal = withLazyLoading(\n  () => import('./ZoomModal'),\n  ModalLoader,\n  'LazyZoomModal'\n)\n\nexport const LazyPhotoTileView = withLazyLoading(\n  () => import('./PhotoTileView'),\n  PhotoGridLoader,\n  'LazyPhotoTileView'\n)", "metadata": {}}
{"id": "265", "text": "// Lazy-loaded components\nexport const LazyVirtualizedAlbumGrid = withLazyLoading(\n  () => import('./AlbumGrid/VirtualizedAlbumGrid'),\n  AlbumGridLoader,\n  'LazyVirtualizedAlbumGrid'\n)\n\nexport const LazyZoomModal = withLazyLoading(\n  () => import('./ZoomModal'),\n  ModalLoader,\n  'LazyZoomModal'\n)\n\nexport const LazyPhotoTileView = withLazyLoading(\n  () => import('./PhotoTileView'),\n  PhotoGridLoader,\n  'LazyPhotoTileView'\n)\n\nexport const LazyUploadDropzone = withLazyLoading(\n  () => import('./UploadDropzone'),\n  DefaultLoadingComponent,\n  'LazyUploadDropzone'\n)\n\n// Higher-order component for lazy loading with error boundaries\nexport function withErrorBoundary<P extends object>(\n  Component: ComponentType<P>\n) {\n  return class extends React.Component<P, { hasError: boolean }> {\n    constructor(props: P) {\n      super(props)\n      this.state = { hasError: false }\n    }\n\n    static getDerivedStateFromError() {\n      return { hasError: true }\n    }", "metadata": {}}
{"id": "266", "text": "export const LazyUploadDropzone = withLazyLoading(\n  () => import('./UploadDropzone'),\n  DefaultLoadingComponent,\n  'LazyUploadDropzone'\n)\n\n// Higher-order component for lazy loading with error boundaries\nexport function withErrorBoundary<P extends object>(\n  Component: ComponentType<P>\n) {\n  return class extends React.Component<P, { hasError: boolean }> {\n    constructor(props: P) {\n      super(props)\n      this.state = { hasError: false }\n    }\n\n    static getDerivedStateFromError() {\n      return { hasError: true }\n    }\n\n    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n      console.error('Lazy component loading error:', error, errorInfo)\n    }\n\n    render() {\n      if (this.state.", "metadata": {}}
{"id": "267", "text": "static getDerivedStateFromError() {\n      return { hasError: true }\n    }\n\n    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n      console.error('Lazy component loading error:', error, errorInfo)\n    }\n\n    render() {\n      if (this.state.hasError) {\n        return (\n          <div className=\"w-full h-64 flex items-center justify-center bg-gray-50 rounded-lg\">\n            <div className=\"text-center\">\n              <div className=\"text-gray-400 mb-2\">\n                <svg className=\"w-12 h-12 mx-auto\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.", "metadata": {}}
{"id": "268", "text": "01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-lg font-medium text-gray-900 mb-1\">Component Loading Error</h3>\n              <p className=\"text-gray-500 text-sm\">Please refresh the page to try again</p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"mt-2 px-4 py-2 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 transition-colors\"\n              >\n                Refresh Page\n              </button>\n            </div>\n          </div>\n        )\n      }\n\n      return <Component {...this.props} />\n    }\n  }\n}", "metadata": {}}
{"id": "269", "text": "location.reload()}\n                className=\"mt-2 px-4 py-2 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 transition-colors\"\n              >\n                Refresh Page\n              </button>\n            </div>\n          </div>\n        )\n      }\n\n      return <Component {...this.props} />\n    }\n  }\n}\n\n// Performance monitoring for lazy components\nexport function withPerformanceTracking<P extends object>(\n  Component: ComponentType<P>,\n  componentName: string\n) {\n  return (props: P) => {\n    React.useEffect(() => {\n      const startTime = performance.now()\n\n      return () => {\n        const endTime = performance.now()\n        const loadTime = endTime - startTime\n\n        if (process.env.NODE_ENV === 'development') {\n          console.log(`🚀 ${componentName} loaded in ${loadTime.toFixed(2)}ms`)\n        }", "metadata": {}}
{"id": "270", "text": "return <Component {...this.props} />\n    }\n  }\n}\n\n// Performance monitoring for lazy components\nexport function withPerformanceTracking<P extends object>(\n  Component: ComponentType<P>,\n  componentName: string\n) {\n  return (props: P) => {\n    React.useEffect(() => {\n      const startTime = performance.now()\n\n      return () => {\n        const endTime = performance.now()\n        const loadTime = endTime - startTime\n\n        if (process.env.NODE_ENV === 'development') {\n          console.log(`🚀 ${componentName} loaded in ${loadTime.toFixed(2)}ms`)\n        }\n\n        // Report to performance monitor if available\n        if (window.performance && window.performance.measure) {\n          try {\n            window.performance.measure(`${componentName}-load`, {\n              start: startTime,\n              end: endTime\n            })\n          } catch (error) {\n            // Silently ignore performance API errors\n          }\n        }\n      }\n    }, [])\n\n    return <Component {...props} />\n  }\n}", "metadata": {}}
{"id": "271", "text": "if (process.env.NODE_ENV === 'development') {\n          console.log(`🚀 ${componentName} loaded in ${loadTime.toFixed(2)}ms`)\n        }\n\n        // Report to performance monitor if available\n        if (window.performance && window.performance.measure) {\n          try {\n            window.performance.measure(`${componentName}-load`, {\n              start: startTime,\n              end: endTime\n            })\n          } catch (error) {\n            // Silently ignore performance API errors\n          }\n        }\n      }\n    }, [])\n\n    return <Component {...props} />\n  }\n}\n\n// Combined HOC for lazy loading with error boundary and performance tracking\nexport function createOptimizedLazyComponent<P extends object>(\n  importFunc: () => Promise<{ default: ComponentType<P> }>,\n  options: {\n    fallback?: React.ComponentType\n    displayName?: string\n    withErrorBoundary?: boolean\n    withPerformanceTracking?: boolean\n  } = {}\n) {\n  const {\n    fallback = DefaultLoadingComponent,\n    displayName = 'OptimizedLazyComponent',\n    withErrorBoundary: enableErrorBoundary = true,\n    withPerformanceTracking: enablePerformanceTracking = process.env.NODE_ENV === 'development'\n  } = options", "metadata": {}}
{"id": "272", "text": "let Component = withLazyLoading(importFunc, fallback, displayName)\n\n  if (enableErrorBoundary) {\n    Component = withErrorBoundary(Component) as any\n  }\n\n  if (enablePerformanceTracking) {\n    Component = withPerformanceTracking(Component, displayName) as any\n  }\n\n  return Component\n}", "metadata": {}}
{"id": "273", "text": "import { PhotoTileViewProps } from '../../types'\n\nconst PhotoTileView = ({\n  photos,\n  onPhotoClick,\n  loading = false,\n  selectedPhotoId,\n  className = '',\n  ...props\n}: PhotoTileViewProps) => {\n  if (loading) {\n    return (\n      <div\n        className={`responsive-grid photo-grid ${className}`}\n        role=\"region\"\n        aria-label=\"Loading photos\"\n        aria-live=\"polite\"\n        {...props}\n      >\n        {/* Loading skeleton */}\n        {Array.from({ length: 12 }).map((_, index) => (\n          <div\n            key={`skeleton-${index}`}\n            className=\"bg-white rounded-lg shadow-md overflow-hidden\"\n            aria-hidden=\"true\"\n          >\n            <div className=\"aspect-square skeleton\" />\n          </div>\n        ))}\n        <div className=\"sr-only\">Loading photos for this album...</div>\n      </div>\n    )\n  }", "metadata": {}}
{"id": "274", "text": "return (\n    <div\n      className={`responsive-grid photo-grid ${className}`}\n      role=\"grid\"\n      aria-label={`Photo grid containing ${photos.length} photos`}\n      {...props}\n    >\n      {photos.map((photo, index) => (\n        <div\n          key={photo.id}\n          onClick={() => onPhotoClick(photo.id)}\n          className={`bg-white rounded-lg shadow-md overflow-hidden grid-item-interactive cursor-pointer ${\n            selectedPhotoId === photo.id ?", "metadata": {}}
{"id": "275", "text": "return (\n    <div\n      className={`responsive-grid photo-grid ${className}`}\n      role=\"grid\"\n      aria-label={`Photo grid containing ${photos.length} photos`}\n      {...props}\n    >\n      {photos.map((photo, index) => (\n        <div\n          key={photo.id}\n          onClick={() => onPhotoClick(photo.id)}\n          className={`bg-white rounded-lg shadow-md overflow-hidden grid-item-interactive cursor-pointer ${\n            selectedPhotoId === photo.id ? 'ring-2 ring-blue-500' : ''\n          }`}\n          tabIndex={0}\n          role=\"button\"\n          aria-label={`View photo ${photo.filename}`}\n          aria-setsize={photos.length}\n          aria-posinset={index + 1}\n          data-testid={`photo-tile-${photo.id}`}\n          onKeyDown={(e) => {\n            if (e.key === 'Enter' || e.key === ' ') {\n              e.preventDefault()\n              onPhotoClick(photo.id)\n            }\n          }}\n        >\n          <div className=\"aspect-square bg-gray-100\">\n            {/* Placeholder for photo thumbnail */}\n            <div className=\"w-full h-full flex items-center justify-center text-gray-400 text-xs p-2 text-center\">\n              {photo.filename}\n            </div>\n          </div>\n        </div>\n      ))}\n    </div>\n  )\n}", "metadata": {}}
{"id": "276", "text": "export default PhotoTileView", "metadata": {}}
{"id": "277", "text": "import { useRef, useState } from 'react'\nimport { Upload } from 'lucide-react'\nimport { UploadDropzoneProps } from '../../types'\n\nconst UploadDropzone = ({\n  onFilesSelected,\n  acceptedFileTypes = ['.jpg', '.jpeg', '.png', '.webp', '.heic'],\n  maxFileSize = 10 * 1024 * 1024, // 10MB\n  isUploading = false,\n  className = '',\n  ...props\n}: UploadDropzoneProps) => {\n  const [isDragOver, setIsDragOver] = useState(false)\n  const fileInputRef = useRef<HTMLInputElement>(null)\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault()\n    setIsDragOver(true)\n  }\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault()\n    setIsDragOver(false)\n  }\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault()\n    setIsDragOver(false)", "metadata": {}}
{"id": "278", "text": "const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault()\n    setIsDragOver(true)\n  }\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault()\n    setIsDragOver(false)\n  }\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault()\n    setIsDragOver(false)\n\n    const files = e.dataTransfer.files\n    if (files.length > 0) {\n      onFilesSelected(files)\n    }\n  }\n\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const files = e.target.files\n    if (files && files.length > 0) {\n      onFilesSelected(files)\n    }\n  }\n\n  const handleClick = () => {\n    if (!isUploading) {\n      fileInputRef.current?.click()\n    }\n  }", "metadata": {}}
{"id": "279", "text": "const files = e.dataTransfer.files\n    if (files.length > 0) {\n      onFilesSelected(files)\n    }\n  }\n\n  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const files = e.target.files\n    if (files && files.length > 0) {\n      onFilesSelected(files)\n    }\n  }\n\n  const handleClick = () => {\n    if (!isUploading) {\n      fileInputRef.current?.click()\n    }\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if ((e.key === 'Enter' || e.key === ' ') && !isUploading) {\n      e.preventDefault()\n      fileInputRef.current?.click()\n    }\n  }\n\n  return (\n    <div\n      className={`\n        border-2 border-dashed rounded-lg p-8 text-center transition-colors cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\n        ${isDragOver\n          ?", "metadata": {}}
{"id": "280", "text": "const handleKeyDown = (e: React.KeyboardEvent) => {\n    if ((e.key === 'Enter' || e.key === ' ') && !isUploading) {\n      e.preventDefault()\n      fileInputRef.current?.click()\n    }\n  }\n\n  return (\n    <div\n      className={`\n        border-2 border-dashed rounded-lg p-8 text-center transition-colors cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\n        ${isDragOver\n          ? 'border-blue-500 bg-blue-50'\n          : 'border-gray-300 bg-gray-50 hover:border-gray-400 hover:bg-gray-100'\n        }\n        ${isUploading ? 'pointer-events-none opacity-50' : ''}\n        ${className}\n      `}\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n      onClick={handleClick}\n      onKeyDown={handleKeyDown}\n      tabIndex={isUploading ?", "metadata": {}}
{"id": "281", "text": "'border-blue-500 bg-blue-50'\n          : 'border-gray-300 bg-gray-50 hover:border-gray-400 hover:bg-gray-100'\n        }\n        ${isUploading ? 'pointer-events-none opacity-50' : ''}\n        ${className}\n      `}\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n      onClick={handleClick}\n      onKeyDown={handleKeyDown}\n      tabIndex={isUploading ? -1 : 0}\n      role=\"button\"\n      aria-label={isUploading ? \"Upload in progress\" : \"Click to select photos or drag and drop photos here\"}\n      aria-describedby=\"upload-dropzone-description\"\n      aria-live={isUploading ? \"polite\" : \"off\"}\n      {...props}\n    >\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        multiple\n        accept={acceptedFileTypes.join(',')}\n        onChange={handleFileSelect}\n        className=\"hidden\"\n        aria-label=\"Select photos to upload\"\n      />", "metadata": {}}
{"id": "282", "text": "-1 : 0}\n      role=\"button\"\n      aria-label={isUploading ? \"Upload in progress\" : \"Click to select photos or drag and drop photos here\"}\n      aria-describedby=\"upload-dropzone-description\"\n      aria-live={isUploading ? \"polite\" : \"off\"}\n      {...props}\n    >\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        multiple\n        accept={acceptedFileTypes.join(',')}\n        onChange={handleFileSelect}\n        className=\"hidden\"\n        aria-label=\"Select photos to upload\"\n      />\n\n      <Upload size={48} className=\"mx-auto mb-4 text-gray-400\" />", "metadata": {}}
{"id": "283", "text": "\"Upload in progress\" : \"Click to select photos or drag and drop photos here\"}\n      aria-describedby=\"upload-dropzone-description\"\n      aria-live={isUploading ? \"polite\" : \"off\"}\n      {...props}\n    >\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        multiple\n        accept={acceptedFileTypes.join(',')}\n        onChange={handleFileSelect}\n        className=\"hidden\"\n        aria-label=\"Select photos to upload\"\n      />\n\n      <Upload size={48} className=\"mx-auto mb-4 text-gray-400\" />\n\n      <div className=\"space-y-2\">\n        <p className=\"text-lg font-medium text-gray-900\">\n          {isUploading ? 'Uploading...' : 'Drop photos here or click to select'}\n        </p>\n        <p id=\"upload-dropzone-description\" className=\"text-sm text-gray-500\">\n          Supports: {acceptedFileTypes.join(', ')} • Max {maxFileSize / (1024 * 1024)}MB per file\n        </p>\n        {isUploading && (\n          <div className=\"sr-only\" aria-live=\"polite\">\n            Please wait while your photos are being uploaded\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}", "metadata": {}}
{"id": "284", "text": "export default UploadDropzone", "metadata": {}}
{"id": "285", "text": "import { ZoomModalProps } from '../../types'\nimport { X, ChevronLeft, ChevronRight } from 'lucide-react'\n\nconst ZoomModal = ({\n  isOpen,\n  onClose,\n  photo,\n  photos,\n  currentIndex,\n  onNext,\n  onPrevious,\n  ...props\n}: ZoomModalProps) => {\n  if (!isOpen || !photo) {\n    return null\n  }\n\n  return (\n    <div\n      className=\"fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center\"\n      onClick={onClose}\n      {...props}\n    >\n      <div className=\"relative max-w-7xl max-h-full p-4\">\n        {/* Close button */}\n        <button\n          onClick={onClose}\n          className=\"absolute top-4 right-4 text-white hover:text-gray-300 z-10\"\n          aria-label=\"Close zoom view\"\n        >\n          <X size={32} />\n        </button>", "metadata": {}}
{"id": "286", "text": "return (\n    <div\n      className=\"fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center\"\n      onClick={onClose}\n      {...props}\n    >\n      <div className=\"relative max-w-7xl max-h-full p-4\">\n        {/* Close button */}\n        <button\n          onClick={onClose}\n          className=\"absolute top-4 right-4 text-white hover:text-gray-300 z-10\"\n          aria-label=\"Close zoom view\"\n        >\n          <X size={32} />\n        </button>\n\n        {/* Navigation buttons */}\n        {photos.length > 1 && (\n          <>\n            <button\n              onClick={(e) => {\n                e.stopPropagation()\n                onPrevious()\n              }}\n              className=\"absolute left-4 top-1/2 transform -translate-y-1/2 text-white hover:text-gray-300\"\n              aria-label=\"Previous photo\"\n            >\n              <ChevronLeft size={48} />\n            </button>\n            <button\n              onClick={(e) => {\n                e.stopPropagation()\n                onNext()\n              }}\n              className=\"absolute right-4 top-1/2 transform -translate-y-1/2 text-white hover:text-gray-300\"\n              aria-label=\"Next photo\"\n            >\n              <ChevronRight size={48} />\n            </button>\n          </>\n        )}", "metadata": {}}
{"id": "287", "text": "{/* Image placeholder */}\n        <div\n          className=\"max-w-full max-h-full bg-gray-200 flex items-center justify-center rounded\"\n          onClick={(e) => e.stopPropagation()}\n        >\n          <div className=\"text-gray-500 p-8\">\n            {photo.filename}\n            <br />\n            <small>Full image would display here</small>\n          </div>\n        </div>\n\n        {/* Photo info */}\n        <div className=\"absolute bottom-4 left-4 text-white\">\n          <p className=\"font-semibold\">{photo.filename}</p>\n          <p className=\"text-sm opacity-80\">\n            {currentIndex + 1} of {photos.length}\n          </p>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default ZoomModal", "metadata": {}}
{"id": "288", "text": "import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",", "metadata": {}}
{"id": "289", "text": "{\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2\",\n        sm: \"h-8 rounded-md px-3 text-xs\",\n        lg: \"h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)", "metadata": {}}
{"id": "290", "text": "ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2\",\n        sm: \"h-8 rounded-md px-3 text-xs\",\n        lg: \"h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}", "metadata": {}}
{"id": "291", "text": "size: {\n        default: \"h-9 px-4 py-2\",\n        sm: \"h-8 rounded-md px-3 text-xs\",\n        lg: \"h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }", "metadata": {}}
{"id": "292", "text": "import * as React from \"react\"\nimport { cn } from \"../../lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"", "metadata": {}}
{"id": "293", "text": "const CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h3\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"", "metadata": {}}
{"id": "294", "text": "const CardDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }", "metadata": {}}
{"id": "295", "text": "import * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.", "metadata": {}}
{"id": "296", "text": "const DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.", "metadata": {}}
{"id": "297", "text": "const DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",", "metadata": {}}
{"id": "298", "text": "className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"", "metadata": {}}
{"id": "299", "text": "Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"", "metadata": {}}
{"id": "300", "text": "const DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName", "metadata": {}}
{"id": "301", "text": "const DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogTrigger,\n  DialogClose,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}", "metadata": {}}
{"id": "302", "text": "import { cn } from \"../../lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-muted\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }", "metadata": {}}
{"id": "303", "text": "import * as React from \"react\"\nimport { cn } from \"../../lib/utils\"\n\ninterface SpinnerProps extends React.HTMLAttributes<HTMLDivElement> {\n  size?: \"sm\" | \"md\" | \"lg\"\n}\n\nconst Spinner = React.forwardRef<HTMLDivElement, SpinnerProps>(\n  ({ className, size = \"md\", ...props }, ref) => {\n    const sizeClasses = {\n      sm: \"h-4 w-4\",\n      md: \"h-6 w-6\",\n      lg: \"h-8 w-8\"\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"animate-spin rounded-full border-2 border-muted border-t-primary\",\n          sizeClasses[size],\n          className\n        )}\n        {...props}\n      />\n    )\n  }\n)\nSpinner.displayName = \"Spinner\"\n\nexport { Spinner }", "metadata": {}}
{"id": "304", "text": "import { useEffect, useRef } from 'react';\n\n/**\n * Hook to trap focus within a container element\n */\nexport function useFocusTrap(isActive: boolean = true) {\n  const containerRef = useRef<HTMLElement>(null);\n  const previousActiveElement = useRef<HTMLElement | null>(null);\n\n  useEffect(() => {\n    if (!isActive || !containerRef.current) return;\n\n    const container = containerRef.current;\n    \n    // Store the currently focused element\n    previousActiveElement.current = document.activeElement as HTMLElement;\n\n    // Find all focusable elements\n    const focusableElements = container.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n    \n    if (focusableElements.length === 0) return;\n\n    const firstElement = focusableElements[0] as HTMLElement;\n    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;\n\n    // Focus the first element\n    firstElement.focus();", "metadata": {}}
{"id": "305", "text": "// Find all focusable elements\n    const focusableElements = container.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n    \n    if (focusableElements.length === 0) return;\n\n    const firstElement = focusableElements[0] as HTMLElement;\n    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;\n\n    // Focus the first element\n    firstElement.focus();\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key !== 'Tab') return;\n\n      // If shift + tab on first element, move to last\n      if (event.shiftKey && document.activeElement === firstElement) {\n        event.preventDefault();\n        lastElement.focus();\n      }\n      \n      // If tab on last element, move to first\n      if (!event.shiftKey && document.activeElement === lastElement) {\n        event.preventDefault();\n        firstElement.focus();\n      }\n    };\n\n    // Add event listener\n    container.addEventListener('keydown', handleKeyDown);", "metadata": {}}
{"id": "306", "text": "const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key !== 'Tab') return;\n\n      // If shift + tab on first element, move to last\n      if (event.shiftKey && document.activeElement === firstElement) {\n        event.preventDefault();\n        lastElement.focus();\n      }\n      \n      // If tab on last element, move to first\n      if (!event.shiftKey && document.activeElement === lastElement) {\n        event.preventDefault();\n        firstElement.focus();\n      }\n    };\n\n    // Add event listener\n    container.addEventListener('keydown', handleKeyDown);\n\n    // Cleanup\n    return () => {\n      container.removeEventListener('keydown', handleKeyDown);\n      \n      // Restore focus to previous element\n      if (previousActiveElement.current && document.body.contains(previousActiveElement.current)) {\n        previousActiveElement.current.focus();\n      }\n    };\n  }, [isActive]);\n\n  return containerRef;\n}\n\n/**\n * Hook to manage ARIA announcements for screen readers\n */\nexport function useAriaAnnouncement() {\n  const announceRef = useRef<HTMLDivElement>(null);", "metadata": {}}
{"id": "307", "text": "// Add event listener\n    container.addEventListener('keydown', handleKeyDown);\n\n    // Cleanup\n    return () => {\n      container.removeEventListener('keydown', handleKeyDown);\n      \n      // Restore focus to previous element\n      if (previousActiveElement.current && document.body.contains(previousActiveElement.current)) {\n        previousActiveElement.current.focus();\n      }\n    };\n  }, [isActive]);\n\n  return containerRef;\n}\n\n/**\n * Hook to manage ARIA announcements for screen readers\n */\nexport function useAriaAnnouncement() {\n  const announceRef = useRef<HTMLDivElement>(null);\n\n  const announce = (message: string, priority: 'polite' | 'assertive' = 'polite') => {\n    if (!announceRef.current) return;", "metadata": {}}
{"id": "308", "text": "return containerRef;\n}\n\n/**\n * Hook to manage ARIA announcements for screen readers\n */\nexport function useAriaAnnouncement() {\n  const announceRef = useRef<HTMLDivElement>(null);\n\n  const announce = (message: string, priority: 'polite' | 'assertive' = 'polite') => {\n    if (!announceRef.current) return;\n\n    // Clear previous content\n    announceRef.current.textContent = '';\n    \n    // Set the new message\n    announceRef.current.textContent = message;\n    \n    // Set the appropriate politeness level\n    announceRef.current.setAttribute('aria-live', priority);\n    \n    // Clear after announcement\n    setTimeout(() => {\n      if (announceRef.current) {\n        announceRef.current.textContent = '';\n      }\n    }, 1000);\n  };", "metadata": {}}
{"id": "309", "text": "const announce = (message: string, priority: 'polite' | 'assertive' = 'polite') => {\n    if (!announceRef.current) return;\n\n    // Clear previous content\n    announceRef.current.textContent = '';\n    \n    // Set the new message\n    announceRef.current.textContent = message;\n    \n    // Set the appropriate politeness level\n    announceRef.current.setAttribute('aria-live', priority);\n    \n    // Clear after announcement\n    setTimeout(() => {\n      if (announceRef.current) {\n        announceRef.current.textContent = '';\n      }\n    }, 1000);\n  };\n\n  // Create a hidden div for announcements\n  const AnnouncementRegion = () => (\n    <div\n      ref={announceRef}\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      className=\"sr-only\"\n      style={{\n        position: 'absolute',\n        left: '-10000px',\n        width: '1px',\n        height: '1px',\n        overflow: 'hidden',\n      }}\n    />\n  );\n\n  return { announce, AnnouncementRegion };\n}", "metadata": {}}
{"id": "310", "text": "import { useState, useCallback } from 'react';\nimport { Image } from '../types/image';\nimport { ImageDetailState } from '../types/state';\n\ninterface UseImageDetailReturn {\n  state: ImageDetailState;\n  openDetail: (image: Image | string) => void;\n  closeDetail: () => void;\n  setImage: (image: Image) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n}\n\nexport function useImageDetail(initialState?: Partial<ImageDetailState>): UseImageDetailReturn {\n  const [state, setState] = useState<ImageDetailState>({\n    isOpen: false,\n    selectedImage: null,\n    isLoading: false,\n    error: null,\n    ...initialState,\n  });\n\n  const openDetail = useCallback((image: Image | string) => {\n    setState(prev => ({\n      ...prev,\n      isOpen: true,\n      isLoading: typeof image === 'string',\n      selectedImage: typeof image === 'string' ? null : image,\n      error: null,\n    }));\n  }, []);", "metadata": {}}
{"id": "311", "text": "export function useImageDetail(initialState?: Partial<ImageDetailState>): UseImageDetailReturn {\n  const [state, setState] = useState<ImageDetailState>({\n    isOpen: false,\n    selectedImage: null,\n    isLoading: false,\n    error: null,\n    ...initialState,\n  });\n\n  const openDetail = useCallback((image: Image | string) => {\n    setState(prev => ({\n      ...prev,\n      isOpen: true,\n      isLoading: typeof image === 'string',\n      selectedImage: typeof image === 'string' ? null : image,\n      error: null,\n    }));\n  }, []);\n\n  const closeDetail = useCallback(() => {\n    setState(prev => ({\n      ...prev,\n      isOpen: false,\n      selectedImage: null,\n      isLoading: false,\n      error: null,\n    }));\n  }, []);\n\n  const setImage = useCallback((image: Image) => {\n    setState(prev => ({\n      ...prev,\n      selectedImage: image,\n      isLoading: false,\n      error: null,\n    }));\n  }, []);", "metadata": {}}
{"id": "312", "text": "const closeDetail = useCallback(() => {\n    setState(prev => ({\n      ...prev,\n      isOpen: false,\n      selectedImage: null,\n      isLoading: false,\n      error: null,\n    }));\n  }, []);\n\n  const setImage = useCallback((image: Image) => {\n    setState(prev => ({\n      ...prev,\n      selectedImage: image,\n      isLoading: false,\n      error: null,\n    }));\n  }, []);\n\n  const setLoading = useCallback((loading: boolean) => {\n    setState(prev => ({\n      ...prev,\n      isLoading: loading,\n    }));\n  }, []);\n\n  const setError = useCallback((error: string | null) => {\n    setState(prev => ({\n      ...prev,\n      error,\n      isLoading: false,\n    }));\n  }, []);\n\n  return {\n    state,\n    openDetail,\n    closeDetail,\n    setImage,\n    setLoading,\n    setError,\n  };\n}\n\ninterface UseImageDetailByIdReturn {\n  getImageById: (id: string) => Promise<Image | null>;\n  isLoading: boolean;\n  error: string | null;\n}", "metadata": {}}
{"id": "313", "text": "const setError = useCallback((error: string | null) => {\n    setState(prev => ({\n      ...prev,\n      error,\n      isLoading: false,\n    }));\n  }, []);\n\n  return {\n    state,\n    openDetail,\n    closeDetail,\n    setImage,\n    setLoading,\n    setError,\n  };\n}\n\ninterface UseImageDetailByIdReturn {\n  getImageById: (id: string) => Promise<Image | null>;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport function useImageDetailById(): UseImageDetailByIdReturn {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const getImageById = useCallback(async (id: string): Promise<Image | null> => {\n    setIsLoading(true);\n    setError(null);", "metadata": {}}
{"id": "314", "text": "interface UseImageDetailByIdReturn {\n  getImageById: (id: string) => Promise<Image | null>;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport function useImageDetailById(): UseImageDetailByIdReturn {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const getImageById = useCallback(async (id: string): Promise<Image | null> => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`/api/images/${id}`);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch image: ${response.statusText}`);\n      }\n      const image = await response.json();\n      return image;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMessage);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  return {\n    getImageById,\n    isLoading,\n    error,\n  };\n}", "metadata": {}}
{"id": "315", "text": "try {\n      const response = await fetch(`/api/images/${id}`);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch image: ${response.statusText}`);\n      }\n      const image = await response.json();\n      return image;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMessage);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  return {\n    getImageById,\n    isLoading,\n    error,\n  };\n}\n\ninterface UseImageFileReturn {\n  getImageFile: (id: string) => Promise<string | null>;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport function useImageFile(): UseImageFileReturn {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const getImageFile = useCallback(async (id: string): Promise<string | null> => {\n    setIsLoading(true);\n    setError(null);", "metadata": {}}
{"id": "316", "text": "return {\n    getImageById,\n    isLoading,\n    error,\n  };\n}\n\ninterface UseImageFileReturn {\n  getImageFile: (id: string) => Promise<string | null>;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport function useImageFile(): UseImageFileReturn {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const getImageFile = useCallback(async (id: string): Promise<string | null> => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`/api/images/${id}/file`);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch image file: ${response.statusText}`);\n      }\n      const blob = await response.blob();\n      return URL.createObjectURL(blob);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMessage);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);", "metadata": {}}
{"id": "317", "text": "try {\n      const response = await fetch(`/api/images/${id}/file`);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch image file: ${response.statusText}`);\n      }\n      const blob = await response.blob();\n      return URL.createObjectURL(blob);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n      setError(errorMessage);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  return {\n    getImageFile,\n    isLoading,\n    error,\n  };\n}", "metadata": {}}
{"id": "318", "text": "/**\n * useImagePreloading Hook\n * Provides intelligent image preloading for album and photo components\n */\n\nimport { useEffect, useRef, useCallback, useState } from 'react'\nimport { useImagePreloader, createIntersectionPreloader } from '../utils/imagePreloader'\nimport { Album, Photo } from '../types'\n\nexport interface ImagePreloadingOptions {\n  /** Enable preloading for thumbnails */\n  enableThumbnailPreloading?: boolean\n  /** Enable preloading for full images */\n  enableFullImagePreloading?: boolean\n  /** Number of items to preload ahead */\n  preloadAhead?: number\n  /** Priority for different image types */\n  priorities?: {\n    thumbnail: 'high' | 'medium' | 'low'\n    fullImage: 'high' | 'medium' | 'low'\n  }\n  /** Viewport margin for intersection observer */\n  viewportMargin?: string\n  /** Enable smart preloading based on user behavior */\n  smartPreloading?: boolean\n}", "metadata": {}}
{"id": "319", "text": "export interface PreloadingState {\n  /** Currently preloading images count */\n  preloadingCount: number\n  /** Successfully preloaded images count */\n  preloadedCount: number\n  /** Failed preloads count */\n  failedCount: number\n  /** Whether preloading is active */\n  isPreloading: boolean\n}\n\nconst DEFAULT_OPTIONS: Required<ImagePreloadingOptions> = {\n  enableThumbnailPreloading: true,\n  enableFullImagePreloading: false,\n  preloadAhead: 10,\n  priorities: {\n    thumbnail: 'high',\n    fullImage: 'medium'\n  },\n  viewportMargin: '100px',\n  smartPreloading: true\n}", "metadata": {}}
{"id": "320", "text": "const DEFAULT_OPTIONS: Required<ImagePreloadingOptions> = {\n  enableThumbnailPreloading: true,\n  enableFullImagePreloading: false,\n  preloadAhead: 10,\n  priorities: {\n    thumbnail: 'high',\n    fullImage: 'medium'\n  },\n  viewportMargin: '100px',\n  smartPreloading: true\n}\n\n/**\n * Hook for preloading album thumbnail images\n */\nexport function useAlbumImagePreloading(\n  albums: Album[],\n  options: ImagePreloadingOptions = {}\n) {\n  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }\n  const preloader = useImagePreloader()\n  const [state, setState] = useState<PreloadingState>({\n    preloadingCount: 0,\n    preloadedCount: 0,\n    failedCount: 0,\n    isPreloading: false\n  })\n\n  const preloadAlbumThumbnails = useCallback(async () => {\n    if (!mergedOptions.enableThumbnailPreloading || albums.length === 0) {\n      return\n    }\n\n    setState(prev => ({ ...prev, isPreloading: true, preloadingCount: 0 }))", "metadata": {}}
{"id": "321", "text": "const preloadAlbumThumbnails = useCallback(async () => {\n    if (!mergedOptions.enableThumbnailPreloading || albums.length === 0) {\n      return\n    }\n\n    setState(prev => ({ ...prev, isPreloading: true, preloadingCount: 0 }))\n\n    // Extract thumbnail URLs from albums\n    const thumbnailUrls = albums\n      .filter(album => album.thumbnailPhotoId)\n      .slice(0, mergedOptions.preloadAhead)\n      .map((album, index) => ({\n        url: `/api/photos/${album.thumbnailPhotoId}/thumbnail`,\n        priority: mergedOptions.priorities.thumbnail,\n        importance: Math.max(0, 1 - (index / albums.length)) // Higher importance for earlier items\n      }))\n\n    if (thumbnailUrls.length === 0) return\n\n    setState(prev => ({ ...prev, preloadingCount: thumbnailUrls.length }))", "metadata": {}}
{"id": "322", "text": "// Extract thumbnail URLs from albums\n    const thumbnailUrls = albums\n      .filter(album => album.thumbnailPhotoId)\n      .slice(0, mergedOptions.preloadAhead)\n      .map((album, index) => ({\n        url: `/api/photos/${album.thumbnailPhotoId}/thumbnail`,\n        priority: mergedOptions.priorities.thumbnail,\n        importance: Math.max(0, 1 - (index / albums.length)) // Higher importance for earlier items\n      }))\n\n    if (thumbnailUrls.length === 0) return\n\n    setState(prev => ({ ...prev, preloadingCount: thumbnailUrls.length }))\n\n    try {\n      let results\n      if (mergedOptions.smartPreloading) {\n        results = await preloader.smartPreload(\n          thumbnailUrls.map(item => ({\n            url: item.url,\n            importance: item.importance,\n            userInteraction: false\n          }))\n        )\n      } else {\n        results = await preloader.preloadBatch(thumbnailUrls)\n      }\n\n      const successful = results.filter(r => r.success).length\n      const failed = results.filter(r => !r.success).length", "metadata": {}}
{"id": "323", "text": "setState(prev => ({ ...prev, preloadingCount: thumbnailUrls.length }))\n\n    try {\n      let results\n      if (mergedOptions.smartPreloading) {\n        results = await preloader.smartPreload(\n          thumbnailUrls.map(item => ({\n            url: item.url,\n            importance: item.importance,\n            userInteraction: false\n          }))\n        )\n      } else {\n        results = await preloader.preloadBatch(thumbnailUrls)\n      }\n\n      const successful = results.filter(r => r.success).length\n      const failed = results.filter(r => !r.success).length\n\n      setState(prev => ({\n        ...prev,\n        preloadedCount: prev.preloadedCount + successful,\n        failedCount: prev.failedCount + failed,\n        isPreloading: false,\n        preloadingCount: 0\n      }))\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        isPreloading: false,\n        preloadingCount: 0\n      }))\n    }\n  }, [albums, mergedOptions, preloader])", "metadata": {}}
{"id": "324", "text": "const successful = results.filter(r => r.success).length\n      const failed = results.filter(r => !r.success).length\n\n      setState(prev => ({\n        ...prev,\n        preloadedCount: prev.preloadedCount + successful,\n        failedCount: prev.failedCount + failed,\n        isPreloading: false,\n        preloadingCount: 0\n      }))\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        isPreloading: false,\n        preloadingCount: 0\n      }))\n    }\n  }, [albums, mergedOptions, preloader])\n\n  // Trigger preloading when albums change\n  useEffect(() => {\n    preloadAlbumThumbnails()\n  }, [preloadAlbumThumbnails])\n\n  return {\n    preloadState: state,\n    preloadStats: preloader.getStats(),\n    cacheInfo: preloader.getCacheInfo(),\n    manualPreload: preloadAlbumThumbnails,\n    clearCache: preloader.clear\n  }\n}", "metadata": {}}
{"id": "325", "text": "// Trigger preloading when albums change\n  useEffect(() => {\n    preloadAlbumThumbnails()\n  }, [preloadAlbumThumbnails])\n\n  return {\n    preloadState: state,\n    preloadStats: preloader.getStats(),\n    cacheInfo: preloader.getCacheInfo(),\n    manualPreload: preloadAlbumThumbnails,\n    clearCache: preloader.clear\n  }\n}\n\n/**\n * Hook for preloading photo images in a photo grid\n */\nexport function usePhotoImagePreloading(\n  photos: Photo[],\n  currentIndex: number = 0,\n  options: ImagePreloadingOptions = {}\n) {\n  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }\n  const preloader = useImagePreloader()\n  const [state, setState] = useState<PreloadingState>({\n    preloadingCount: 0,\n    preloadedCount: 0,\n    failedCount: 0,\n    isPreloading: false\n  })\n\n  const preloadAroundIndex = useCallback(async (index: number) => {\n    if (!photos.length) return\n\n    setState(prev => ({ ...prev, isPreloading: true }))", "metadata": {}}
{"id": "326", "text": "const preloadAroundIndex = useCallback(async (index: number) => {\n    if (!photos.length) return\n\n    setState(prev => ({ ...prev, isPreloading: true }))\n\n    const startIndex = Math.max(0, index - Math.floor(mergedOptions.preloadAhead / 2))\n    const endIndex = Math.min(photos.length - 1, startIndex + mergedOptions.preloadAhead)\n\n    const photosToPreload = photos.slice(startIndex, endIndex)\n\n    // Preload thumbnails first (high priority)\n    if (mergedOptions.enableThumbnailPreloading) {\n      const thumbnailUrls = photosToPreload.map((photo, idx) => ({\n        url: `/api/photos/${photo.id}/thumbnail`,\n        priority: mergedOptions.priorities.thumbnail,\n        importance: Math.max(0, 1 - Math.abs(idx - (index - startIndex)) / mergedOptions.preloadAhead)\n      }))\n\n      setState(prev => ({ ...prev, preloadingCount: prev.preloadingCount + thumbnailUrls.length }))", "metadata": {}}
{"id": "327", "text": "const photosToPreload = photos.slice(startIndex, endIndex)\n\n    // Preload thumbnails first (high priority)\n    if (mergedOptions.enableThumbnailPreloading) {\n      const thumbnailUrls = photosToPreload.map((photo, idx) => ({\n        url: `/api/photos/${photo.id}/thumbnail`,\n        priority: mergedOptions.priorities.thumbnail,\n        importance: Math.max(0, 1 - Math.abs(idx - (index - startIndex)) / mergedOptions.preloadAhead)\n      }))\n\n      setState(prev => ({ ...prev, preloadingCount: prev.preloadingCount + thumbnailUrls.length }))\n\n      try {\n        const thumbnailResults = await preloader.smartPreload(\n          thumbnailUrls.map(item => ({\n            url: item.url,\n            importance: item.importance,\n            userInteraction: Math.abs((startIndex + thumbnailUrls.indexOf(item)) - index) <= 1\n          }))\n        )\n\n        const thumbSuccessful = thumbnailResults.filter(r => r.success).length\n        const thumbFailed = thumbnailResults.filter(r => !r.success).length", "metadata": {}}
{"id": "328", "text": "setState(prev => ({ ...prev, preloadingCount: prev.preloadingCount + thumbnailUrls.length }))\n\n      try {\n        const thumbnailResults = await preloader.smartPreload(\n          thumbnailUrls.map(item => ({\n            url: item.url,\n            importance: item.importance,\n            userInteraction: Math.abs((startIndex + thumbnailUrls.indexOf(item)) - index) <= 1\n          }))\n        )\n\n        const thumbSuccessful = thumbnailResults.filter(r => r.success).length\n        const thumbFailed = thumbnailResults.filter(r => !r.success).length\n\n        setState(prev => ({\n          ...prev,\n          preloadedCount: prev.preloadedCount + thumbSuccessful,\n          failedCount: prev.failedCount + thumbFailed,\n          preloadingCount: prev.preloadingCount - thumbnailUrls.length\n        }))\n      } catch (error) {\n        setState(prev => ({ ...prev, preloadingCount: Math.max(0, prev.preloadingCount - thumbnailUrls.length) }))\n      }\n    }", "metadata": {}}
{"id": "329", "text": "const thumbSuccessful = thumbnailResults.filter(r => r.success).length\n        const thumbFailed = thumbnailResults.filter(r => !r.success).length\n\n        setState(prev => ({\n          ...prev,\n          preloadedCount: prev.preloadedCount + thumbSuccessful,\n          failedCount: prev.failedCount + thumbFailed,\n          preloadingCount: prev.preloadingCount - thumbnailUrls.length\n        }))\n      } catch (error) {\n        setState(prev => ({ ...prev, preloadingCount: Math.max(0, prev.preloadingCount - thumbnailUrls.length) }))\n      }\n    }\n\n    // Preload full images if enabled (lower priority)\n    if (mergedOptions.enableFullImagePreloading) {\n      const fullImageUrls = photosToPreload\n        .slice(0, Math.min(3, photosToPreload.length)) // Limit full image preloading\n        .map((photo, idx) => ({\n          url: `/api/photos/${photo.id}/full`,\n          priority: mergedOptions.priorities.fullImage,\n          importance: Math.max(0, 1 - Math.abs(idx - (index - startIndex)) / 3)\n        }))", "metadata": {}}
{"id": "330", "text": "// Preload full images if enabled (lower priority)\n    if (mergedOptions.enableFullImagePreloading) {\n      const fullImageUrls = photosToPreload\n        .slice(0, Math.min(3, photosToPreload.length)) // Limit full image preloading\n        .map((photo, idx) => ({\n          url: `/api/photos/${photo.id}/full`,\n          priority: mergedOptions.priorities.fullImage,\n          importance: Math.max(0, 1 - Math.abs(idx - (index - startIndex)) / 3)\n        }))\n\n      setState(prev => ({ ...prev, preloadingCount: prev.preloadingCount + fullImageUrls.length }))\n\n      try {\n        const fullImageResults = await preloader.preloadBatch(fullImageUrls)\n\n        const fullSuccessful = fullImageResults.filter(r => r.success).length\n        const fullFailed = fullImageResults.filter(r => !r.success).length", "metadata": {}}
{"id": "331", "text": "setState(prev => ({ ...prev, preloadingCount: prev.preloadingCount + fullImageUrls.length }))\n\n      try {\n        const fullImageResults = await preloader.preloadBatch(fullImageUrls)\n\n        const fullSuccessful = fullImageResults.filter(r => r.success).length\n        const fullFailed = fullImageResults.filter(r => !r.success).length\n\n        setState(prev => ({\n          ...prev,\n          preloadedCount: prev.preloadedCount + fullSuccessful,\n          failedCount: prev.failedCount + fullFailed,\n          preloadingCount: prev.preloadingCount - fullImageUrls.length\n        }))\n      } catch (error) {\n        setState(prev => ({ ...prev, preloadingCount: Math.max(0, prev.preloadingCount - fullImageUrls.length) }))\n      }\n    }\n\n    setState(prev => ({ ...prev, isPreloading: false }))\n  }, [photos, mergedOptions, preloader])\n\n  // Preload around current index when it changes\n  useEffect(() => {\n    preloadAroundIndex(currentIndex)\n  }, [currentIndex, preloadAroundIndex])", "metadata": {}}
{"id": "332", "text": "setState(prev => ({ ...prev, isPreloading: false }))\n  }, [photos, mergedOptions, preloader])\n\n  // Preload around current index when it changes\n  useEffect(() => {\n    preloadAroundIndex(currentIndex)\n  }, [currentIndex, preloadAroundIndex])\n\n  return {\n    preloadState: state,\n    preloadStats: preloader.getStats(),\n    cacheInfo: preloader.getCacheInfo(),\n    preloadAroundIndex,\n    clearCache: preloader.clear\n  }\n}\n\n/**\n * Hook for viewport-based image preloading with Intersection Observer\n */\nexport function useIntersectionPreloading(\n  options: ImagePreloadingOptions & {\n    threshold?: number\n    onImageLoad?: (url: string) => void\n  } = {}\n) {\n  const { threshold = 0.1, onImageLoad, ...preloadOptions } = options\n  const observerRef = useRef<IntersectionObserver | null>(null)\n  const preloader = useImagePreloader(preloadOptions)", "metadata": {}}
{"id": "333", "text": "/**\n * Hook for viewport-based image preloading with Intersection Observer\n */\nexport function useIntersectionPreloading(\n  options: ImagePreloadingOptions & {\n    threshold?: number\n    onImageLoad?: (url: string) => void\n  } = {}\n) {\n  const { threshold = 0.1, onImageLoad, ...preloadOptions } = options\n  const observerRef = useRef<IntersectionObserver | null>(null)\n  const preloader = useImagePreloader(preloadOptions)\n\n  useEffect(() => {\n    observerRef.current = createIntersectionPreloader({\n      threshold,\n      rootMargin: options.viewportMargin || '100px',\n      ...preloadOptions\n    })\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n    }\n  }, [threshold, options.viewportMargin, preloadOptions])\n\n  const observeElement = useCallback((element: HTMLElement) => {\n    if (observerRef.current && element) {\n      observerRef.current.observe(element)\n    }\n  }, [])", "metadata": {}}
{"id": "334", "text": "useEffect(() => {\n    observerRef.current = createIntersectionPreloader({\n      threshold,\n      rootMargin: options.viewportMargin || '100px',\n      ...preloadOptions\n    })\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n    }\n  }, [threshold, options.viewportMargin, preloadOptions])\n\n  const observeElement = useCallback((element: HTMLElement) => {\n    if (observerRef.current && element) {\n      observerRef.current.observe(element)\n    }\n  }, [])\n\n  const unobserveElement = useCallback((element: HTMLElement) => {\n    if (observerRef.current && element) {\n      observerRef.current.unobserve(element)\n    }\n  }, [])\n\n  return {\n    observeElement,\n    unobserveElement,\n    preloadStats: preloader.getStats(),\n    cacheInfo: preloader.getCacheInfo()\n  }\n}", "metadata": {}}
{"id": "335", "text": "/**\n * useInfiniteAlbums Hook\n * Manages infinite scrolling for albums with pagination and retry logic\n */\n\nimport { useState, useCallback, useEffect } from 'react'\nimport { Album, PaginatedResponse } from '../types'\nimport { mockDataService } from '../services/MockDataService'\nimport { useInfiniteScroll } from './useInfiniteScroll'\nimport { useRetry } from './useRetry'\n\nexport interface UseInfiniteAlbumsReturn {\n  albums: Album[]\n  loading: boolean\n  error: string | null\n  hasNextPage: boolean\n  triggerRef: React.RefObject<HTMLElement>\n  loadMore: () => Promise<void>\n  refresh: () => Promise<void>\n  retrying: boolean\n  retryCount: number\n  retry: () => Promise<void>\n}", "metadata": {}}
{"id": "336", "text": "export interface UseInfiniteAlbumsReturn {\n  albums: Album[]\n  loading: boolean\n  error: string | null\n  hasNextPage: boolean\n  triggerRef: React.RefObject<HTMLElement>\n  loadMore: () => Promise<void>\n  refresh: () => Promise<void>\n  retrying: boolean\n  retryCount: number\n  retry: () => Promise<void>\n}\n\nexport function useInfiniteAlbums(pageSize: number = 12): UseInfiniteAlbumsReturn {\n  const [albums, setAlbums] = useState<Album[]>([])\n  const [currentPage, setCurrentPage] = useState(1)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [hasNextPage, setHasNextPage] = useState(true)\n  const [lastFailedPage, setLastFailedPage] = useState<number | null>(null)", "metadata": {}}
{"id": "337", "text": "export function useInfiniteAlbums(pageSize: number = 12): UseInfiniteAlbumsReturn {\n  const [albums, setAlbums] = useState<Album[]>([])\n  const [currentPage, setCurrentPage] = useState(1)\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [hasNextPage, setHasNextPage] = useState(true)\n  const [lastFailedPage, setLastFailedPage] = useState<number | null>(null)\n\n  // Configure retry with album-specific settings\n  const { execute: executeWithRetry, retrying, retryCount, reset: resetRetry } = useRetry<PaginatedResponse<Album>>({\n    maxRetries: 3,\n    initialDelay: 1000,\n    backoffFactor: 1.5,\n    retryCondition: (error) => {\n      // Retry on network-like errors but not on validation errors\n      return !error.message.includes('not found') && !error.message.includes('invalid')\n    }\n  })", "metadata": {}}
{"id": "338", "text": "// Configure retry with album-specific settings\n  const { execute: executeWithRetry, retrying, retryCount, reset: resetRetry } = useRetry<PaginatedResponse<Album>>({\n    maxRetries: 3,\n    initialDelay: 1000,\n    backoffFactor: 1.5,\n    retryCondition: (error) => {\n      // Retry on network-like errors but not on validation errors\n      return !error.message.includes('not found') && !error.message.includes('invalid')\n    }\n  })\n\n  const loadAlbumsPage = useCallback(async (page: number, reset: boolean = false) => {\n    try {\n      setLoading(true)\n      setError(null)\n      setLastFailedPage(null)\n      resetRetry()\n\n      const response = await executeWithRetry(() =>\n        mockDataService.getAlbumsPaginated(page, pageSize)\n      )\n\n      if (reset) {\n        setAlbums(response.data)\n      } else {\n        setAlbums(prev => [...prev, ...response.data])\n      }", "metadata": {}}
{"id": "339", "text": "const loadAlbumsPage = useCallback(async (page: number, reset: boolean = false) => {\n    try {\n      setLoading(true)\n      setError(null)\n      setLastFailedPage(null)\n      resetRetry()\n\n      const response = await executeWithRetry(() =>\n        mockDataService.getAlbumsPaginated(page, pageSize)\n      )\n\n      if (reset) {\n        setAlbums(response.data)\n      } else {\n        setAlbums(prev => [...prev, ...response.data])\n      }\n\n      setHasNextPage(response.pagination.hasNextPage)\n      setCurrentPage(page)\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to load albums'\n      setError(errorMessage)\n      setLastFailedPage(page)\n    } finally {\n      setLoading(false)\n    }\n  }, [pageSize, executeWithRetry, resetRetry])\n\n  const loadMore = useCallback(async () => {\n    if (!hasNextPage || loading) return\n    await loadAlbumsPage(currentPage + 1, false)\n  }, [currentPage, hasNextPage, loading, loadAlbumsPage])", "metadata": {}}
{"id": "340", "text": "setHasNextPage(response.pagination.hasNextPage)\n      setCurrentPage(page)\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to load albums'\n      setError(errorMessage)\n      setLastFailedPage(page)\n    } finally {\n      setLoading(false)\n    }\n  }, [pageSize, executeWithRetry, resetRetry])\n\n  const loadMore = useCallback(async () => {\n    if (!hasNextPage || loading) return\n    await loadAlbumsPage(currentPage + 1, false)\n  }, [currentPage, hasNextPage, loading, loadAlbumsPage])\n\n  const refresh = useCallback(async () => {\n    setCurrentPage(1)\n    setAlbums([])\n    setHasNextPage(true)\n    await loadAlbumsPage(1, true)\n  }, [loadAlbumsPage])\n\n  const retry = useCallback(async () => {\n    if (lastFailedPage) {\n      await loadAlbumsPage(lastFailedPage, lastFailedPage === 1)\n    }\n  }, [lastFailedPage, loadAlbumsPage])", "metadata": {}}
{"id": "341", "text": "const refresh = useCallback(async () => {\n    setCurrentPage(1)\n    setAlbums([])\n    setHasNextPage(true)\n    await loadAlbumsPage(1, true)\n  }, [loadAlbumsPage])\n\n  const retry = useCallback(async () => {\n    if (lastFailedPage) {\n      await loadAlbumsPage(lastFailedPage, lastFailedPage === 1)\n    }\n  }, [lastFailedPage, loadAlbumsPage])\n\n  const { triggerRef } = useInfiniteScroll(loadMore, {\n    enabled: hasNextPage && !loading,\n    threshold: 0.1,\n    rootMargin: '100px',\n  })\n\n  // Load initial page on mount and generate demo data if empty\n  useEffect(() => {\n    const initializeData = async () => {\n      // Generate demo data if no albums exist\n      const initialAlbums = await mockDataService.getAllAlbums()\n      if (initialAlbums.length === 0) {\n        mockDataService.generateDemoData(50)\n      }\n      await loadAlbumsPage(1, true)\n    }", "metadata": {}}
{"id": "342", "text": "// Load initial page on mount and generate demo data if empty\n  useEffect(() => {\n    const initializeData = async () => {\n      // Generate demo data if no albums exist\n      const initialAlbums = await mockDataService.getAllAlbums()\n      if (initialAlbums.length === 0) {\n        mockDataService.generateDemoData(50)\n      }\n      await loadAlbumsPage(1, true)\n    }\n\n    initializeData()\n  }, [loadAlbumsPage])\n\n  return {\n    albums,\n    loading,\n    error,\n    hasNextPage,\n    triggerRef,\n    loadMore,\n    refresh,\n    retrying,\n    retryCount,\n    retry,\n  }\n}", "metadata": {}}
{"id": "343", "text": "/**\n * useInfiniteScroll Hook\n * Provides infinite scrolling functionality with IntersectionObserver\n * Includes performance monitoring for scroll metrics\n */\n\nimport { useRef, useEffect, useCallback, useState } from 'react'\nimport { InfiniteScrollOptions } from '../types'\nimport { usePerformanceMonitor, measureAsyncTime } from '../utils/performanceMonitor'", "metadata": {}}
{"id": "344", "text": "/**\n * useInfiniteScroll Hook\n * Provides infinite scrolling functionality with IntersectionObserver\n * Includes performance monitoring for scroll metrics\n */\n\nimport { useRef, useEffect, useCallback, useState } from 'react'\nimport { InfiniteScrollOptions } from '../types'\nimport { usePerformanceMonitor, measureAsyncTime } from '../utils/performanceMonitor'\n\nexport interface UseInfiniteScrollReturn {\n  /** Reference to attach to the trigger element */\n  triggerRef: React.RefObject<HTMLElement>\n  /** Loading state indicator */\n  isLoading: boolean\n  /** Whether there are more items to load */\n  hasNextPage: boolean\n  /** Current error message, if any */\n  error: string | null\n  /** Manual loading trigger */\n  loadMore: () => Promise<void>\n  /** Manual loading state control */\n  setIsLoading: (loading: boolean) => void\n  /** Manual hasNextPage control */\n  setHasNextPage: (hasNext: boolean) => void\n  /** Manual error control */\n  setError: (error: string | null) => void\n  /** Focus management for new content */\n  focusNewContent: (selector?: string) => void\n  /** Performance metrics */\n  performanceMetrics: () => any\n  /** Start performance monitoring */\n  startPerformanceMonitoring: () => void\n  /** Stop performance monitoring */\n  stopPerformanceMonitoring: () => void\n}", "metadata": {}}
{"id": "345", "text": "export function useInfiniteScroll(\n  callback: () => Promise<void>,\n  options: InfiniteScrollOptions = {}\n): UseInfiniteScrollReturn {\n  const {\n    threshold = 0.1,\n    rootMargin = '50px',\n    enabled = true\n  } = options\n\n  // State management\n  const [isLoading, setIsLoading] = useState(false)\n  const [hasNextPage, setHasNextPage] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  // Performance monitoring\n  const performanceMonitor = usePerformanceMonitor({\n    enableFPSMonitoring: true,\n    enableMemoryMonitoring: true,\n    enableRenderTimeMonitoring: true,\n    sampleSize: 50,\n    reportingInterval: 10000, // Report every 10 seconds\n    onReport: (metrics) => {\n      console.group('📊 Infinite Scroll Performance')\n      console.log('Scroll Performance:', {\n        avgFPS: metrics.scrollFPS.length > 0 ?", "metadata": {}}
{"id": "346", "text": "// Performance monitoring\n  const performanceMonitor = usePerformanceMonitor({\n    enableFPSMonitoring: true,\n    enableMemoryMonitoring: true,\n    enableRenderTimeMonitoring: true,\n    sampleSize: 50,\n    reportingInterval: 10000, // Report every 10 seconds\n    onReport: (metrics) => {\n      console.group('📊 Infinite Scroll Performance')\n      console.log('Scroll Performance:', {\n        avgFPS: metrics.scrollFPS.length > 0 ? (metrics.scrollFPS.reduce((a, b) => a + b, 0) / metrics.scrollFPS.length).toFixed(2) : 'N/A',\n        avgLoadTime: metrics.loadTime.length > 0 ? (metrics.loadTime.reduce((a, b) => a + b, 0) / metrics.loadTime.length).toFixed(2) + 'ms' : 'N/A',\n        avgIntersectionTime: metrics.intersectionTime.length > 0 ?", "metadata": {}}
{"id": "347", "text": "(metrics.scrollFPS.reduce((a, b) => a + b, 0) / metrics.scrollFPS.length).toFixed(2) : 'N/A',\n        avgLoadTime: metrics.loadTime.length > 0 ? (metrics.loadTime.reduce((a, b) => a + b, 0) / metrics.loadTime.length).toFixed(2) + 'ms' : 'N/A',\n        avgIntersectionTime: metrics.intersectionTime.length > 0 ? (metrics.intersectionTime.reduce((a, b) => a + b, 0) / metrics.intersectionTime.length).toFixed(2) + 'ms' : 'N/A'\n      })\n      console.groupEnd()\n    }\n  })\n\n  // Refs\n  const triggerRef = useRef<HTMLElement>(null)\n  const observerRef = useRef<IntersectionObserver | null>(null)\n  const callbackRef = useRef(callback)\n  const itemCountRef = useRef(0)", "metadata": {}}
{"id": "348", "text": "(metrics.intersectionTime.reduce((a, b) => a + b, 0) / metrics.intersectionTime.length).toFixed(2) + 'ms' : 'N/A'\n      })\n      console.groupEnd()\n    }\n  })\n\n  // Refs\n  const triggerRef = useRef<HTMLElement>(null)\n  const observerRef = useRef<IntersectionObserver | null>(null)\n  const callbackRef = useRef(callback)\n  const itemCountRef = useRef(0)\n\n  // Focus management function\n  const focusNewContent = useCallback((selector: string = '[role=\"button\"]') => {\n    // Wait for DOM update\n    setTimeout(() => {\n      const items = document.querySelectorAll(selector)\n      const firstNewItem = items[itemCountRef.current] as HTMLElement\n      if (firstNewItem && firstNewItem.focus) {\n        firstNewItem.focus()\n\n        // Scroll into view if needed\n        firstNewItem.scrollIntoView({\n          behavior: 'smooth',\n          block: 'nearest'\n        })\n      }\n    }, 100)\n  }, [])", "metadata": {}}
{"id": "349", "text": "// Focus management function\n  const focusNewContent = useCallback((selector: string = '[role=\"button\"]') => {\n    // Wait for DOM update\n    setTimeout(() => {\n      const items = document.querySelectorAll(selector)\n      const firstNewItem = items[itemCountRef.current] as HTMLElement\n      if (firstNewItem && firstNewItem.focus) {\n        firstNewItem.focus()\n\n        // Scroll into view if needed\n        firstNewItem.scrollIntoView({\n          behavior: 'smooth',\n          block: 'nearest'\n        })\n      }\n    }, 100)\n  }, [])\n\n  // Update callback ref when callback changes\n  useEffect(() => {\n    callbackRef.current = callback\n  }, [callback])\n\n  // Load more function for manual triggering with performance tracking\n  const loadMore = useCallback(async () => {\n    if (isLoading || !hasNextPage) {\n      return\n    }\n\n    setIsLoading(true)\n    setError(null)", "metadata": {}}
{"id": "350", "text": "// Scroll into view if needed\n        firstNewItem.scrollIntoView({\n          behavior: 'smooth',\n          block: 'nearest'\n        })\n      }\n    }, 100)\n  }, [])\n\n  // Update callback ref when callback changes\n  useEffect(() => {\n    callbackRef.current = callback\n  }, [callback])\n\n  // Load more function for manual triggering with performance tracking\n  const loadMore = useCallback(async () => {\n    if (isLoading || !hasNextPage) {\n      return\n    }\n\n    setIsLoading(true)\n    setError(null)\n\n    try {\n      await measureAsyncTime(callbackRef.current)\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred'\n      setError(errorMessage)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [isLoading, hasNextPage, performanceMonitor])\n\n  // Intersection observer callback with performance tracking\n  const handleIntersection = useCallback(\n    (entries: IntersectionObserverEntry[]) => {\n      const intersectionStartTime = performance.now()\n      const entry = entries[0]", "metadata": {}}
{"id": "351", "text": "setIsLoading(true)\n    setError(null)\n\n    try {\n      await measureAsyncTime(callbackRef.current)\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred'\n      setError(errorMessage)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [isLoading, hasNextPage, performanceMonitor])\n\n  // Intersection observer callback with performance tracking\n  const handleIntersection = useCallback(\n    (entries: IntersectionObserverEntry[]) => {\n      const intersectionStartTime = performance.now()\n      const entry = entries[0]\n\n      if (entry.isIntersecting && hasNextPage && !isLoading) {\n        performanceMonitor.recordIntersectionTime(intersectionStartTime)\n        loadMore()\n      }\n    },\n    [hasNextPage, isLoading, loadMore, performanceMonitor]\n  )\n\n  // Initialize IntersectionObserver\n  useEffect(() => {\n    if (!enabled) {\n      return\n    }\n\n    observerRef.current = new IntersectionObserver(handleIntersection, {\n      threshold,\n      rootMargin,\n    })", "metadata": {}}
{"id": "352", "text": "if (entry.isIntersecting && hasNextPage && !isLoading) {\n        performanceMonitor.recordIntersectionTime(intersectionStartTime)\n        loadMore()\n      }\n    },\n    [hasNextPage, isLoading, loadMore, performanceMonitor]\n  )\n\n  // Initialize IntersectionObserver\n  useEffect(() => {\n    if (!enabled) {\n      return\n    }\n\n    observerRef.current = new IntersectionObserver(handleIntersection, {\n      threshold,\n      rootMargin,\n    })\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n    }\n  }, [enabled, threshold, rootMargin, handleIntersection])\n\n  // Handle trigger ref changes\n  useEffect(() => {\n    const observer = observerRef.current\n    const element = triggerRef.current\n\n    if (!observer || !element || !enabled) {\n      return\n    }\n\n    observer.observe(element)\n\n    return () => {\n      if (observer && element) {\n        observer.unobserve(element)\n      }\n    }\n  }, [triggerRef.current, enabled])", "metadata": {}}
{"id": "353", "text": "return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n    }\n  }, [enabled, threshold, rootMargin, handleIntersection])\n\n  // Handle trigger ref changes\n  useEffect(() => {\n    const observer = observerRef.current\n    const element = triggerRef.current\n\n    if (!observer || !element || !enabled) {\n      return\n    }\n\n    observer.observe(element)\n\n    return () => {\n      if (observer && element) {\n        observer.unobserve(element)\n      }\n    }\n  }, [triggerRef.current, enabled])\n\n  return {\n    triggerRef,\n    isLoading,\n    hasNextPage,\n    error,\n    loadMore,\n    setIsLoading,\n    setHasNextPage,\n    setError,\n    focusNewContent,\n    performanceMetrics: performanceMonitor.getMetrics,\n    startPerformanceMonitoring: performanceMonitor.start,\n    stopPerformanceMonitoring: performanceMonitor.stop,\n  }\n}", "metadata": {}}
{"id": "354", "text": "/**\n * useRetry Hook\n * Provides retry functionality for async operations with exponential backoff\n */\n\nimport { useState, useCallback } from 'react'\n\nexport interface RetryOptions {\n  maxRetries?: number\n  initialDelay?: number\n  maxDelay?: number\n  backoffFactor?: number\n  retryCondition?: (error: Error) => boolean\n}\n\nexport interface UseRetryReturn<T> {\n  execute: (fn: () => Promise<T>) => Promise<T>\n  retrying: boolean\n  retryCount: number\n  lastError: Error | null\n  reset: () => void\n}\n\nconst defaultRetryCondition = (error: Error): boolean => {\n  // Retry on network errors and 5xx server errors\n  return error.message.includes('network') ||\n         error.message.includes('timeout') ||\n         error.message.includes('fetch')\n}", "metadata": {}}
{"id": "355", "text": "export interface UseRetryReturn<T> {\n  execute: (fn: () => Promise<T>) => Promise<T>\n  retrying: boolean\n  retryCount: number\n  lastError: Error | null\n  reset: () => void\n}\n\nconst defaultRetryCondition = (error: Error): boolean => {\n  // Retry on network errors and 5xx server errors\n  return error.message.includes('network') ||\n         error.message.includes('timeout') ||\n         error.message.includes('fetch')\n}\n\nexport function useRetry<T>(options: RetryOptions = {}): UseRetryReturn<T> {\n  const {\n    maxRetries = 3,\n    initialDelay = 1000,\n    maxDelay = 10000,\n    backoffFactor = 2,\n    retryCondition = defaultRetryCondition\n  } = options\n\n  const [retrying, setRetrying] = useState(false)\n  const [retryCount, setRetryCount] = useState(0)\n  const [lastError, setLastError] = useState<Error | null>(null)", "metadata": {}}
{"id": "356", "text": "export function useRetry<T>(options: RetryOptions = {}): UseRetryReturn<T> {\n  const {\n    maxRetries = 3,\n    initialDelay = 1000,\n    maxDelay = 10000,\n    backoffFactor = 2,\n    retryCondition = defaultRetryCondition\n  } = options\n\n  const [retrying, setRetrying] = useState(false)\n  const [retryCount, setRetryCount] = useState(0)\n  const [lastError, setLastError] = useState<Error | null>(null)\n\n  const delay = (ms: number): Promise<void> =>\n    new Promise(resolve => setTimeout(resolve, ms))\n\n  const calculateDelay = (attempt: number): number => {\n    const delayMs = Math.min(\n      initialDelay * Math.pow(backoffFactor, attempt),\n      maxDelay\n    )\n    // Add jitter to prevent thundering herd\n    return delayMs + (Math.random() * 0.1 * delayMs)\n  }", "metadata": {}}
{"id": "357", "text": "const delay = (ms: number): Promise<void> =>\n    new Promise(resolve => setTimeout(resolve, ms))\n\n  const calculateDelay = (attempt: number): number => {\n    const delayMs = Math.min(\n      initialDelay * Math.pow(backoffFactor, attempt),\n      maxDelay\n    )\n    // Add jitter to prevent thundering herd\n    return delayMs + (Math.random() * 0.1 * delayMs)\n  }\n\n  const execute = useCallback(async (fn: () => Promise<T>): Promise<T> => {\n    let attempt = 0\n    setRetrying(false)\n    setRetryCount(0)\n\n    while (attempt <= maxRetries) {\n      try {\n        if (attempt > 0) {\n          setRetrying(true)\n          setRetryCount(attempt)\n          const delayMs = calculateDelay(attempt - 1)\n          await delay(delayMs)\n        }\n\n        const result = await fn()\n\n        // Only reset error on success\n        setRetrying(false)\n        setRetryCount(0)\n        setLastError(null)", "metadata": {}}
{"id": "358", "text": "while (attempt <= maxRetries) {\n      try {\n        if (attempt > 0) {\n          setRetrying(true)\n          setRetryCount(attempt)\n          const delayMs = calculateDelay(attempt - 1)\n          await delay(delayMs)\n        }\n\n        const result = await fn()\n\n        // Only reset error on success\n        setRetrying(false)\n        setRetryCount(0)\n        setLastError(null)\n\n        return result\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error('Unknown error')\n        setLastError(err)\n\n        if (attempt >= maxRetries || !retryCondition(err)) {\n          setRetrying(false)\n          throw err\n        }\n\n        attempt++\n      }\n    }\n\n    // This should never be reached, but TypeScript needs it\n    throw lastError\n  }, [maxRetries, initialDelay, maxDelay, backoffFactor, retryCondition, lastError])\n\n  const reset = useCallback(() => {\n    setRetrying(false)\n    setRetryCount(0)\n    setLastError(null)\n  }, [])", "metadata": {}}
{"id": "359", "text": "if (attempt >= maxRetries || !retryCondition(err)) {\n          setRetrying(false)\n          throw err\n        }\n\n        attempt++\n      }\n    }\n\n    // This should never be reached, but TypeScript needs it\n    throw lastError\n  }, [maxRetries, initialDelay, maxDelay, backoffFactor, retryCondition, lastError])\n\n  const reset = useCallback(() => {\n    setRetrying(false)\n    setRetryCount(0)\n    setLastError(null)\n  }, [])\n\n  return {\n    execute,\n    retrying,\n    retryCount,\n    lastError,\n    reset\n  }\n}", "metadata": {}}
{"id": "360", "text": "/**\n * useVirtualization Hook\n * Determines when to use virtualization based on performance criteria\n */\n\nimport { useState, useEffect, useMemo } from 'react'\n\nexport interface VirtualizationConfig {\n  /** Minimum items before virtualization is considered */\n  itemThreshold: number\n  /** Container height threshold for virtualization */\n  heightThreshold: number\n  /** Enable/disable virtualization globally */\n  forceVirtualization?: boolean\n  /** Disable virtualization globally */\n  disableVirtualization?: boolean\n}\n\nexport interface VirtualizationResult {\n  /** Whether virtualization should be used */\n  shouldVirtualize: boolean\n  /** Recommended container height for virtualization */\n  containerHeight: number\n  /** Recommended item dimensions */\n  itemDimensions: {\n    width: number\n    height: number\n  }\n  /** Performance metrics */\n  metrics: {\n    itemCount: number\n    estimatedUnvirtualizedHeight: number\n    memoryImpact: 'low' | 'medium' | 'high'\n  }\n}", "metadata": {}}
{"id": "361", "text": "export interface VirtualizationResult {\n  /** Whether virtualization should be used */\n  shouldVirtualize: boolean\n  /** Recommended container height for virtualization */\n  containerHeight: number\n  /** Recommended item dimensions */\n  itemDimensions: {\n    width: number\n    height: number\n  }\n  /** Performance metrics */\n  metrics: {\n    itemCount: number\n    estimatedUnvirtualizedHeight: number\n    memoryImpact: 'low' | 'medium' | 'high'\n  }\n}\n\nconst DEFAULT_CONFIG: VirtualizationConfig = {\n  itemThreshold: 50, // Start virtualizing after 50 items\n  heightThreshold: 2000, // Virtualize if total height would exceed 2000px\n  forceVirtualization: false,\n  disableVirtualization: false\n}\n\nexport function useVirtualization(\n  itemCount: number,\n  itemHeight: number = 280,\n  itemWidth: number = 320,\n  config: Partial<VirtualizationConfig> = {}\n): VirtualizationResult {\n  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 600 })", "metadata": {}}
{"id": "362", "text": "export function useVirtualization(\n  itemCount: number,\n  itemHeight: number = 280,\n  itemWidth: number = 320,\n  config: Partial<VirtualizationConfig> = {}\n): VirtualizationResult {\n  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 600 })\n\n  const mergedConfig = useMemo(() => ({ ...DEFAULT_CONFIG, ...config }), [config])\n\n  // Calculate container dimensions\n  useEffect(() => {\n    const calculateDimensions = () => {\n      const viewportWidth = window.innerWidth\n      const viewportHeight = window.innerHeight\n\n      // Estimate container width (accounting for padding/margins)\n      const containerWidth = Math.min(viewportWidth - 64, 1200) // Max width of 1200px with 32px margins\n\n      // Calculate appropriate container height (max 70% of viewport)\n      const maxHeight = Math.floor(viewportHeight * 0.7)\n      const recommendedHeight = Math.min(600, maxHeight)\n\n      setContainerDimensions({\n        width: containerWidth,\n        height: recommendedHeight\n      })\n    }", "metadata": {}}
{"id": "363", "text": "// Estimate container width (accounting for padding/margins)\n      const containerWidth = Math.min(viewportWidth - 64, 1200) // Max width of 1200px with 32px margins\n\n      // Calculate appropriate container height (max 70% of viewport)\n      const maxHeight = Math.floor(viewportHeight * 0.7)\n      const recommendedHeight = Math.min(600, maxHeight)\n\n      setContainerDimensions({\n        width: containerWidth,\n        height: recommendedHeight\n      })\n    }\n\n    calculateDimensions()\n    window.addEventListener('resize', calculateDimensions)\n\n    return () => window.removeEventListener('resize', calculateDimensions)\n  }, [])\n\n  // Calculate virtualization decision\n  const result = useMemo((): VirtualizationResult => {\n    const { itemThreshold, heightThreshold, forceVirtualization, disableVirtualization } = mergedConfig", "metadata": {}}
{"id": "364", "text": "setContainerDimensions({\n        width: containerWidth,\n        height: recommendedHeight\n      })\n    }\n\n    calculateDimensions()\n    window.addEventListener('resize', calculateDimensions)\n\n    return () => window.removeEventListener('resize', calculateDimensions)\n  }, [])\n\n  // Calculate virtualization decision\n  const result = useMemo((): VirtualizationResult => {\n    const { itemThreshold, heightThreshold, forceVirtualization, disableVirtualization } = mergedConfig\n\n    // Force override\n    if (disableVirtualization) {\n      return {\n        shouldVirtualize: false,\n        containerHeight: containerDimensions.height,\n        itemDimensions: { width: itemWidth, height: itemHeight },\n        metrics: {\n          itemCount,\n          estimatedUnvirtualizedHeight: 0,\n          memoryImpact: 'low'\n        }\n      }\n    }", "metadata": {}}
{"id": "365", "text": "// Calculate virtualization decision\n  const result = useMemo((): VirtualizationResult => {\n    const { itemThreshold, heightThreshold, forceVirtualization, disableVirtualization } = mergedConfig\n\n    // Force override\n    if (disableVirtualization) {\n      return {\n        shouldVirtualize: false,\n        containerHeight: containerDimensions.height,\n        itemDimensions: { width: itemWidth, height: itemHeight },\n        metrics: {\n          itemCount,\n          estimatedUnvirtualizedHeight: 0,\n          memoryImpact: 'low'\n        }\n      }\n    }\n\n    if (forceVirtualization) {\n      return {\n        shouldVirtualize: true,\n        containerHeight: containerDimensions.height,\n        itemDimensions: { width: itemWidth, height: itemHeight },\n        metrics: {\n          itemCount,\n          estimatedUnvirtualizedHeight: itemCount * itemHeight,\n          memoryImpact: itemCount > 1000 ? 'high' : itemCount > 200 ? 'medium' : 'low'\n        }\n      }\n    }", "metadata": {}}
{"id": "366", "text": "if (forceVirtualization) {\n      return {\n        shouldVirtualize: true,\n        containerHeight: containerDimensions.height,\n        itemDimensions: { width: itemWidth, height: itemHeight },\n        metrics: {\n          itemCount,\n          estimatedUnvirtualizedHeight: itemCount * itemHeight,\n          memoryImpact: itemCount > 1000 ? 'high' : itemCount > 200 ? 'medium' : 'low'\n        }\n      }\n    }\n\n    // Calculate grid dimensions\n    const columnsPerRow = Math.max(1, Math.floor(containerDimensions.width / itemWidth))\n    const totalRows = Math.ceil(itemCount / columnsPerRow)\n    const estimatedHeight = totalRows * itemHeight\n\n    // Decision criteria\n    const exceedsItemThreshold = itemCount >= itemThreshold\n    const exceedsHeightThreshold = estimatedHeight >= heightThreshold", "metadata": {}}
{"id": "367", "text": "// Calculate grid dimensions\n    const columnsPerRow = Math.max(1, Math.floor(containerDimensions.width / itemWidth))\n    const totalRows = Math.ceil(itemCount / columnsPerRow)\n    const estimatedHeight = totalRows * itemHeight\n\n    // Decision criteria\n    const exceedsItemThreshold = itemCount >= itemThreshold\n    const exceedsHeightThreshold = estimatedHeight >= heightThreshold\n\n    // Memory impact assessment\n    let memoryImpact: 'low' | 'medium' | 'high' = 'low'\n    if (itemCount > 1000) {\n      memoryImpact = 'high'\n    } else if (itemCount > 200) {\n      memoryImpact = 'medium'\n    }\n\n    const shouldVirtualize = exceedsItemThreshold || exceedsHeightThreshold || memoryImpact === 'high'", "metadata": {}}
{"id": "368", "text": "// Decision criteria\n    const exceedsItemThreshold = itemCount >= itemThreshold\n    const exceedsHeightThreshold = estimatedHeight >= heightThreshold\n\n    // Memory impact assessment\n    let memoryImpact: 'low' | 'medium' | 'high' = 'low'\n    if (itemCount > 1000) {\n      memoryImpact = 'high'\n    } else if (itemCount > 200) {\n      memoryImpact = 'medium'\n    }\n\n    const shouldVirtualize = exceedsItemThreshold || exceedsHeightThreshold || memoryImpact === 'high'\n\n    return {\n      shouldVirtualize,\n      containerHeight: containerDimensions.height,\n      itemDimensions: { width: itemWidth, height: itemHeight },\n      metrics: {\n        itemCount,\n        estimatedUnvirtualizedHeight: estimatedHeight,\n        memoryImpact\n      }\n    }\n  }, [\n    itemCount,\n    itemHeight,\n    itemWidth,\n    containerDimensions,\n    mergedConfig\n  ])\n\n  return result\n}", "metadata": {}}
{"id": "369", "text": "const shouldVirtualize = exceedsItemThreshold || exceedsHeightThreshold || memoryImpact === 'high'\n\n    return {\n      shouldVirtualize,\n      containerHeight: containerDimensions.height,\n      itemDimensions: { width: itemWidth, height: itemHeight },\n      metrics: {\n        itemCount,\n        estimatedUnvirtualizedHeight: estimatedHeight,\n        memoryImpact\n      }\n    }\n  }, [\n    itemCount,\n    itemHeight,\n    itemWidth,\n    containerDimensions,\n    mergedConfig\n  ])\n\n  return result\n}\n\n// Hook for automatic virtualization decision with performance logging\nexport function useSmartVirtualization(\n  itemCount: number,\n  itemHeight: number = 280,\n  itemWidth: number = 320,\n  config: Partial<VirtualizationConfig> = {}\n) {\n  const virtualization = useVirtualization(itemCount, itemHeight, itemWidth, config)", "metadata": {}}
{"id": "370", "text": "return result\n}\n\n// Hook for automatic virtualization decision with performance logging\nexport function useSmartVirtualization(\n  itemCount: number,\n  itemHeight: number = 280,\n  itemWidth: number = 320,\n  config: Partial<VirtualizationConfig> = {}\n) {\n  const virtualization = useVirtualization(itemCount, itemHeight, itemWidth, config)\n\n  // Log performance decision in development\n  useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      console.group('🎯 Smart Virtualization Decision')\n      console.log('Item Count:', itemCount)\n      console.log('Should Virtualize:', virtualization.shouldVirtualize)\n      console.log('Memory Impact:', virtualization.metrics.memoryImpact)\n      console.log('Estimated Height:', virtualization.metrics.estimatedUnvirtualizedHeight, 'px')\n      console.log('Reason:',\n        virtualization.shouldVirtualize\n          ? itemCount >= (config.itemThreshold || 50)\n            ? 'Item count threshold exceeded'\n            : 'Height threshold exceeded'\n          : 'No virtualization needed'\n      )\n      console.groupEnd()\n    }\n  }, [virtualization, itemCount, config.itemThreshold])", "metadata": {}}
{"id": "371", "text": "return virtualization\n}", "metadata": {}}
{"id": "372", "text": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}", "metadata": {}}
{"id": "373", "text": "import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.tsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n)", "metadata": {}}
{"id": "374", "text": "import { Album } from '../types'\n\n/**\n * Mock album data generator for development and testing\n */\nexport const mockAlbums: Album[] = [\n  {\n    id: 1,\n    name: 'Summer Vacation 2024',\n    captureDate: new Date('2024-07-15'),\n    displayOrder: 1,\n    thumbnailPhotoId: 1,\n    photoCount: 25,\n    createdAt: new Date('2024-07-15T10:30:00Z'),\n    updatedAt: new Date('2024-07-15T10:30:00Z'),\n  },\n  {\n    id: 2,\n    name: 'Spring Wedding',\n    captureDate: new Date('2024-05-20'),\n    displayOrder: 2,\n    thumbnailPhotoId: 26,\n    photoCount: 142,\n    createdAt: new Date('2024-05-20T14:00:00Z'),\n    updatedAt: new Date('2024-05-20T14:00:00Z'),", "metadata": {}}
{"id": "375", "text": "updatedAt: new Date('2024-07-15T10:30:00Z'),\n  },\n  {\n    id: 2,\n    name: 'Spring Wedding',\n    captureDate: new Date('2024-05-20'),\n    displayOrder: 2,\n    thumbnailPhotoId: 26,\n    photoCount: 142,\n    createdAt: new Date('2024-05-20T14:00:00Z'),\n    updatedAt: new Date('2024-05-20T14:00:00Z'),\n  },\n  {\n    id: 3,\n    name: 'Mountain Hiking Trip',\n    captureDate: new Date('2024-09-10'),\n    displayOrder: 3,\n    thumbnailPhotoId: 168,\n    photoCount: 67,\n    createdAt: new Date('2024-09-10T08:15:00Z'),\n    updatedAt: new Date('2024-09-10T08:15:00Z'),\n  },", "metadata": {}}
{"id": "376", "text": "updatedAt: new Date('2024-05-20T14:00:00Z'),\n  },\n  {\n    id: 3,\n    name: 'Mountain Hiking Trip',\n    captureDate: new Date('2024-09-10'),\n    displayOrder: 3,\n    thumbnailPhotoId: 168,\n    photoCount: 67,\n    createdAt: new Date('2024-09-10T08:15:00Z'),\n    updatedAt: new Date('2024-09-10T08:15:00Z'),\n  },\n  {\n    id: 4,\n    name: 'Family Reunion',\n    captureDate: new Date('2024-08-05'),\n    displayOrder: 4,\n    thumbnailPhotoId: 235,\n    photoCount: 89,\n    createdAt: new Date('2024-08-05T16:45:00Z'),\n    updatedAt: new Date('2024-08-05T16:45:00Z'),\n  },", "metadata": {}}
{"id": "377", "text": "updatedAt: new Date('2024-09-10T08:15:00Z'),\n  },\n  {\n    id: 4,\n    name: 'Family Reunion',\n    captureDate: new Date('2024-08-05'),\n    displayOrder: 4,\n    thumbnailPhotoId: 235,\n    photoCount: 89,\n    createdAt: new Date('2024-08-05T16:45:00Z'),\n    updatedAt: new Date('2024-08-05T16:45:00Z'),\n  },\n  {\n    id: 5,\n    name: 'City Architecture',\n    captureDate: new Date('2024-06-12'),\n    displayOrder: 5,\n    thumbnailPhotoId: 324,\n    photoCount: 34,\n    createdAt: new Date('2024-06-12T11:20:00Z'),\n    updatedAt: new Date('2024-06-12T11:20:00Z'),\n  },", "metadata": {}}
{"id": "378", "text": "updatedAt: new Date('2024-08-05T16:45:00Z'),\n  },\n  {\n    id: 5,\n    name: 'City Architecture',\n    captureDate: new Date('2024-06-12'),\n    displayOrder: 5,\n    thumbnailPhotoId: 324,\n    photoCount: 34,\n    createdAt: new Date('2024-06-12T11:20:00Z'),\n    updatedAt: new Date('2024-06-12T11:20:00Z'),\n  },\n  {\n    id: 6,\n    name: 'Beach Sunset',\n    captureDate: new Date('2024-07-28'),\n    displayOrder: 6,\n    thumbnailPhotoId: 358,\n    photoCount: 18,\n    createdAt: new Date('2024-07-28T19:30:00Z'),\n    updatedAt: new Date('2024-07-28T19:30:00Z'),\n  },\n]", "metadata": {}}
{"id": "379", "text": "},\n  {\n    id: 6,\n    name: 'Beach Sunset',\n    captureDate: new Date('2024-07-28'),\n    displayOrder: 6,\n    thumbnailPhotoId: 358,\n    photoCount: 18,\n    createdAt: new Date('2024-07-28T19:30:00Z'),\n    updatedAt: new Date('2024-07-28T19:30:00Z'),\n  },\n]\n\n/**\n * Generate additional mock albums for testing large lists\n * @param count - Number of additional albums to generate\n * @returns Array of generated mock albums\n */\nexport const generateMockAlbums = (count: number): Album[] => {\n  const baseAlbums = [...mockAlbums]\n  const generatedAlbums: Album[] = []", "metadata": {}}
{"id": "380", "text": "photoCount: 18,\n    createdAt: new Date('2024-07-28T19:30:00Z'),\n    updatedAt: new Date('2024-07-28T19:30:00Z'),\n  },\n]\n\n/**\n * Generate additional mock albums for testing large lists\n * @param count - Number of additional albums to generate\n * @returns Array of generated mock albums\n */\nexport const generateMockAlbums = (count: number): Album[] => {\n  const baseAlbums = [...mockAlbums]\n  const generatedAlbums: Album[] = []\n\n  for (let i = 0; i < count; i++) {\n    const albumId = baseAlbums.length + generatedAlbums.length + 1\n    const photoStartId = albumId * 100\n    const photoCount = Math.floor(Math.random() * 100) + 5 // 5-104 photos\n\n    // Generate random date within last 2 years\n    const randomDate = new Date()\n    randomDate.setDate(randomDate.getDate() - Math.floor(Math.random() * 730))", "metadata": {}}
{"id": "381", "text": "for (let i = 0; i < count; i++) {\n    const albumId = baseAlbums.length + generatedAlbums.length + 1\n    const photoStartId = albumId * 100\n    const photoCount = Math.floor(Math.random() * 100) + 5 // 5-104 photos\n\n    // Generate random date within last 2 years\n    const randomDate = new Date()\n    randomDate.setDate(randomDate.getDate() - Math.floor(Math.random() * 730))\n\n    const albumNames = [\n      'Nature Walk', 'Food Photography', 'Portrait Session', 'Travel Adventure',\n      'Street Photography', 'Landscape Views', 'Concert Night', 'Art Gallery Visit',\n      'Sports Event', 'Birthday Party', 'Holiday Celebration', 'Pets & Animals',\n      'Sunrise Session', 'Urban Exploration', 'Museum Trip', 'Garden Flowers',\n      'Winter Wonderland', 'Autumn Colors', 'Spring Blooms', 'Coffee Shop Vibes'\n    ]\n\n    const randomName = albumNames[Math.floor(Math.random() * albumNames.length)]", "metadata": {}}
{"id": "382", "text": "const albumNames = [\n      'Nature Walk', 'Food Photography', 'Portrait Session', 'Travel Adventure',\n      'Street Photography', 'Landscape Views', 'Concert Night', 'Art Gallery Visit',\n      'Sports Event', 'Birthday Party', 'Holiday Celebration', 'Pets & Animals',\n      'Sunrise Session', 'Urban Exploration', 'Museum Trip', 'Garden Flowers',\n      'Winter Wonderland', 'Autumn Colors', 'Spring Blooms', 'Coffee Shop Vibes'\n    ]\n\n    const randomName = albumNames[Math.floor(Math.random() * albumNames.length)]\n\n    generatedAlbums.push({\n      id: albumId,\n      name: `${randomName} ${albumId}`,\n      captureDate: randomDate,\n      displayOrder: albumId,\n      thumbnailPhotoId: photoStartId + 1,\n      photoCount,\n      createdAt: randomDate,\n      updatedAt: randomDate,\n    })\n  }\n\n  return [...baseAlbums, ...generatedAlbums]\n}", "metadata": {}}
{"id": "383", "text": "const randomName = albumNames[Math.floor(Math.random() * albumNames.length)]\n\n    generatedAlbums.push({\n      id: albumId,\n      name: `${randomName} ${albumId}`,\n      captureDate: randomDate,\n      displayOrder: albumId,\n      thumbnailPhotoId: photoStartId + 1,\n      photoCount,\n      createdAt: randomDate,\n      updatedAt: randomDate,\n    })\n  }\n\n  return [...baseAlbums, ...generatedAlbums]\n}\n\n/**\n * Get paginated albums for infinite scroll testing\n * @param page - Page number (0-based)\n * @param pageSize - Number of albums per page\n * @param totalAlbums - Total albums to generate if needed\n * @returns Object with albums array and pagination info\n */\nexport const getPaginatedAlbums = (\n  page: number = 0,\n  pageSize: number = 12,\n  totalAlbums: number = 100\n) => {\n  const allAlbums = generateMockAlbums(Math.max(0, totalAlbums - mockAlbums.length))\n  const startIndex = page * pageSize\n  const endIndex = startIndex + pageSize", "metadata": {}}
{"id": "384", "text": "const albums = allAlbums.slice(startIndex, endIndex)\n  const hasNextPage = endIndex < allAlbums.length\n  const totalPages = Math.ceil(allAlbums.length / pageSize)\n\n  return {\n    albums,\n    pagination: {\n      page,\n      pageSize,\n      totalAlbums: allAlbums.length,\n      totalPages,\n      hasNextPage,\n      hasPreviousPage: page > 0,\n    }\n  }\n}\n\n/**\n * Simulate API delay for realistic testing\n * @param albums - Albums to return after delay\n * @param delay - Delay in milliseconds (default: 300-800ms)\n * @returns Promise that resolves with albums after delay\n */\nexport const getMockAlbumsWithDelay = async (\n  albums: Album[] = mockAlbums,\n  delay?: number\n): Promise<Album[]> => {\n  const actualDelay = delay ?? Math.floor(Math.random() * 500) + 300\n\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(albums), actualDelay)\n  })\n}", "metadata": {}}
{"id": "385", "text": "/**\n * Simulate API delay for realistic testing\n * @param albums - Albums to return after delay\n * @param delay - Delay in milliseconds (default: 300-800ms)\n * @returns Promise that resolves with albums after delay\n */\nexport const getMockAlbumsWithDelay = async (\n  albums: Album[] = mockAlbums,\n  delay?: number\n): Promise<Album[]> => {\n  const actualDelay = delay ?? Math.floor(Math.random() * 500) + 300\n\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(albums), actualDelay)\n  })\n}\n\n/**\n * Find album by ID\n * @param id - Album ID to find\n * @param allAlbums - Optional custom album list\n * @returns Album if found, undefined otherwise\n */\nexport const findMockAlbumById = (\n  id: number,\n  allAlbums: Album[] = mockAlbums\n): Album | undefined => {\n  return allAlbums.find(album => album.id === id)\n}", "metadata": {}}
{"id": "386", "text": "import { http } from 'msw';\nimport { ImageService } from '../../src/services/imageService';\n\n// Mock image data for testing\nconst mockImages = [\n  {\n    id: '550e8400-e29b-41d4-a716-446655440000',\n    filename: 'sample-image.jpg',\n    path: '/images/sample-image.jpg',\n    url: 'https://picsum.photos/800/600?random=1',\n    caption: 'A beautiful landscape',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date('2024-01-15T10:30:00Z'),\n    capturedAt: new Date('2024-01-15T09:15:00Z'),\n    fileSize: 2457600,\n    width: 1920,\n    height: 1080,\n    mimeType: 'image/jpeg',\n    cameraModel: 'Canon EOS R5',\n    location: 'San Francisco, CA',\n    tags: ['landscape', 'nature', 'outdoor'],\n  },\n];", "metadata": {}}
{"id": "387", "text": "export const handlers = [\n  // GET /api/images/{id}\n  http.get('/api/images/:id', async (req, res, ctx) => {\n    const { id } = req.params;\n\n    try {\n      const image = await ImageService.getImage(id as string);\n\n      if (!image) {\n        return res(\n          ctx.status(404),\n          ctx.json({ error: 'Image not found' })\n        );\n      }\n\n      return res(\n        ctx.status(200),\n        ctx.json(image)\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),\n\n  // GET /api/images/{id}/file\n  http.get('/api/images/:id/file', async (req, res, ctx) => {\n    const { id } = req.params;\n\n    try {\n      const fileUrl = await ImageService.getImageFile(id as string);", "metadata": {}}
{"id": "388", "text": "return res(\n        ctx.status(200),\n        ctx.json(image)\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),\n\n  // GET /api/images/{id}/file\n  http.get('/api/images/:id/file', async (req, res, ctx) => {\n    const { id } = req.params;\n\n    try {\n      const fileUrl = await ImageService.getImageFile(id as string);\n\n      if (!fileUrl) {\n        return res(\n          ctx.status(404),\n          ctx.json({ error: 'Image file not found' })\n        );\n      }\n\n      // In a real implementation, this would serve the actual file\n      // For mock purposes, we'll return a redirect to the URL\n      return res(\n        ctx.status(200),\n        ctx.json({ url: fileUrl })\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),", "metadata": {}}
{"id": "389", "text": "if (!fileUrl) {\n        return res(\n          ctx.status(404),\n          ctx.json({ error: 'Image file not found' })\n        );\n      }\n\n      // In a real implementation, this would serve the actual file\n      // For mock purposes, we'll return a redirect to the URL\n      return res(\n        ctx.status(200),\n        ctx.json({ url: fileUrl })\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),\n\n  // PUT /api/images/{id}\n  http.put('/api/images/:id', async (req, res, ctx) => {\n    const { id } = req.params;\n\n    try {\n      const updates = await req.json();\n      const image = await ImageService.updateImage(id as string, updates);\n\n      if (!image) {\n        return res(\n          ctx.status(404),\n          ctx.json({ error: 'Image not found' })\n        );\n      }", "metadata": {}}
{"id": "390", "text": "// PUT /api/images/{id}\n  http.put('/api/images/:id', async (req, res, ctx) => {\n    const { id } = req.params;\n\n    try {\n      const updates = await req.json();\n      const image = await ImageService.updateImage(id as string, updates);\n\n      if (!image) {\n        return res(\n          ctx.status(404),\n          ctx.json({ error: 'Image not found' })\n        );\n      }\n\n      return res(\n        ctx.status(200),\n        ctx.json(image)\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),", "metadata": {}}
{"id": "391", "text": "try {\n      const updates = await req.json();\n      const image = await ImageService.updateImage(id as string, updates);\n\n      if (!image) {\n        return res(\n          ctx.status(404),\n          ctx.json({ error: 'Image not found' })\n        );\n      }\n\n      return res(\n        ctx.status(200),\n        ctx.json(image)\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),\n\n  // GET /api/images (for gallery)\n  http.get('/api/images', async (req, res, ctx) => {\n    try {\n      const url = new URL(req.url);\n      const limit = url.searchParams.get('limit') ? parseInt(url.searchParams.get('limit')!) : undefined;\n      const offset = url.searchParams.get('offset') ? parseInt(url.searchParams.get('offset')!) : undefined;\n      const sortBy = url.searchParams.get('sortBy') as any;\n      const sortOrder = url.searchParams.get('sortOrder') as any;\n      const tags = url.searchParams.get('tags')?.split(',') || undefined;\n      const uploadedBy = url.searchParams.get('uploadedBy') || undefined;", "metadata": {}}
{"id": "392", "text": "const result = await ImageService.getAllImages({\n        limit,\n        offset,\n        sortBy,\n        sortOrder,\n        tags,\n        uploadedBy,\n      });\n\n      return res(\n        ctx.status(200),\n        ctx.json(result)\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),\n\n  // POST /api/images/upload\n  http.post('/api/images/upload', async (req, res, ctx) => {\n    try {\n      // This would handle multipart/form-data in a real implementation\n      const formData = await req.formData();\n      const file = formData.get('file') as File;\n      const caption = formData.get('caption') as string;\n      const tags = formData.get('tags') as string;\n\n      if (!file) {\n        return res(\n          ctx.status(400),\n          ctx.json({ error: 'No file provided' })\n        );\n      }", "metadata": {}}
{"id": "393", "text": "// POST /api/images/upload\n  http.post('/api/images/upload', async (req, res, ctx) => {\n    try {\n      // This would handle multipart/form-data in a real implementation\n      const formData = await req.formData();\n      const file = formData.get('file') as File;\n      const caption = formData.get('caption') as string;\n      const tags = formData.get('tags') as string;\n\n      if (!file) {\n        return res(\n          ctx.status(400),\n          ctx.json({ error: 'No file provided' })\n        );\n      }\n\n      const image = await ImageService.uploadImage(file, {\n        caption: caption || undefined,\n        tags: tags ? tags.split(',') : undefined,\n      });\n\n      return res(\n        ctx.status(201),\n        ctx.json(image)\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),", "metadata": {}}
{"id": "394", "text": "if (!file) {\n        return res(\n          ctx.status(400),\n          ctx.json({ error: 'No file provided' })\n        );\n      }\n\n      const image = await ImageService.uploadImage(file, {\n        caption: caption || undefined,\n        tags: tags ? tags.split(',') : undefined,\n      });\n\n      return res(\n        ctx.status(201),\n        ctx.json(image)\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),\n\n  // DELETE /api/images/{id}\n  http.delete('/api/images/:id', async (req, res, ctx) => {\n    const { id } = req.params;\n\n    try {\n      const success = await ImageService.deleteImage(id as string);\n\n      if (!success) {\n        return res(\n          ctx.status(404),\n          ctx.json({ error: 'Image not found' })\n        );\n      }", "metadata": {}}
{"id": "395", "text": "// DELETE /api/images/{id}\n  http.delete('/api/images/:id', async (req, res, ctx) => {\n    const { id } = req.params;\n\n    try {\n      const success = await ImageService.deleteImage(id as string);\n\n      if (!success) {\n        return res(\n          ctx.status(404),\n          ctx.json({ error: 'Image not found' })\n        );\n      }\n\n      return res(\n        ctx.status(204)\n      );\n    } catch (error) {\n      return res(\n        ctx.status(500),\n        ctx.json({ error: 'Internal server error' })\n      );\n    }\n  }),\n];", "metadata": {}}
{"id": "396", "text": "import { Photo } from '../types'\n\n/**\n * Mock photo data generator for development and testing\n */\nexport const mockPhotos: Photo[] = [\n  {\n    id: 1,\n    filename: 'IMG_2024_0715_001.jpg',\n    albumId: 1,\n    fileData: new Blob(['mock-file-data-1'], { type: 'image/jpeg' }),\n    thumbnailData: new Blob(['mock-thumbnail-1'], { type: 'image/jpeg' }),\n    captureDate: new Date('2024-07-15T08:30:00Z'),\n    fileSize: 2458624,\n    width: 4032,\n    height: 3024,\n    uploadTimestamp: new Date('2024-07-15T10:30:00Z'),\n  },\n  {\n    id: 2,\n    filename: 'IMG_2024_0715_002.jpg',\n    albumId: 1,\n    fileData: new Blob(['mock-file-data-2'], { type: 'image/jpeg' }),", "metadata": {}}
{"id": "397", "text": "captureDate: new Date('2024-07-15T08:30:00Z'),\n    fileSize: 2458624,\n    width: 4032,\n    height: 3024,\n    uploadTimestamp: new Date('2024-07-15T10:30:00Z'),\n  },\n  {\n    id: 2,\n    filename: 'IMG_2024_0715_002.jpg',\n    albumId: 1,\n    fileData: new Blob(['mock-file-data-2'], { type: 'image/jpeg' }),\n    thumbnailData: new Blob(['mock-thumbnail-2'], { type: 'image/jpeg' }),\n    captureDate: new Date('2024-07-15T09:15:00Z'),\n    fileSize: 3125478,\n    width: 4032,\n    height: 3024,\n    uploadTimestamp: new Date('2024-07-15T10:30:00Z'),\n  },\n  {\n    id: 3,", "metadata": {}}
{"id": "398", "text": "fileData: new Blob(['mock-file-data-2'], { type: 'image/jpeg' }),\n    thumbnailData: new Blob(['mock-thumbnail-2'], { type: 'image/jpeg' }),\n    captureDate: new Date('2024-07-15T09:15:00Z'),\n    fileSize: 3125478,\n    width: 4032,\n    height: 3024,\n    uploadTimestamp: new Date('2024-07-15T10:30:00Z'),\n  },\n  {\n    id: 3,\n    filename: 'IMG_2024_0715_003.jpg',\n    albumId: 1,\n    fileData: new Blob(['mock-file-data-3'], { type: 'image/jpeg' }),\n    thumbnailData: new Blob(['mock-thumbnail-3'], { type: 'image/jpeg' }),\n    captureDate: new Date('2024-07-15T14:22:00Z'),\n    fileSize: 2897541,\n    width: 3024,", "metadata": {}}
{"id": "399", "text": "},\n  {\n    id: 3,\n    filename: 'IMG_2024_0715_003.jpg',\n    albumId: 1,\n    fileData: new Blob(['mock-file-data-3'], { type: 'image/jpeg' }),\n    thumbnailData: new Blob(['mock-thumbnail-3'], { type: 'image/jpeg' }),\n    captureDate: new Date('2024-07-15T14:22:00Z'),\n    fileSize: 2897541,\n    width: 3024,\n    height: 4032,\n    uploadTimestamp: new Date('2024-07-15T10:30:00Z'),\n  }\n]", "metadata": {}}
{"id": "400", "text": "jpg',\n    albumId: 1,\n    fileData: new Blob(['mock-file-data-3'], { type: 'image/jpeg' }),\n    thumbnailData: new Blob(['mock-thumbnail-3'], { type: 'image/jpeg' }),\n    captureDate: new Date('2024-07-15T14:22:00Z'),\n    fileSize: 2897541,\n    width: 3024,\n    height: 4032,\n    uploadTimestamp: new Date('2024-07-15T10:30:00Z'),\n  }\n]\n\n/**\n * Generate thumbnail URLs using placeholder image services\n * @param photoId - Photo ID for unique image generation\n * @param width - Thumbnail width (default: 300)\n * @param height - Thumbnail height (default: 200)\n * @returns URL string for placeholder thumbnail\n */\nexport const generateThumbnailUrl = (\n  photoId: number,\n  width: number = 300,\n  height: number = 200\n): string => {\n  // Using picsum.photos for realistic placeholder images\n  return `https://picsum.photos/${width}/${height}?random=${photoId}`\n}", "metadata": {}}
{"id": "401", "text": "}\n]\n\n/**\n * Generate thumbnail URLs using placeholder image services\n * @param photoId - Photo ID for unique image generation\n * @param width - Thumbnail width (default: 300)\n * @param height - Thumbnail height (default: 200)\n * @returns URL string for placeholder thumbnail\n */\nexport const generateThumbnailUrl = (\n  photoId: number,\n  width: number = 300,\n  height: number = 200\n): string => {\n  // Using picsum.photos for realistic placeholder images\n  return `https://picsum.photos/${width}/${height}?random=${photoId}`\n}\n\n/**\n * Generate full photo URLs using placeholder image services\n * @param photoId - Photo ID for unique image generation\n * @param width - Photo width (default: 1920)\n * @param height - Photo height (default: 1080)\n * @returns URL string for placeholder full photo\n */\nexport const generateFullPhotoUrl = (\n  photoId: number,\n  width: number = 1920,\n  height: number = 1080\n): string => {\n  return `https://picsum.photos/${width}/${height}?random=${photoId}`\n}", "metadata": {}}
{"id": "402", "text": "/**\n * Generate full photo URLs using placeholder image services\n * @param photoId - Photo ID for unique image generation\n * @param width - Photo width (default: 1920)\n * @param height - Photo height (default: 1080)\n * @returns URL string for placeholder full photo\n */\nexport const generateFullPhotoUrl = (\n  photoId: number,\n  width: number = 1920,\n  height: number = 1080\n): string => {\n  return `https://picsum.photos/${width}/${height}?random=${photoId}`\n}\n\n/**\n * Generate mock photos for a specific album\n * @param albumId - Album ID to generate photos for\n * @param count - Number of photos to generate\n * @param basePhotoId - Starting photo ID (optional)\n * @returns Array of generated mock photos\n */\nexport const generateMockPhotos = (\n  albumId: number,\n  count: number,\n  basePhotoId?: number\n): Photo[] => {\n  const startId = basePhotoId ?? (albumId * 1000)\n  const photos: Photo[] = []", "metadata": {}}
{"id": "403", "text": "/**\n * Generate mock photos for a specific album\n * @param albumId - Album ID to generate photos for\n * @param count - Number of photos to generate\n * @param basePhotoId - Starting photo ID (optional)\n * @returns Array of generated mock photos\n */\nexport const generateMockPhotos = (\n  albumId: number,\n  count: number,\n  basePhotoId?: number\n): Photo[] => {\n  const startId = basePhotoId ?? (albumId * 1000)\n  const photos: Photo[] = []\n\n  // Random photo dimensions for variety\n  const dimensions = [\n    { width: 4032, height: 3024 }, // Standard smartphone\n    { width: 3024, height: 4032 }, // Portrait smartphone\n    { width: 5472, height: 3648 }, // DSLR landscape\n    { width: 3648, height: 5472 }, // DSLR portrait\n    { width: 1920, height: 1080 }, // Standard HD\n  ]", "metadata": {}}
{"id": "404", "text": "// Random photo dimensions for variety\n  const dimensions = [\n    { width: 4032, height: 3024 }, // Standard smartphone\n    { width: 3024, height: 4032 }, // Portrait smartphone\n    { width: 5472, height: 3648 }, // DSLR landscape\n    { width: 3648, height: 5472 }, // DSLR portrait\n    { width: 1920, height: 1080 }, // Standard HD\n  ]\n\n  for (let i = 0; i < count; i++) {\n    const photoId = startId + i + 1\n    const dimension = dimensions[Math.floor(Math.random() * dimensions.length)]", "metadata": {}}
{"id": "405", "text": "for (let i = 0; i < count; i++) {\n    const photoId = startId + i + 1\n    const dimension = dimensions[Math.floor(Math.random() * dimensions.length)]\n\n    // Generate random capture date within album's date range\n    const baseDate = new Date(2024, 6, 15) // July 15, 2024\n    const randomHours = Math.floor(Math.random() * 12)\n    const randomMinutes = Math.floor(Math.random() * 60)\n    const captureDate = new Date(baseDate)\n    captureDate.setHours(8 + randomHours, randomMinutes, 0, 0)\n\n    // Generate realistic file sizes (2-8MB for high-res photos)\n    const fileSize = Math.floor(Math.random() * 6000000) + 2000000", "metadata": {}}
{"id": "406", "text": "// Generate realistic file sizes (2-8MB for high-res photos)\n    const fileSize = Math.floor(Math.random() * 6000000) + 2000000\n\n    photos.push({\n      id: photoId,\n      filename: `IMG_2024_${String(baseDate.getMonth() + 1).padStart(2, '0')}${String(baseDate.getDate()).padStart(2, '0')}_${String(i + 1).padStart(3, '0')}.jpg`,\n      albumId,\n      fileData: new Blob([`mock-file-data-${photoId}`], { type: 'image/jpeg' }),\n      thumbnailData: new Blob([`mock-thumbnail-${photoId}`], { type: 'image/jpeg' }),\n      captureDate,\n      fileSize,\n      width: dimension.width,\n      height: dimension.height,\n      uploadTimestamp: new Date('2024-07-15T10:30:00Z'),\n    })\n  }\n\n  return photos\n}", "metadata": {}}
{"id": "407", "text": "return photos\n}\n\n/**\n * Get paginated photos for infinite scroll testing\n * @param albumId - Album ID to get photos for\n * @param page - Page number (0-based)\n * @param pageSize - Number of photos per page\n * @param totalPhotos - Total photos to generate if needed\n * @returns Object with photos array and pagination info\n */\nexport const getPaginatedPhotos = (\n  albumId: number,\n  page: number = 0,\n  pageSize: number = 20,\n  totalPhotos: number = 100\n) => {\n  const allPhotos = generateMockPhotos(albumId, totalPhotos)\n  const startIndex = page * pageSize\n  const endIndex = startIndex + pageSize\n\n  const photos = allPhotos.slice(startIndex, endIndex)\n  const hasNextPage = endIndex < allPhotos.length\n  const totalPages = Math.ceil(allPhotos.length / pageSize)\n\n  return {\n    photos,\n    pagination: {\n      page,\n      pageSize,\n      totalPhotos: allPhotos.length,\n      totalPages,\n      hasNextPage,\n      hasPreviousPage: page > 0,\n    }\n  }\n}", "metadata": {}}
{"id": "408", "text": "const photos = allPhotos.slice(startIndex, endIndex)\n  const hasNextPage = endIndex < allPhotos.length\n  const totalPages = Math.ceil(allPhotos.length / pageSize)\n\n  return {\n    photos,\n    pagination: {\n      page,\n      pageSize,\n      totalPhotos: allPhotos.length,\n      totalPages,\n      hasNextPage,\n      hasPreviousPage: page > 0,\n    }\n  }\n}\n\n/**\n * Simulate API delay for realistic testing\n * @param photos - Photos to return after delay\n * @param delay - Delay in milliseconds (default: 200-600ms)\n * @returns Promise that resolves with photos after delay\n */\nexport const getMockPhotosWithDelay = async (\n  photos: Photo[] = mockPhotos,\n  delay?: number\n): Promise<Photo[]> => {\n  const actualDelay = delay ?? Math.floor(Math.random() * 400) + 200\n\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(photos), actualDelay)\n  })\n}", "metadata": {}}
{"id": "409", "text": "/**\n * Simulate API delay for realistic testing\n * @param photos - Photos to return after delay\n * @param delay - Delay in milliseconds (default: 200-600ms)\n * @returns Promise that resolves with photos after delay\n */\nexport const getMockPhotosWithDelay = async (\n  photos: Photo[] = mockPhotos,\n  delay?: number\n): Promise<Photo[]> => {\n  const actualDelay = delay ?? Math.floor(Math.random() * 400) + 200\n\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(photos), actualDelay)\n  })\n}\n\n/**\n * Find photos by album ID\n * @param albumId - Album ID to find photos for\n * @param allPhotos - Optional custom photo list\n * @returns Array of photos for the album\n */\nexport const findMockPhotosByAlbumId = (\n  albumId: number,\n  allPhotos: Photo[] = mockPhotos\n): Photo[] => {\n  return allPhotos.filter(photo => photo.albumId === albumId)\n}", "metadata": {}}
{"id": "410", "text": "return new Promise((resolve) => {\n    setTimeout(() => resolve(photos), actualDelay)\n  })\n}\n\n/**\n * Find photos by album ID\n * @param albumId - Album ID to find photos for\n * @param allPhotos - Optional custom photo list\n * @returns Array of photos for the album\n */\nexport const findMockPhotosByAlbumId = (\n  albumId: number,\n  allPhotos: Photo[] = mockPhotos\n): Photo[] => {\n  return allPhotos.filter(photo => photo.albumId === albumId)\n}\n\n/**\n * Find photo by ID\n * @param id - Photo ID to find\n * @param allPhotos - Optional custom photo list\n * @returns Photo if found, undefined otherwise\n */\nexport const findMockPhotoById = (\n  id: number,\n  allPhotos: Photo[] = mockPhotos\n): Photo | undefined => {\n  return allPhotos.find(photo => photo.id === id)\n}", "metadata": {}}
{"id": "411", "text": "/**\n * Find photo by ID\n * @param id - Photo ID to find\n * @param allPhotos - Optional custom photo list\n * @returns Photo if found, undefined otherwise\n */\nexport const findMockPhotoById = (\n  id: number,\n  allPhotos: Photo[] = mockPhotos\n): Photo | undefined => {\n  return allPhotos.find(photo => photo.id === id)\n}\n\n/**\n * Create blob URLs for photo display\n * @param photo - Photo object\n * @returns Object with thumbnail and full photo blob URLs\n */\nexport const createPhotoUrls = (photo: Photo) => {\n  return {\n    thumbnailUrl: URL.createObjectURL(photo.thumbnailData),\n    fullPhotoUrl: URL.createObjectURL(photo.fileData),\n  }\n}\n\n/**\n * Cleanup blob URLs to prevent memory leaks\n * @param urls - Array of blob URLs to revoke\n */\nexport const cleanupPhotoUrls = (urls: string[]) => {\n  urls.forEach(url => {\n    if (url.startsWith('blob:')) {\n      URL.revokeObjectURL(url)\n    }\n  })\n}", "metadata": {}}
{"id": "412", "text": "/**\n * Cleanup blob URLs to prevent memory leaks\n * @param urls - Array of blob URLs to revoke\n */\nexport const cleanupPhotoUrls = (urls: string[]) => {\n  urls.forEach(url => {\n    if (url.startsWith('blob:')) {\n      URL.revokeObjectURL(url)\n    }\n  })\n}\n\n/**\n * Mock photo factory for testing with realistic data\n * @param overrides - Properties to override in the mock photo\n * @param useRealUrls - Whether to use placeholder service URLs\n * @returns Mock photo object\n */\nexport const createMockPhotoForTesting = (\n  overrides: Partial<Photo> = {},\n  _useRealUrls: boolean = false\n): Photo => {\n  const photoId = overrides.id ?? 1\n  const mockBlob = new Blob(['test'], { type: 'image/jpeg' })", "metadata": {}}
{"id": "413", "text": "/**\n * Mock photo factory for testing with realistic data\n * @param overrides - Properties to override in the mock photo\n * @param useRealUrls - Whether to use placeholder service URLs\n * @returns Mock photo object\n */\nexport const createMockPhotoForTesting = (\n  overrides: Partial<Photo> = {},\n  _useRealUrls: boolean = false\n): Photo => {\n  const photoId = overrides.id ?? 1\n  const mockBlob = new Blob(['test'], { type: 'image/jpeg' })\n\n  const basePhoto: Photo = {\n    id: photoId,\n    filename: `test-photo-${photoId}.jpg`,\n    albumId: 1,\n    fileData: mockBlob,\n    thumbnailData: mockBlob,\n    captureDate: new Date('2024-09-15T12:00:00Z'),\n    fileSize: 1024000,\n    width: 1920,\n    height: 1080,\n    uploadTimestamp: new Date('2024-09-15T10:00:00Z'),\n  }\n\n  return { ...basePhoto, ...overrides }\n}", "metadata": {}}
{"id": "414", "text": "import React, { useState, useEffect } from 'react';\nimport { Image, User } from '../types';\nimport { ImageGallery } from '../components/ImageGallery/ImageGallery';\nimport { ImageDetailModal } from '../components/ImageDetailModal/ImageDetailModal';\nimport { useImageDetail } from '../hooks/useImageDetail';\nimport { ImageService } from '../services/imageService';\nimport { Button } from '../components/ui/button';\nimport { Input } from '../components/ui/input';\nimport { Search, Upload, Filter } from 'lucide-react';\n\ninterface GalleryPageProps {\n  className?: string;\n}\n\nexport function GalleryPage({ className = '' }: GalleryPageProps) {\n  const [images, setImages] = useState<Image[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedUser, setSelectedUser] = useState<User | null>(null);\n  const { state, openDetail, closeDetail } = useImageDetail();", "metadata": {}}
{"id": "415", "text": "interface GalleryPageProps {\n  className?: string;\n}\n\nexport function GalleryPage({ className = '' }: GalleryPageProps) {\n  const [images, setImages] = useState<Image[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedUser, setSelectedUser] = useState<User | null>(null);\n  const { state, openDetail, closeDetail } = useImageDetail();\n\n  // Load images on component mount\n  useEffect(() => {\n    loadImages();\n  }, []);\n\n  // Load user when modal opens with image\n  useEffect(() => {\n    if (state.isOpen && state.selectedImage && !selectedUser) {\n      loadUser(state.selectedImage.uploadedBy);\n    }\n  }, [state.isOpen, state.selectedImage, selectedUser]);", "metadata": {}}
{"id": "416", "text": "// Load images on component mount\n  useEffect(() => {\n    loadImages();\n  }, []);\n\n  // Load user when modal opens with image\n  useEffect(() => {\n    if (state.isOpen && state.selectedImage && !selectedUser) {\n      loadUser(state.selectedImage.uploadedBy);\n    }\n  }, [state.isOpen, state.selectedImage, selectedUser]);\n\n  const loadImages = async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await ImageService.getAllImages();\n      setImages(result.images);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load images');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const loadUser = async (userId: string) => {\n    try {\n      const user = await ImageService.getUser(userId);\n      setSelectedUser(user);\n    } catch (err) {\n      console.error('Failed to load user:', err);\n    }\n  };\n\n  const handleImageClick = (image: Image) => {\n    openDetail(image);\n  };", "metadata": {}}
{"id": "417", "text": "const loadUser = async (userId: string) => {\n    try {\n      const user = await ImageService.getUser(userId);\n      setSelectedUser(user);\n    } catch (err) {\n      console.error('Failed to load user:', err);\n    }\n  };\n\n  const handleImageClick = (image: Image) => {\n    openDetail(image);\n  };\n\n  const handleSearch = async () => {\n    if (!searchQuery.trim()) {\n      loadImages();\n      return;\n    }\n\n    setLoading(true);\n    try {\n      const searchResults = await ImageService.searchImages(searchQuery);\n      setImages(searchResults);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Search failed');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleUpload = () => {\n    // This would open an upload dialog\n    console.log('Upload functionality to be implemented');\n  };\n\n  const filteredImages = images; // Add more filtering logic as needed", "metadata": {}}
{"id": "418", "text": "setLoading(true);\n    try {\n      const searchResults = await ImageService.searchImages(searchQuery);\n      setImages(searchResults);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Search failed');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleUpload = () => {\n    // This would open an upload dialog\n    console.log('Upload functionality to be implemented');\n  };\n\n  const filteredImages = images; // Add more filtering logic as needed\n\n  return (\n    <div className={`min-h-screen bg-background ${className}`}>\n      {/* Header */}\n      <header className=\"border-b bg-card\">\n        <div className=\"container mx-auto px-4 py-6\">\n          <div className=\"flex flex-col md:flex-row md:items-center justify-between gap-4\">\n            <div>\n              <h1 className=\"text-2xl font-bold\">Photo Gallery</h1>\n              <p className=\"text-muted-foreground mt-1\">\n                {images.length} {images.length === 1 ?", "metadata": {}}
{"id": "419", "text": "return (\n    <div className={`min-h-screen bg-background ${className}`}>\n      {/* Header */}\n      <header className=\"border-b bg-card\">\n        <div className=\"container mx-auto px-4 py-6\">\n          <div className=\"flex flex-col md:flex-row md:items-center justify-between gap-4\">\n            <div>\n              <h1 className=\"text-2xl font-bold\">Photo Gallery</h1>\n              <p className=\"text-muted-foreground mt-1\">\n                {images.length} {images.length === 1 ? 'photo' : 'photos'}\n              </p>\n            </div>\n            \n            <div className=\"flex flex-col sm:flex-row gap-3\">\n              <div className=\"relative\">\n                <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground h-4 w-4\" />\n                <Input\n                  type=\"text\"\n                  placeholder=\"Search photos...\"\n                  value={searchQuery}\n                  onChange={(e) => setSearchQuery(e.target.value)}\n                  onKeyDown={(e) => e.key === 'Enter' && handleSearch()}\n                  className=\"pl-10 w-full sm:w-64\"\n                />\n              </div>\n              \n              <Button onClick={handleSearch} variant=\"outline\">\n                Search\n              </Button>\n              \n              <Button onClick={handleUpload}>\n                <Upload className=\"h-4 w-4 mr-2\" />\n                Upload\n              </Button>\n            </div>\n          </div>\n        </div>\n      </header>", "metadata": {}}
{"id": "420", "text": "{/* Main Content */}\n      <main className=\"container mx-auto px-4 py-8\">\n        {/* Filters and Controls */}\n        <div className=\"mb-6 flex flex-wrap items-center gap-4\">\n          <Button variant=\"outline\" size=\"sm\">\n            <Filter className=\"h-4 w-4 mr-2\" />\n            Filters\n          </Button>\n          \n          <div className=\"flex gap-2\">\n            <Button variant=\"ghost\" size=\"sm\">\n              All\n            </Button>\n            <Button variant=\"ghost\" size=\"sm\">\n              Recent\n            </Button>\n            <Button variant=\"ghost\" size=\"sm\">\n              Favorites\n            </Button>\n          </div>\n        </div>\n\n        {/* Gallery */}\n        <ImageGallery\n          images={filteredImages}\n          loading={loading}\n          error={error}\n          onImageClick={handleImageClick}\n        />", "metadata": {}}
{"id": "421", "text": "{/* Gallery */}\n        <ImageGallery\n          images={filteredImages}\n          loading={loading}\n          error={error}\n          onImageClick={handleImageClick}\n        />\n\n        {/* Empty State */}\n        {!loading && !error && filteredImages.length === 0 && (\n          <div className=\"text-center py-12\">\n            <div className=\"text-6xl mb-4\">📷</div>\n            <h2 className=\"text-xl font-semibold mb-2\">No photos found</h2>\n            <p className=\"text-muted-foreground mb-4\">\n              {searchQuery \n                ? 'No photos match your search.' \n                : 'Start by uploading some photos!'\n              }\n            </p>\n            {!searchQuery && (\n              <Button onClick={handleUpload}>\n                <Upload className=\"h-4 w-4 mr-2\" />\n                Upload Photos\n              </Button>\n            )}\n          </div>\n        )}\n      </main>", "metadata": {}}
{"id": "422", "text": "{/* Image Detail Modal */}\n      <ImageDetailModal\n        isOpen={state.isOpen}\n        onClose={closeDetail}\n        image={state.selectedImage}\n        user={selectedUser}\n      />\n    </div>\n  );\n}\n\n// Export a default version\nexport default GalleryPage;", "metadata": {}}
{"id": "423", "text": "import { useEffect, useState } from 'react'\nimport { ViewState, Photo } from '../types'\nimport AlbumGrid from '../components/AlbumGrid'\nimport PhotoTileView from '../components/PhotoTileView'\nimport ZoomModal from '../components/ZoomModal'\nimport UploadDropzone from '../components/UploadDropzone'\nimport { Spinner } from '../components/ui/spinner'\nimport { mockDataService } from '../services/MockDataService'\nimport { useInfiniteAlbums } from '../hooks/useInfiniteAlbums'\nimport { useRetry } from '../hooks/useRetry'\n\ninterface LandingPageProps {\n  viewState: ViewState\n  onAlbumClick: (albumId: number) => void\n  onPhotoClick: (photoId: number) => void\n  onCloseZoom: () => void\n}", "metadata": {}}
{"id": "424", "text": "interface LandingPageProps {\n  viewState: ViewState\n  onAlbumClick: (albumId: number) => void\n  onPhotoClick: (photoId: number) => void\n  onCloseZoom: () => void\n}\n\nconst LandingPage = ({\n  viewState,\n  onAlbumClick,\n  onPhotoClick,\n  onCloseZoom\n}: LandingPageProps) => {\n  const {\n    albums,\n    loading: albumsLoading,\n    error: albumsError,\n    hasNextPage,\n    triggerRef,\n    refresh: refreshAlbums,\n    retrying,\n    retryCount,\n    retry\n  } = useInfiniteAlbums(12)\n\n  const [photos, setPhotos] = useState<Photo[]>([])\n  const [photosLoading, setPhotosLoading] = useState(false)\n  const [photosError, setPhotosError] = useState<string | null>(null)\n  const [selectedPhoto, setSelectedPhoto] = useState<Photo | null>(null)", "metadata": {}}
{"id": "425", "text": "const [photos, setPhotos] = useState<Photo[]>([])\n  const [photosLoading, setPhotosLoading] = useState(false)\n  const [photosError, setPhotosError] = useState<string | null>(null)\n  const [selectedPhoto, setSelectedPhoto] = useState<Photo | null>(null)\n\n  // Retry logic for photo loading\n  const { execute: executePhotoLoad, retrying: photosRetrying, retryCount: photosRetryCount } = useRetry<Photo[]>({\n    maxRetries: 3,\n    initialDelay: 500,\n    backoffFactor: 1.5,\n  })\n\n  useEffect(() => {\n    const loadPhotos = async () => {\n      if (!viewState.selectedAlbumId) return\n\n      setPhotosLoading(true)\n      setPhotosError(null)", "metadata": {}}
{"id": "426", "text": "// Retry logic for photo loading\n  const { execute: executePhotoLoad, retrying: photosRetrying, retryCount: photosRetryCount } = useRetry<Photo[]>({\n    maxRetries: 3,\n    initialDelay: 500,\n    backoffFactor: 1.5,\n  })\n\n  useEffect(() => {\n    const loadPhotos = async () => {\n      if (!viewState.selectedAlbumId) return\n\n      setPhotosLoading(true)\n      setPhotosError(null)\n\n      try {\n        const photosData = await executePhotoLoad(() =>\n          mockDataService.getPhotosInAlbum(viewState.selectedAlbumId!)\n        )\n        setPhotos(photosData)\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Failed to load photos'\n        setPhotosError(errorMessage)\n        console.error('Failed to load photos:', error)\n      } finally {\n        setPhotosLoading(false)\n      }\n    }", "metadata": {}}
{"id": "427", "text": "setPhotosLoading(true)\n      setPhotosError(null)\n\n      try {\n        const photosData = await executePhotoLoad(() =>\n          mockDataService.getPhotosInAlbum(viewState.selectedAlbumId!)\n        )\n        setPhotos(photosData)\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Failed to load photos'\n        setPhotosError(errorMessage)\n        console.error('Failed to load photos:', error)\n      } finally {\n        setPhotosLoading(false)\n      }\n    }\n\n    if (viewState.currentView === 'photos' && viewState.selectedAlbumId) {\n      loadPhotos()\n    }\n  }, [viewState.currentView, viewState.selectedAlbumId, executePhotoLoad])\n\n  useEffect(() => {\n    const loadSelectedPhoto = async () => {\n      if (!viewState.selectedPhotoId) return\n\n      try {\n        const photoData = await mockDataService.getFullPhoto(viewState.selectedPhotoId)\n        setSelectedPhoto(photoData)\n      } catch (error) {\n        console.error('Failed to load photo:', error)\n        setSelectedPhoto(null)\n      }\n    }", "metadata": {}}
{"id": "428", "text": "if (viewState.currentView === 'photos' && viewState.selectedAlbumId) {\n      loadPhotos()\n    }\n  }, [viewState.currentView, viewState.selectedAlbumId, executePhotoLoad])\n\n  useEffect(() => {\n    const loadSelectedPhoto = async () => {\n      if (!viewState.selectedPhotoId) return\n\n      try {\n        const photoData = await mockDataService.getFullPhoto(viewState.selectedPhotoId)\n        setSelectedPhoto(photoData)\n      } catch (error) {\n        console.error('Failed to load photo:', error)\n        setSelectedPhoto(null)\n      }\n    }\n\n    if (viewState.isZoomModalOpen && viewState.selectedPhotoId) {\n      loadSelectedPhoto()\n    } else {\n      setSelectedPhoto(null)\n    }\n  }, [viewState.isZoomModalOpen, viewState.selectedPhotoId])", "metadata": {}}
{"id": "429", "text": "try {\n        const photoData = await mockDataService.getFullPhoto(viewState.selectedPhotoId)\n        setSelectedPhoto(photoData)\n      } catch (error) {\n        console.error('Failed to load photo:', error)\n        setSelectedPhoto(null)\n      }\n    }\n\n    if (viewState.isZoomModalOpen && viewState.selectedPhotoId) {\n      loadSelectedPhoto()\n    } else {\n      setSelectedPhoto(null)\n    }\n  }, [viewState.isZoomModalOpen, viewState.selectedPhotoId])\n\n  const handleAlbumReorder = async (albumId: number, newOrder: number) => {\n    try {\n      await mockDataService.updateAlbumOrder(albumId, newOrder)\n      // Refresh albums to reflect the new order\n      await refreshAlbums()\n    } catch (error) {\n      console.error('Failed to reorder album:', error)\n    }\n  }", "metadata": {}}
{"id": "430", "text": "if (viewState.isZoomModalOpen && viewState.selectedPhotoId) {\n      loadSelectedPhoto()\n    } else {\n      setSelectedPhoto(null)\n    }\n  }, [viewState.isZoomModalOpen, viewState.selectedPhotoId])\n\n  const handleAlbumReorder = async (albumId: number, newOrder: number) => {\n    try {\n      await mockDataService.updateAlbumOrder(albumId, newOrder)\n      // Refresh albums to reflect the new order\n      await refreshAlbums()\n    } catch (error) {\n      console.error('Failed to reorder album:', error)\n    }\n  }\n\n  const handleFilesSelected = async (files: FileList) => {\n    try {\n      await mockDataService.uploadPhotos(Array.from(files))\n      // Refresh albums to show any new albums created\n      await refreshAlbums()\n    } catch (error) {\n      console.error('Failed to upload files:', error)\n    }\n  }\n\n  const getCurrentPhotoIndex = () => {\n    if (!selectedPhoto) return 0\n    return photos.findIndex(photo => photo.id === selectedPhoto.id)\n  }", "metadata": {}}
{"id": "431", "text": "const handleFilesSelected = async (files: FileList) => {\n    try {\n      await mockDataService.uploadPhotos(Array.from(files))\n      // Refresh albums to show any new albums created\n      await refreshAlbums()\n    } catch (error) {\n      console.error('Failed to upload files:', error)\n    }\n  }\n\n  const getCurrentPhotoIndex = () => {\n    if (!selectedPhoto) return 0\n    return photos.findIndex(photo => photo.id === selectedPhoto.id)\n  }\n\n  const handleNext = () => {\n    const currentIndex = getCurrentPhotoIndex()\n    const nextIndex = (currentIndex + 1) % photos.length\n    onPhotoClick(photos[nextIndex].id)\n  }\n\n  const handlePrevious = () => {\n    const currentIndex = getCurrentPhotoIndex()\n    const prevIndex = currentIndex === 0 ? photos.length - 1 : currentIndex - 1\n    onPhotoClick(photos[prevIndex].id)\n  }", "metadata": {}}
{"id": "432", "text": "const handleNext = () => {\n    const currentIndex = getCurrentPhotoIndex()\n    const nextIndex = (currentIndex + 1) % photos.length\n    onPhotoClick(photos[nextIndex].id)\n  }\n\n  const handlePrevious = () => {\n    const currentIndex = getCurrentPhotoIndex()\n    const prevIndex = currentIndex === 0 ? photos.length - 1 : currentIndex - 1\n    onPhotoClick(photos[prevIndex].id)\n  }\n\n  return (\n    <div className=\"space-y-8\">\n      {/* Upload Dropzone - always visible */}\n      <UploadDropzone\n        onFilesSelected={handleFilesSelected}\n        acceptedFileTypes={['.jpg', '.jpeg', '.png', '.webp', '.heic']}\n        className=\"mb-8\"\n        data-testid=\"upload-dropzone\"\n      />", "metadata": {}}
{"id": "433", "text": "return (\n    <div className=\"space-y-8\">\n      {/* Upload Dropzone - always visible */}\n      <UploadDropzone\n        onFilesSelected={handleFilesSelected}\n        acceptedFileTypes={['.jpg', '.jpeg', '.png', '.webp', '.heic']}\n        className=\"mb-8\"\n        data-testid=\"upload-dropzone\"\n      />\n\n      {/* Main Content Area */}\n      {viewState.currentView === 'albums' && (\n        <div className=\"space-y-6\">\n          <div className=\"flex justify-between items-center\">\n            <h2 className=\"text-3xl font-bold text-gray-900\">Photo Albums</h2>\n            <span className=\"text-gray-500\">\n              {albums.length} {albums.length === 1 ? 'album' : 'albums'}\n            </span>\n          </div>", "metadata": {}}
{"id": "434", "text": "{/* Main Content Area */}\n      {viewState.currentView === 'albums' && (\n        <div className=\"space-y-6\">\n          <div className=\"flex justify-between items-center\">\n            <h2 className=\"text-3xl font-bold text-gray-900\">Photo Albums</h2>\n            <span className=\"text-gray-500\">\n              {albums.length} {albums.length === 1 ? 'album' : 'albums'}\n            </span>\n          </div>\n\n          <AlbumGrid\n            albums={albums}\n            onAlbumClick={onAlbumClick}\n            onAlbumReorder={handleAlbumReorder}\n            loading={albumsLoading && albums.length === 0}\n            className=\"responsive-grid\"\n            data-testid=\"album-grid\"\n          />\n\n          {/* Infinite Scroll Trigger */}\n          {hasNextPage && (\n            <div\n              ref={triggerRef as React.RefObject<HTMLDivElement>}\n              className=\"flex justify-center items-center py-8\"\n              data-testid=\"infinite-scroll-trigger\"\n              role=\"status\"\n              aria-live=\"polite\"\n              aria-label={albumsLoading ?", "metadata": {}}
{"id": "435", "text": "{/* Infinite Scroll Trigger */}\n          {hasNextPage && (\n            <div\n              ref={triggerRef as React.RefObject<HTMLDivElement>}\n              className=\"flex justify-center items-center py-8\"\n              data-testid=\"infinite-scroll-trigger\"\n              role=\"status\"\n              aria-live=\"polite\"\n              aria-label={albumsLoading ? \"Loading more albums\" : \"Scroll to load more albums\"}\n            >\n              {albumsLoading ? (\n                <div className=\"flex items-center space-x-2\">\n                  <Spinner size=\"md\" />\n                  <span className=\"text-muted-foreground\">Loading more albums...</span>\n                  <div className=\"sr-only\">\n                    Loading page {Math.ceil(albums.length / 12) + 1} of albums\n                  </div>\n                </div>\n              ) : (\n                <button\n                  onClick={async () => {\n                    try {\n                      // Focus on the newly loaded content after loading\n                      const currentCount = albums.length\n                      await refreshAlbums()\n                      // After new content loads,", "metadata": {}}
{"id": "436", "text": "..</span>\n                  <div className=\"sr-only\">\n                    Loading page {Math.ceil(albums.length / 12) + 1} of albums\n                  </div>\n                </div>\n              ) : (\n                <button\n                  onClick={async () => {\n                    try {\n                      // Focus on the newly loaded content after loading\n                      const currentCount = albums.length\n                      await refreshAlbums()\n                      // After new content loads, focus on first new album\n                      setTimeout(() => {\n                        const newAlbums = document.querySelectorAll('[data-testid^=\"album-tile-\"]')\n                        const firstNewAlbum = newAlbums[currentCount] as HTMLElement\n                        if (firstNewAlbum) {\n                          firstNewAlbum.focus()\n                        }\n                      }, 100)\n                    } catch (error) {\n                      console.error('Failed to load more albums:',", "metadata": {}}
{"id": "437", "text": "length\n                      await refreshAlbums()\n                      // After new content loads, focus on first new album\n                      setTimeout(() => {\n                        const newAlbums = document.querySelectorAll('[data-testid^=\"album-tile-\"]')\n                        const firstNewAlbum = newAlbums[currentCount] as HTMLElement\n                        if (firstNewAlbum) {\n                          firstNewAlbum.focus()\n                        }\n                      }, 100)\n                    } catch (error) {\n                      console.error('Failed to load more albums:', error)\n                    }\n                  }}\n                  className=\"text-blue-600 hover:text-blue-800 underline focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 rounded px-2 py-1\"\n                  aria-describedby=\"load-more-description\"\n                >\n                  Load more albums\n                </button>\n              )}\n              <div id=\"load-more-description\" className=\"sr-only\">\n                Use this button to manually load more albums, or scroll down to automatically load them\n              </div>\n            </div>\n          )}", "metadata": {}}
{"id": "438", "text": "error('Failed to load more albums:', error)\n                    }\n                  }}\n                  className=\"text-blue-600 hover:text-blue-800 underline focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 rounded px-2 py-1\"\n                  aria-describedby=\"load-more-description\"\n                >\n                  Load more albums\n                </button>\n              )}\n              <div id=\"load-more-description\" className=\"sr-only\">\n                Use this button to manually load more albums, or scroll down to automatically load them\n              </div>\n            </div>\n          )}\n\n          {/* Error and retry state */}\n          {albumsError && (\n            <div className=\"text-center py-4 space-y-3\">\n              <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\n                <div className=\"flex items-center justify-center space-x-2 mb-2\">\n                  <svg className=\"w-5 h-5 text-red-500\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                    <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.", "metadata": {}}
{"id": "439", "text": "707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.", "metadata": {}}
{"id": "440", "text": "707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\" clipRule=\"evenodd\" />\n                  </svg>\n                  <p className=\"text-red-800 font-medium\">Failed to load albums</p>\n                </div>\n                <p className=\"text-red-600 text-sm mb-3\">{albumsError}</p>\n                {retryCount > 0 && (\n                  <p className=\"text-red-500 text-xs mb-3\">\n                    Retry attempt {retryCount} of 3\n                  </p>\n                )}\n                <div className=\"flex justify-center space-x-2\">\n                  <button\n                    onClick={retry}\n                    disabled={retrying}\n                    className=\"px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2\"\n                  >\n                    {retrying ?", "metadata": {}}
{"id": "441", "text": "(\n                      <>\n                        <Spinner size=\"sm\" />\n                        <span>Retrying...</span>\n                      </>\n                    ) : (\n                      <span>Try Again</span>\n                    )}\n                  </button>\n                  <button\n                    onClick={refreshAlbums}\n                    disabled={retrying || albumsLoading}\n                    className=\"px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed\"\n                  >\n                    Refresh\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n\n      {viewState.currentView === 'photos' && viewState.", "metadata": {}}
{"id": "442", "text": "{viewState.currentView === 'photos' && viewState.selectedAlbumId && (\n        <div className=\"space-y-6\">\n          {/* Photo error and retry state */}\n          {photosError && (\n            <div className=\"text-center py-4\">\n              <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\n                <div className=\"flex items-center justify-center space-x-2 mb-2\">\n                  <svg className=\"w-5 h-5 text-red-500\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                    <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.", "metadata": {}}
{"id": "443", "text": "707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.", "metadata": {}}
{"id": "444", "text": "707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\" clipRule=\"evenodd\" />\n                  </svg>\n                  <p className=\"text-red-800 font-medium\">Failed to load photos</p>\n                </div>\n                <p className=\"text-red-600 text-sm mb-3\">{photosError}</p>\n                {photosRetryCount > 0 && (\n                  <p className=\"text-red-500 text-xs mb-3\">\n                    Retry attempt {photosRetryCount} of 3\n                  </p>\n                )}\n                <div className=\"flex justify-center\">\n                  <button\n                    onClick={() => window.", "metadata": {}}
{"id": "445", "text": "586 8.707 7.293z\" clipRule=\"evenodd\" />\n                  </svg>\n                  <p className=\"text-red-800 font-medium\">Failed to load photos</p>\n                </div>\n                <p className=\"text-red-600 text-sm mb-3\">{photosError}</p>\n                {photosRetryCount > 0 && (\n                  <p className=\"text-red-500 text-xs mb-3\">\n                    Retry attempt {photosRetryCount} of 3\n                  </p>\n                )}\n                <div className=\"flex justify-center\">\n                  <button\n                    onClick={() => window.location.reload()}\n                    disabled={photosRetrying}\n                    className=\"px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2\"\n                  >\n                    {photosRetrying ?", "metadata": {}}
{"id": "446", "text": "location.reload()}\n                    disabled={photosRetrying}\n                    className=\"px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2\"\n                  >\n                    {photosRetrying ? (\n                      <>\n                        <Spinner size=\"sm\" />\n                        <span>Retrying...</span>\n                      </>\n                    ) : (\n                      <span>Try Again</span>\n                    )}\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n\n          <PhotoTileView\n            photos={photos}\n            onPhotoClick={onPhotoClick}\n            loading={photosLoading || photosRetrying}\n            selectedPhotoId={viewState.selectedPhotoId}\n            className=\"responsive-grid\"\n            data-testid=\"photo-tile-view\"\n          />\n        </div>\n      )}", "metadata": {}}
{"id": "447", "text": "(\n                      <>\n                        <Spinner size=\"sm\" />\n                        <span>Retrying...</span>\n                      </>\n                    ) : (\n                      <span>Try Again</span>\n                    )}\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n\n          <PhotoTileView\n            photos={photos}\n            onPhotoClick={onPhotoClick}\n            loading={photosLoading || photosRetrying}\n            selectedPhotoId={viewState.selectedPhotoId}\n            className=\"responsive-grid\"\n            data-testid=\"photo-tile-view\"\n          />\n        </div>\n      )}\n\n      {/* Zoom Modal */}\n      <ZoomModal\n        isOpen={viewState.isZoomModalOpen}\n        onClose={onCloseZoom}\n        photo={selectedPhoto}\n        photos={photos}\n        currentIndex={getCurrentPhotoIndex()}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        data-testid=\"zoom-modal\"\n      />\n    </div>\n  )\n}\n\nexport default LandingPage", "metadata": {}}
{"id": "448", "text": "import { Album, Photo, UploadSession, PhotoService, PaginatedResponse, PaginationInfo } from '../types'\n\nexport class MockDataService implements PhotoService {\n  private albums: Album[] = []\n  private photos: Photo[] = []\n  private nextAlbumId: number = 1\n  private nextPhotoId: number = 1\n\n  constructor() {\n    // Start with empty state to match test expectations\n    // Mock data will be generated on demand for demo purposes\n  }\n\n  /**\n   * Generate mock data for demo/testing purposes\n   */\n  public generateDemoData(albumCount: number = 50) {\n    this.albums = []\n    this.photos = []\n    this.nextAlbumId = 1\n    this.nextPhotoId = 1\n    this.generateMockData(albumCount)\n  }\n\n  private generateMockData(albumCount: number) {\n    const baseDate = new Date('2024-01-01')", "metadata": {}}
{"id": "449", "text": "constructor() {\n    // Start with empty state to match test expectations\n    // Mock data will be generated on demand for demo purposes\n  }\n\n  /**\n   * Generate mock data for demo/testing purposes\n   */\n  public generateDemoData(albumCount: number = 50) {\n    this.albums = []\n    this.photos = []\n    this.nextAlbumId = 1\n    this.nextPhotoId = 1\n    this.generateMockData(albumCount)\n  }\n\n  private generateMockData(albumCount: number) {\n    const baseDate = new Date('2024-01-01')\n\n    for (let i = 0; i < albumCount; i++) {\n      const captureDate = new Date(baseDate.getTime() + i * 24 * 60 * 60 * 1000) // Daily intervals\n      const album: Album = {\n        id: this.nextAlbumId++,\n        name: this.generateAlbumName(captureDate),\n        captureDate,\n        displayOrder: i + 1,\n        thumbnailPhotoId: null,\n        photoCount: Math.floor(Math.random() * 20) + 5, // 5-24 photos per album\n        createdAt: captureDate,\n        updatedAt: captureDate\n      }", "metadata": {}}
{"id": "450", "text": "this.albums.push(album)\n\n      // Generate photos for this album\n      for (let j = 0; j < album.photoCount; j++) {\n        const photo: Photo = {\n          id: this.nextPhotoId++,\n          filename: `IMG_${String(this.nextPhotoId - 1).padStart(4, '0')}.jpg`,\n          albumId: album.id,\n          fileData: new Blob(['mock-file-data'], { type: 'image/jpeg' }),\n          thumbnailData: new Blob(['mock-thumbnail-data'], { type: 'image/jpeg' }),\n          captureDate: new Date(captureDate.getTime() + j * 3600000), // Hour intervals\n          fileSize: 2048576 + Math.random() * 1048576, // 2-3MB\n          width: 1920 + Math.floor(Math.random() * 1080),\n          height: 1080 + Math.floor(Math.random() * 720),\n          uploadTimestamp: captureDate\n        }\n        this.photos.push(photo)", "metadata": {}}
{"id": "451", "text": "// Set first photo as thumbnail\n        if (j === 0) {\n          album.thumbnailPhotoId = photo.id\n        }\n      }\n    }\n  }\n\n  private generateAlbumName(date: Date): string {\n    const options: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    }\n    return date.toLocaleDateString('en-US', options)\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  private simulateRandomError(errorRate: number = 0.05): void {\n    // Simulate occasional network errors for testing retry logic\n    // Disabled during testing to ensure consistent test results\n    if (process.env.NODE_ENV !== 'test' && Math.random() < errorRate) {\n      throw new Error('Simulated network error: Connection timeout')\n    }\n  }\n\n  async uploadPhotos(files: File[]): Promise<UploadSession> {\n    await this.delay(500) // Simulate network delay", "metadata": {}}
{"id": "452", "text": "private simulateRandomError(errorRate: number = 0.05): void {\n    // Simulate occasional network errors for testing retry logic\n    // Disabled during testing to ensure consistent test results\n    if (process.env.NODE_ENV !== 'test' && Math.random() < errorRate) {\n      throw new Error('Simulated network error: Connection timeout')\n    }\n  }\n\n  async uploadPhotos(files: File[]): Promise<UploadSession> {\n    await this.delay(500) // Simulate network delay\n\n    const session: UploadSession = {\n      id: crypto.randomUUID(),\n      status: files.length === 0 ? 'completed' : 'processing',\n      totalFiles: files.length,\n      processedFiles: files.length === 0 ? 0 : 0,\n      errorCount: 0,\n      startedAt: new Date(),\n      completedAt: files.length === 0 ? new Date() : null\n    }", "metadata": {}}
{"id": "453", "text": "async uploadPhotos(files: File[]): Promise<UploadSession> {\n    await this.delay(500) // Simulate network delay\n\n    const session: UploadSession = {\n      id: crypto.randomUUID(),\n      status: files.length === 0 ? 'completed' : 'processing',\n      totalFiles: files.length,\n      processedFiles: files.length === 0 ? 0 : 0,\n      errorCount: 0,\n      startedAt: new Date(),\n      completedAt: files.length === 0 ? new Date() : null\n    }\n\n    // Process files if any exist\n    if (files.length > 0) {\n      // Simulate processing each file\n      files.forEach((file) => {\n        // Create mock album and photo data\n        const captureDate = new Date()\n\n        // Find existing album for this date or create new one\n        let album = this.albums.find(a =>\n          a.captureDate.toDateString() === captureDate.toDateString()\n        )", "metadata": {}}
{"id": "454", "text": "// Process files if any exist\n    if (files.length > 0) {\n      // Simulate processing each file\n      files.forEach((file) => {\n        // Create mock album and photo data\n        const captureDate = new Date()\n\n        // Find existing album for this date or create new one\n        let album = this.albums.find(a =>\n          a.captureDate.toDateString() === captureDate.toDateString()\n        )\n\n        if (!album) {\n          album = {\n            id: this.nextAlbumId++,\n            name: this.generateAlbumName(captureDate),\n            captureDate,\n            displayOrder: this.albums.length + 1,\n            thumbnailPhotoId: null,\n            photoCount: 0,\n            createdAt: captureDate,\n            updatedAt: captureDate\n          }\n          this.albums.push(album)\n        }", "metadata": {}}
{"id": "455", "text": "// Find existing album for this date or create new one\n        let album = this.albums.find(a =>\n          a.captureDate.toDateString() === captureDate.toDateString()\n        )\n\n        if (!album) {\n          album = {\n            id: this.nextAlbumId++,\n            name: this.generateAlbumName(captureDate),\n            captureDate,\n            displayOrder: this.albums.length + 1,\n            thumbnailPhotoId: null,\n            photoCount: 0,\n            createdAt: captureDate,\n            updatedAt: captureDate\n          }\n          this.albums.push(album)\n        }\n\n        // Create photo\n        const photo: Photo = {\n          id: this.nextPhotoId++,\n          filename: file.name,\n          albumId: album.id,\n          fileData: new Blob(['mock-file-data'], { type: file.type }),\n          thumbnailData: new Blob(['mock-thumbnail-data'], { type: file.type }),\n          captureDate,\n          fileSize: file.size,\n          width: 1920 + Math.floor(Math.random() * 1080),\n          height: 1080 + Math.floor(Math.random() * 720),\n          uploadTimestamp: new Date()\n        }", "metadata": {}}
{"id": "456", "text": "// Create photo\n        const photo: Photo = {\n          id: this.nextPhotoId++,\n          filename: file.name,\n          albumId: album.id,\n          fileData: new Blob(['mock-file-data'], { type: file.type }),\n          thumbnailData: new Blob(['mock-thumbnail-data'], { type: file.type }),\n          captureDate,\n          fileSize: file.size,\n          width: 1920 + Math.floor(Math.random() * 1080),\n          height: 1080 + Math.floor(Math.random() * 720),\n          uploadTimestamp: new Date()\n        }\n\n        this.photos.push(photo)\n        album.photoCount++\n\n        // Set first photo as thumbnail if not set\n        if (!album.thumbnailPhotoId) {\n          album.thumbnailPhotoId = photo.id\n        }\n      })\n\n      // Simulate upload completion\n      setTimeout(() => {\n        session.status = 'completed'\n        session.processedFiles = files.length\n        session.completedAt = new Date()\n      }, 2000)\n    }\n\n    return session\n  }", "metadata": {}}
{"id": "457", "text": "this.photos.push(photo)\n        album.photoCount++\n\n        // Set first photo as thumbnail if not set\n        if (!album.thumbnailPhotoId) {\n          album.thumbnailPhotoId = photo.id\n        }\n      })\n\n      // Simulate upload completion\n      setTimeout(() => {\n        session.status = 'completed'\n        session.processedFiles = files.length\n        session.completedAt = new Date()\n      }, 2000)\n    }\n\n    return session\n  }\n\n  async getAllAlbums(): Promise<Album[]> {\n    await this.delay(300) // Simulate network delay\n    return [...this.albums].sort((a, b) => a.displayOrder - b.displayOrder)\n  }\n\n  /**\n   * Get albums with pagination support for infinite scrolling\n   */\n  async getAlbumsPaginated(page: number = 1, pageSize: number = 12): Promise<PaginatedResponse<Album>> {\n    await this.delay(300) // Simulate network delay\n\n    // Simulate occasional network errors to test retry logic\n    this.simulateRandomError(0.02) // 2% error rate", "metadata": {}}
{"id": "458", "text": "/**\n   * Get albums with pagination support for infinite scrolling\n   */\n  async getAlbumsPaginated(page: number = 1, pageSize: number = 12): Promise<PaginatedResponse<Album>> {\n    await this.delay(300) // Simulate network delay\n\n    // Simulate occasional network errors to test retry logic\n    this.simulateRandomError(0.02) // 2% error rate\n\n    const sortedAlbums = [...this.albums].sort((a, b) => a.displayOrder - b.displayOrder)\n    const totalAlbums = sortedAlbums.length\n    const totalPages = Math.ceil(totalAlbums / pageSize)\n    const startIndex = (page - 1) * pageSize\n    const endIndex = startIndex + pageSize\n    const albumsPage = sortedAlbums.slice(startIndex, endIndex)\n\n    const pagination: PaginationInfo = {\n      page,\n      pageSize,\n      totalAlbums,\n      totalPages,\n      hasNextPage: page < totalPages,\n      hasPreviousPage: page > 1\n    }\n\n    return {\n      data: albumsPage,\n      pagination\n    }\n  }", "metadata": {}}
{"id": "459", "text": "const pagination: PaginationInfo = {\n      page,\n      pageSize,\n      totalAlbums,\n      totalPages,\n      hasNextPage: page < totalPages,\n      hasPreviousPage: page > 1\n    }\n\n    return {\n      data: albumsPage,\n      pagination\n    }\n  }\n\n  async getPhotosInAlbum(albumId: number): Promise<Photo[]> {\n    await this.delay(400) // Simulate network delay\n\n    // Simulate occasional network errors to test retry logic\n    this.simulateRandomError(0.03) // 3% error rate\n\n    return this.photos.filter(photo => photo.albumId === albumId)\n  }\n\n  async getFullPhoto(photoId: number): Promise<Photo> {\n    await this.delay(200) // Simulate network delay\n    const photo = this.photos.find(p => p.id === photoId)\n    if (!photo) {\n      throw new Error(`Photo not found`)\n    }\n    return photo\n  }\n\n  async updateAlbumOrder(albumId: number, newOrder: number): Promise<void> {\n    await this.delay(200) // Simulate network delay", "metadata": {}}
{"id": "460", "text": "return this.photos.filter(photo => photo.albumId === albumId)\n  }\n\n  async getFullPhoto(photoId: number): Promise<Photo> {\n    await this.delay(200) // Simulate network delay\n    const photo = this.photos.find(p => p.id === photoId)\n    if (!photo) {\n      throw new Error(`Photo not found`)\n    }\n    return photo\n  }\n\n  async updateAlbumOrder(albumId: number, newOrder: number): Promise<void> {\n    await this.delay(200) // Simulate network delay\n\n    const album = this.albums.find(a => a.id === albumId)\n    if (!album) {\n      return // Handle gracefully as tests expect\n    }\n\n    album.displayOrder = newOrder\n    album.updatedAt = new Date()\n  }\n\n  async exportAlbumAsZip(albumId: number): Promise<Blob> {\n    await this.delay(1000) // Simulate zip creation time\n\n    const album = this.albums.find(a => a.id === albumId)\n    if (!album) {\n      throw new Error(`Album not found`)\n    }", "metadata": {}}
{"id": "461", "text": "const album = this.albums.find(a => a.id === albumId)\n    if (!album) {\n      return // Handle gracefully as tests expect\n    }\n\n    album.displayOrder = newOrder\n    album.updatedAt = new Date()\n  }\n\n  async exportAlbumAsZip(albumId: number): Promise<Blob> {\n    await this.delay(1000) // Simulate zip creation time\n\n    const album = this.albums.find(a => a.id === albumId)\n    if (!album) {\n      throw new Error(`Album not found`)\n    }\n\n    // Get photos for this album and simulate ZIP size based on photo count\n    const albumPhotos = this.photos.filter(p => p.albumId === albumId)\n    const mockZipData = 'mock-zip-data'.repeat(albumPhotos.length * 100) // Simulate realistic size\n    return new Blob([mockZipData], { type: 'application/zip' })\n  }\n\n  async deletePhoto(photoId: number): Promise<void> {\n    await this.delay(200) // Simulate network delay", "metadata": {}}
{"id": "462", "text": "// Get photos for this album and simulate ZIP size based on photo count\n    const albumPhotos = this.photos.filter(p => p.albumId === albumId)\n    const mockZipData = 'mock-zip-data'.repeat(albumPhotos.length * 100) // Simulate realistic size\n    return new Blob([mockZipData], { type: 'application/zip' })\n  }\n\n  async deletePhoto(photoId: number): Promise<void> {\n    await this.delay(200) // Simulate network delay\n\n    const photoIndex = this.photos.findIndex(p => p.id === photoId)\n    if (photoIndex === -1) {\n      return // Handle gracefully as tests expect\n    }\n\n    const photo = this.photos[photoIndex]\n    this.photos.splice(photoIndex, 1)\n\n    // Update album photo count and remove album if empty\n    const album = this.albums.find(a => a.id === photo.albumId)\n    if (album) {\n      album.photoCount = Math.max(0, album.photoCount - 1)\n      album.updatedAt = new Date()", "metadata": {}}
{"id": "463", "text": "const photoIndex = this.photos.findIndex(p => p.id === photoId)\n    if (photoIndex === -1) {\n      return // Handle gracefully as tests expect\n    }\n\n    const photo = this.photos[photoIndex]\n    this.photos.splice(photoIndex, 1)\n\n    // Update album photo count and remove album if empty\n    const album = this.albums.find(a => a.id === photo.albumId)\n    if (album) {\n      album.photoCount = Math.max(0, album.photoCount - 1)\n      album.updatedAt = new Date()\n\n      // Remove empty albums\n      if (album.photoCount === 0) {\n        const albumIndex = this.albums.findIndex(a => a.id === album.id)\n        if (albumIndex !== -1) {\n          this.albums.splice(albumIndex, 1)\n        }\n      }\n    }\n  }\n\n  async deleteAlbum(albumId: number): Promise<void> {\n    await this.delay(300) // Simulate network delay", "metadata": {}}
{"id": "464", "text": "// Remove empty albums\n      if (album.photoCount === 0) {\n        const albumIndex = this.albums.findIndex(a => a.id === album.id)\n        if (albumIndex !== -1) {\n          this.albums.splice(albumIndex, 1)\n        }\n      }\n    }\n  }\n\n  async deleteAlbum(albumId: number): Promise<void> {\n    await this.delay(300) // Simulate network delay\n\n    const albumIndex = this.albums.findIndex(a => a.id === albumId)\n    if (albumIndex === -1) {\n      return // Handle gracefully as tests expect\n    }\n\n    // Remove all photos in the album\n    this.photos = this.photos.filter(photo => photo.albumId !== albumId)\n\n    // Remove the album\n    this.albums.splice(albumIndex, 1)\n  }\n}\n\n// Export singleton instance\nexport const mockDataService = new MockDataService()", "metadata": {}}
{"id": "465", "text": "import { Image, ImageUpdateData } from '../types/image';\n\n// Mock database - in a real app this would connect to SQLite\nconst mockImages: Image[] = [\n  {\n    id: '550e8400-e29b-41d4-a716-446655440000',\n    filename: 'sample-image.jpg',\n    path: '/images/sample-image.jpg',\n    url: 'https://picsum.photos/800/600?random=1',\n    caption: 'A beautiful landscape',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date('2024-01-15T10:30:00Z'),\n    capturedAt: new Date('2024-01-15T09:15:00Z'),\n    fileSize: 2457600,\n    width: 1920,\n    height: 1080,\n    mimeType: 'image/jpeg',\n    cameraModel: 'Canon EOS R5',\n    location: 'San Francisco, CA',\n    tags: ['landscape', 'nature', 'outdoor'],\n  },", "metadata": {}}
{"id": "466", "text": "uploadedBy: 'user-123',\n    uploadedAt: new Date('2024-01-15T10:30:00Z'),\n    capturedAt: new Date('2024-01-15T09:15:00Z'),\n    fileSize: 2457600,\n    width: 1920,\n    height: 1080,\n    mimeType: 'image/jpeg',\n    cameraModel: 'Canon EOS R5',\n    location: 'San Francisco, CA',\n    tags: ['landscape', 'nature', 'outdoor'],\n  },\n  {\n    id: '550e8400-e29b-41d4-a716-446655440001',\n    filename: 'portrait.jpg',\n    path: '/images/portrait.jpg',\n    url: 'https://picsum.photos/600/800?random=2',\n    caption: 'Portrait session',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date('2024-01-16T14:45:00Z'),", "metadata": {}}
{"id": "467", "text": "CA',\n    tags: ['landscape', 'nature', 'outdoor'],\n  },\n  {\n    id: '550e8400-e29b-41d4-a716-446655440001',\n    filename: 'portrait.jpg',\n    path: '/images/portrait.jpg',\n    url: 'https://picsum.photos/600/800?random=2',\n    caption: 'Portrait session',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date('2024-01-16T14:45:00Z'),\n    capturedAt: new Date('2024-01-16T14:30:00Z'),\n    fileSize: 3145728,\n    width: 2400,\n    height: 3600,\n    mimeType: 'image/jpeg',\n    cameraModel: 'Sony A7R IV',\n    tags: ['portrait', 'people'],\n  },\n];", "metadata": {}}
{"id": "468", "text": "caption: 'Portrait session',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date('2024-01-16T14:45:00Z'),\n    capturedAt: new Date('2024-01-16T14:30:00Z'),\n    fileSize: 3145728,\n    width: 2400,\n    height: 3600,\n    mimeType: 'image/jpeg',\n    cameraModel: 'Sony A7R IV',\n    tags: ['portrait', 'people'],\n  },\n];\n\n// Mock user database\nconst mockUsers = [\n  {\n    id: 'user-123',\n    username: 'photographer',\n    displayName: 'John Photographer',\n    email: 'john@example.com',\n    avatarUrl: 'https://picsum.photos/100/100?random=1',\n  },\n];", "metadata": {}}
{"id": "469", "text": "fileSize: 3145728,\n    width: 2400,\n    height: 3600,\n    mimeType: 'image/jpeg',\n    cameraModel: 'Sony A7R IV',\n    tags: ['portrait', 'people'],\n  },\n];\n\n// Mock user database\nconst mockUsers = [\n  {\n    id: 'user-123',\n    username: 'photographer',\n    displayName: 'John Photographer',\n    email: 'john@example.com',\n    avatarUrl: 'https://picsum.photos/100/100?random=1',\n  },\n];\n\nexport class ImageService {\n  /**\n   * Get an image by ID\n   */\n  static async getImage(id: string): Promise<Image | null> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    const image = mockImages.find(img => img.id === id);\n    return image || null;\n  }", "metadata": {}}
{"id": "470", "text": "export class ImageService {\n  /**\n   * Get an image by ID\n   */\n  static async getImage(id: string): Promise<Image | null> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    const image = mockImages.find(img => img.id === id);\n    return image || null;\n  }\n\n  /**\n   * Get image file as blob URL\n   */\n  static async getImageFile(id: string): Promise<string | null> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 150));\n    \n    const image = mockImages.find(img => img.id === id);\n    if (!image) {\n      return null;\n    }\n    \n    // In a real app, this would fetch the actual file\n    // For mock purposes, we'll return the existing URL\n    return image.url;\n  }", "metadata": {}}
{"id": "471", "text": "/**\n   * Get image file as blob URL\n   */\n  static async getImageFile(id: string): Promise<string | null> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 150));\n    \n    const image = mockImages.find(img => img.id === id);\n    if (!image) {\n      return null;\n    }\n    \n    // In a real app, this would fetch the actual file\n    // For mock purposes, we'll return the existing URL\n    return image.url;\n  }\n\n  /**\n   * Update image metadata\n   */\n  static async updateImage(id: string, updates: ImageUpdateData): Promise<Image | null> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    const imageIndex = mockImages.findIndex(img => img.id === id);\n    if (imageIndex === -1) {\n      return null;\n    }\n    \n    // Update the image\n    mockImages[imageIndex] = {\n      ...mockImages[imageIndex],\n      ...updates,\n    };\n    \n    return mockImages[imageIndex];\n  }", "metadata": {}}
{"id": "472", "text": "/**\n   * Update image metadata\n   */\n  static async updateImage(id: string, updates: ImageUpdateData): Promise<Image | null> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    const imageIndex = mockImages.findIndex(img => img.id === id);\n    if (imageIndex === -1) {\n      return null;\n    }\n    \n    // Update the image\n    mockImages[imageIndex] = {\n      ...mockImages[imageIndex],\n      ...updates,\n    };\n    \n    return mockImages[imageIndex];\n  }\n\n  /**\n   * Get all images with optional filtering\n   */\n  static async getAllImages(options?: {\n    limit?: number;\n    offset?: number;\n    sortBy?: 'uploadedAt' | 'capturedAt' | 'filename';\n    sortOrder?: 'asc' | 'desc';\n    tags?: string[];\n    uploadedBy?", "metadata": {}}
{"id": "473", "text": "/**\n   * Get all images with optional filtering\n   */\n  static async getAllImages(options?: {\n    limit?: number;\n    offset?: number;\n    sortBy?: 'uploadedAt' | 'capturedAt' | 'filename';\n    sortOrder?: 'asc' | 'desc';\n    tags?: string[];\n    uploadedBy?: string;\n  }): Promise<{ images: Image[]; total: number }> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 50));\n    \n    let filteredImages = [...mockImages];\n    \n    // Apply filters\n    if (options?.tags && options.tags.length > 0) {\n      filteredImages = filteredImages.filter(img => \n        options.tags!.some(tag => img.tags.includes(tag))\n      );\n    }\n    \n    if (options?.uploadedBy) {\n      filteredImages = filteredImages.filter(img => img.uploadedBy === options.uploadedBy);\n    }\n    \n    // Apply sorting\n    if (options?.sortBy) {\n      filteredImages.sort((a, b) => {\n        const aValue = a[options.sortBy!", "metadata": {}}
{"id": "474", "text": "];\n        const bValue = b[options.sortBy!];\n        \n        if (aValue < bValue) return options.sortOrder === 'asc' ? -1 : 1;\n        if (aValue > bValue) return options.sortOrder === 'asc' ? 1 : -1;\n        return 0;\n      });\n    }\n    \n    const total = filteredImages.length;\n    \n    // Apply pagination\n    if (options?.limit) {\n      const start = options.offset || 0;\n      filteredImages = filteredImages.slice(start, start + options.limit);\n    }\n    \n    return {\n      images: filteredImages,\n      total,\n    };\n  }\n\n  /**\n   * Upload a new image\n   */\n  static async uploadImage(file: File, metadata?: {\n    caption?: string;\n    tags?: string[];\n  }): Promise<Image> {\n    // Simulate upload delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Generate mock EXIF data\n    const mockExifData = {\n      width: Math.floor(Math.", "metadata": {}}
{"id": "475", "text": "/**\n   * Upload a new image\n   */\n  static async uploadImage(file: File, metadata?: {\n    caption?: string;\n    tags?: string[];\n  }): Promise<Image> {\n    // Simulate upload delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // Generate mock EXIF data\n    const mockExifData = {\n      width: Math.floor(Math.random() * 2000) + 1000,\n      height: Math.floor(Math.random() * 2000) + 1000,\n      cameraModel: ['Canon EOS R5', 'Sony A7R IV', 'Nikon Z9'][Math.floor(Math.random() * 3)],\n      capturedAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000),\n    };\n    \n    const newImage: Image = {\n      id: crypto.randomUUID(),\n      filename: file.name,\n      path: `/images/${file.name}`,\n      url: URL.", "metadata": {}}
{"id": "476", "text": "floor(Math.random() * 2000) + 1000,\n      cameraModel: ['Canon EOS R5', 'Sony A7R IV', 'Nikon Z9'][Math.floor(Math.random() * 3)],\n      capturedAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000),\n    };\n    \n    const newImage: Image = {\n      id: crypto.randomUUID(),\n      filename: file.name,\n      path: `/images/${file.name}`,\n      url: URL.createObjectURL(file),\n      caption: metadata?.caption,\n      uploadedBy: 'user-123', // In real app, get from auth context\n      uploadedAt: new Date(),\n      capturedAt: mockExifData.capturedAt,\n      fileSize: file.size,\n      width: mockExifData.width,\n      height: mockExifData.height,\n      mimeType: file.type,\n      cameraModel: mockExifData.cameraModel,", "metadata": {}}
{"id": "477", "text": "name,\n      path: `/images/${file.name}`,\n      url: URL.createObjectURL(file),\n      caption: metadata?.caption,\n      uploadedBy: 'user-123', // In real app, get from auth context\n      uploadedAt: new Date(),\n      capturedAt: mockExifData.capturedAt,\n      fileSize: file.size,\n      width: mockExifData.width,\n      height: mockExifData.height,\n      mimeType: file.type,\n      cameraModel: mockExifData.cameraModel,\n      tags: metadata?.tags || [],\n    };\n    \n    mockImages.push(newImage);\n    return newImage;\n  }", "metadata": {}}
{"id": "478", "text": "caption,\n      uploadedBy: 'user-123', // In real app, get from auth context\n      uploadedAt: new Date(),\n      capturedAt: mockExifData.capturedAt,\n      fileSize: file.size,\n      width: mockExifData.width,\n      height: mockExifData.height,\n      mimeType: file.type,\n      cameraModel: mockExifData.cameraModel,\n      tags: metadata?.tags || [],\n    };\n    \n    mockImages.push(newImage);\n    return newImage;\n  }\n\n  /**\n   * Delete an image\n   */\n  static async deleteImage(id: string): Promise<boolean> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    const index = mockImages.findIndex(img => img.id === id);\n    if (index === -1) {\n      return false;\n    }\n    \n    mockImages.splice(index, 1);\n    return true;\n  }", "metadata": {}}
{"id": "479", "text": "cameraModel,\n      tags: metadata?.tags || [],\n    };\n    \n    mockImages.push(newImage);\n    return newImage;\n  }\n\n  /**\n   * Delete an image\n   */\n  static async deleteImage(id: string): Promise<boolean> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    const index = mockImages.findIndex(img => img.id === id);\n    if (index === -1) {\n      return false;\n    }\n    \n    mockImages.splice(index, 1);\n    return true;\n  }\n\n  /**\n   * Get user by ID\n   */\n  static async getUser(id: string) {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 50));\n    \n    return mockUsers.find(user => user.id === id) || null;\n  }", "metadata": {}}
{"id": "480", "text": "/**\n   * Get user by ID\n   */\n  static async getUser(id: string) {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 50));\n    \n    return mockUsers.find(user => user.id === id) || null;\n  }\n\n  /**\n   * Search images by query\n   */\n  static async searchImages(query: string): Promise<Image[]> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    const lowercaseQuery = query.toLowerCase();\n    return mockImages.filter(img => \n      img.filename.toLowerCase().includes(lowercaseQuery) ||\n      img.caption?.toLowerCase().includes(lowercaseQuery) ||\n      img.tags.some(tag => tag.toLowerCase().includes(lowercaseQuery))\n    );\n  }\n}", "metadata": {}}
{"id": "481", "text": "/**\n   * Search images by query\n   */\n  static async searchImages(query: string): Promise<Image[]> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    const lowercaseQuery = query.toLowerCase();\n    return mockImages.filter(img => \n      img.filename.toLowerCase().includes(lowercaseQuery) ||\n      img.caption?.toLowerCase().includes(lowercaseQuery) ||\n      img.tags.some(tag => tag.toLowerCase().includes(lowercaseQuery))\n    );\n  }\n}\n\n// Export utility functions for convenience\nexport const getImage = ImageService.getImage.bind(ImageService);\nexport const getImageFile = ImageService.getImageFile.bind(ImageService);\nexport const updateImage = ImageService.updateImage.bind(ImageService);\nexport const getAllImages = ImageService.getAllImages.bind(ImageService);\nexport const uploadImage = ImageService.uploadImage.bind(ImageService);\nexport const deleteImage = ImageService.deleteImage.bind(ImageService);\nexport const searchImages = ImageService.searchImages.bind(ImageService);", "metadata": {}}
{"id": "482", "text": "import '@testing-library/jest-dom'\n\n// Mock IntersectionObserver for infinite scroll tests\nglobal.IntersectionObserver = class IntersectionObserver {\n  root = null\n  rootMargin = ''\n  thresholds = []\n\n  constructor(public callback: IntersectionObserverCallback, public options?: IntersectionObserverInit) {}\n  disconnect() {}\n  observe() {}\n  unobserve() {}\n  takeRecords(): IntersectionObserverEntry[] {\n    return []\n  }\n}\n\n// Mock ResizeObserver\nglobal.ResizeObserver = class ResizeObserver {\n  constructor() {}\n  disconnect() {}\n  observe() {}\n  unobserve() {}\n}", "metadata": {}}
{"id": "483", "text": "export interface Image {\n  id: string;\n  filename: string;\n  path: string;\n  url: string;\n  caption?: string;\n  uploadedBy: string;\n  uploadedAt: Date;\n  capturedAt?: Date;\n  fileSize: number;\n  width?: number;\n  height?: number;\n  mimeType: string;\n  cameraModel?: string;\n  location?: string;\n  tags: string[];\n}\n\nexport interface ImageFormData {\n  file: File;\n  caption?: string;\n  tags?: string[];\n}\n\nexport interface ImageUpdateData {\n  caption?: string;\n  tags?: string[];\n}\n\nexport interface ImageQueryOptions {\n  limit?: number;\n  offset?: number;\n  sortBy?: 'uploadedAt' | 'capturedAt' | 'filename';\n  sortOrder?: 'asc' | 'desc';\n  tags?: string[];\n  uploadedBy?: string;\n}", "metadata": {}}
{"id": "484", "text": "/**\n * Core data interfaces for the Photo Organizer App\n * Based on contracts from specs/001-build-a-photo/contracts/\n */\n\n// ============================================================================\n// Core Data Types\n// ============================================================================\n\nexport interface Photo {\n  id: number\n  filename: string\n  albumId: number\n  fileData: Blob\n  thumbnailData: Blob\n  captureDate: Date | null\n  fileSize: number\n  width: number\n  height: number\n  uploadTimestamp: Date\n}\n\nexport interface Album {\n  id: number\n  name: string\n  captureDate: Date\n  displayOrder: number\n  thumbnailPhotoId: number | null\n  photoCount: number\n  createdAt: Date\n  updatedAt: Date\n}\n\nexport interface UploadSession {\n  id: string\n  status: 'processing' | 'completed' | 'failed'\n  totalFiles: number\n  processedFiles: number\n  errorCount: number\n  startedAt: Date\n  completedAt: Date | null\n}\n\n// ============================================================================\n// Service Interfaces\n// ============================================================================", "metadata": {}}
{"id": "485", "text": "export interface Album {\n  id: number\n  name: string\n  captureDate: Date\n  displayOrder: number\n  thumbnailPhotoId: number | null\n  photoCount: number\n  createdAt: Date\n  updatedAt: Date\n}\n\nexport interface UploadSession {\n  id: string\n  status: 'processing' | 'completed' | 'failed'\n  totalFiles: number\n  processedFiles: number\n  errorCount: number\n  startedAt: Date\n  completedAt: Date | null\n}\n\n// ============================================================================\n// Service Interfaces\n// ============================================================================\n\nexport interface PhotoService {\n  uploadPhotos(files: File[]): Promise<UploadSession>\n  getAllAlbums(): Promise<Album[]>\n  getPhotosInAlbum(albumId: number): Promise<Photo[]>\n  getFullPhoto(photoId: number): Promise<Photo>\n  updateAlbumOrder(albumId: number, newOrder: number): Promise<void>\n  exportAlbumAsZip(albumId: number): Promise<Blob>\n  deletePhoto(photoId: number): Promise<void>\n  deleteAlbum(albumId: number): Promise<void>\n}", "metadata": {}}
{"id": "486", "text": "// ============================================================================\n// Service Interfaces\n// ============================================================================\n\nexport interface PhotoService {\n  uploadPhotos(files: File[]): Promise<UploadSession>\n  getAllAlbums(): Promise<Album[]>\n  getPhotosInAlbum(albumId: number): Promise<Photo[]>\n  getFullPhoto(photoId: number): Promise<Photo>\n  updateAlbumOrder(albumId: number, newOrder: number): Promise<void>\n  exportAlbumAsZip(albumId: number): Promise<Blob>\n  deletePhoto(photoId: number): Promise<void>\n  deleteAlbum(albumId: number): Promise<void>\n}\n\nexport interface PhotoServiceEvents {\n  uploadProgress: {\n    sessionId: string\n    processedFiles: number\n    totalFiles: number\n    currentFile?: string\n  }\n  uploadComplete: {\n    sessionId: string\n    newAlbums: Album[]\n    totalPhotos: number\n  }\n  uploadError: {\n    sessionId: string\n    filename: string\n    error: string\n  }\n  albumOrderChanged: {\n    albumId: number\n    oldOrder: number\n    newOrder: number\n  }\n}", "metadata": {}}
{"id": "487", "text": "export interface PhotoServiceEvents {\n  uploadProgress: {\n    sessionId: string\n    processedFiles: number\n    totalFiles: number\n    currentFile?: string\n  }\n  uploadComplete: {\n    sessionId: string\n    newAlbums: Album[]\n    totalPhotos: number\n  }\n  uploadError: {\n    sessionId: string\n    filename: string\n    error: string\n  }\n  albumOrderChanged: {\n    albumId: number\n    oldOrder: number\n    newOrder: number\n  }\n}\n\n// ============================================================================\n// Component Props\n// ============================================================================\n\ninterface BaseComponentProps {\n  className?: string\n  'data-testid'?: string\n  'aria-setsize'?: number\n  'aria-posinset'?: number\n  'aria-label'?: string\n  'aria-labelledby'?: string\n  'aria-describedby'?: string\n  role?: string\n}", "metadata": {}}
{"id": "488", "text": "// ============================================================================\n// Component Props\n// ============================================================================\n\ninterface BaseComponentProps {\n  className?: string\n  'data-testid'?: string\n  'aria-setsize'?: number\n  'aria-posinset'?: number\n  'aria-label'?: string\n  'aria-labelledby'?: string\n  'aria-describedby'?: string\n  role?: string\n}\n\nexport interface AlbumGridProps extends BaseComponentProps {\n  albums: Album[]\n  onAlbumClick: (albumId: number) => void\n  onAlbumReorder: (albumId: number, newOrder: number) => void\n  onAlbumDelete?: (albumId: number) => void\n  loading?: boolean\n}\n\nexport interface AlbumTileProps extends BaseComponentProps {\n  album: Album\n  thumbnailSrc?: string\n  onClick: () => void\n  onDelete?: () => void\n  isDragging?: boolean\n  dragHandleProps?: any\n}", "metadata": {}}
{"id": "489", "text": "export interface AlbumGridProps extends BaseComponentProps {\n  albums: Album[]\n  onAlbumClick: (albumId: number) => void\n  onAlbumReorder: (albumId: number, newOrder: number) => void\n  onAlbumDelete?: (albumId: number) => void\n  loading?: boolean\n}\n\nexport interface AlbumTileProps extends BaseComponentProps {\n  album: Album\n  thumbnailSrc?: string\n  onClick: () => void\n  onDelete?: () => void\n  isDragging?: boolean\n  dragHandleProps?: any\n}\n\nexport interface PhotoTileViewProps extends BaseComponentProps {\n  photos: Photo[]\n  onPhotoClick: (photoId: number) => void\n  onPhotoDelete?: (photoId: number) => void\n  loading?: boolean\n  selectedPhotoId?: number\n}\n\nexport interface PhotoTileProps extends BaseComponentProps {\n  photo: Photo\n  thumbnailSrc: string\n  onClick: () => void\n  onDelete?: () => void\n  isSelected?: boolean\n}", "metadata": {}}
{"id": "490", "text": "export interface PhotoTileViewProps extends BaseComponentProps {\n  photos: Photo[]\n  onPhotoClick: (photoId: number) => void\n  onPhotoDelete?: (photoId: number) => void\n  loading?: boolean\n  selectedPhotoId?: number\n}\n\nexport interface PhotoTileProps extends BaseComponentProps {\n  photo: Photo\n  thumbnailSrc: string\n  onClick: () => void\n  onDelete?: () => void\n  isSelected?: boolean\n}\n\nexport interface ZoomModalProps extends BaseComponentProps {\n  isOpen: boolean\n  onClose: () => void\n  photo: Photo | null\n  photos: Photo[]\n  currentIndex: number\n  onNext: () => void\n  onPrevious: () => void\n  onDelete?: (photoId: number) => void\n}\n\nexport interface UploadDropzoneProps extends BaseComponentProps {\n  onFilesSelected: (files: FileList) => void\n  uploadSession?: UploadSession\n  acceptedFileTypes?: string[]\n  maxFileSize?: number\n  isUploading?: boolean\n}", "metadata": {}}
{"id": "491", "text": "export interface ZoomModalProps extends BaseComponentProps {\n  isOpen: boolean\n  onClose: () => void\n  photo: Photo | null\n  photos: Photo[]\n  currentIndex: number\n  onNext: () => void\n  onPrevious: () => void\n  onDelete?: (photoId: number) => void\n}\n\nexport interface UploadDropzoneProps extends BaseComponentProps {\n  onFilesSelected: (files: FileList) => void\n  uploadSession?: UploadSession\n  acceptedFileTypes?: string[]\n  maxFileSize?: number\n  isUploading?: boolean\n}\n\nexport interface UploadProgressProps extends BaseComponentProps {\n  session: UploadSession\n  onCancel?: () => void\n  showDetails?: boolean\n}\n\nexport interface NavigationProps extends BaseComponentProps {\n  currentView: 'albums' | 'photos'\n  albumName?: string\n  onBackToAlbums?: () => void\n  onExportAlbum?: () => void\n  canExport?: boolean\n}", "metadata": {}}
{"id": "492", "text": "export interface UploadProgressProps extends BaseComponentProps {\n  session: UploadSession\n  onCancel?: () => void\n  showDetails?: boolean\n}\n\nexport interface NavigationProps extends BaseComponentProps {\n  currentView: 'albums' | 'photos'\n  albumName?: string\n  onBackToAlbums?: () => void\n  onExportAlbum?: () => void\n  canExport?: boolean\n}\n\nexport interface SearchProps extends BaseComponentProps {\n  onSearch: (query: string) => void\n  placeholder?: string\n  suggestions?: string[]\n}\n\n// ============================================================================\n// Accessibility and Interaction Types\n// ============================================================================\n\nexport interface AccessibilityProps {\n  'aria-label'?: string\n  'aria-labelledby'?: string\n  'aria-describedby'?: string\n  role?: string\n  tabIndex?: number\n}\n\nexport interface DraggableProps extends AccessibilityProps {\n  draggable: boolean\n  onDragStart: (event: React.DragEvent) => void\n  onDragEnd: (event: React.DragEvent) => void\n}", "metadata": {}}
{"id": "493", "text": "// ============================================================================\n// Accessibility and Interaction Types\n// ============================================================================\n\nexport interface AccessibilityProps {\n  'aria-label'?: string\n  'aria-labelledby'?: string\n  'aria-describedby'?: string\n  role?: string\n  tabIndex?: number\n}\n\nexport interface DraggableProps extends AccessibilityProps {\n  draggable: boolean\n  onDragStart: (event: React.DragEvent) => void\n  onDragEnd: (event: React.DragEvent) => void\n}\n\nexport interface DroppableProps extends AccessibilityProps {\n  onDragOver: (event: React.DragEvent) => void\n  onDrop: (event: React.DragEvent) => void\n  onDragEnter: (event: React.DragEvent) => void\n  onDragLeave: (event: React.DragEvent) => void\n}\n\n// ============================================================================\n// Event Handler Types\n// ============================================================================", "metadata": {}}
{"id": "494", "text": "export interface DroppableProps extends AccessibilityProps {\n  onDragOver: (event: React.DragEvent) => void\n  onDrop: (event: React.DragEvent) => void\n  onDragEnter: (event: React.DragEvent) => void\n  onDragLeave: (event: React.DragEvent) => void\n}\n\n// ============================================================================\n// Event Handler Types\n// ============================================================================\n\nexport type PhotoEventHandler = (photoId: number) => void\nexport type AlbumEventHandler = (albumId: number) => void\nexport type FileSelectHandler = (files: FileList) => void\nexport type OrderChangeHandler = (itemId: number, newOrder: number) => void\n\n// ============================================================================\n// Application State Types\n// ============================================================================\n\nexport interface ViewState {\n  currentView: 'albums' | 'photos'\n  selectedAlbumId?: number\n  selectedPhotoId?: number\n  isZoomModalOpen: boolean\n}\n\nexport interface LoadingState {\n  albums: boolean\n  photos: boolean\n  upload: boolean\n  export: boolean\n}", "metadata": {}}
{"id": "495", "text": "// ============================================================================\n// Application State Types\n// ============================================================================\n\nexport interface ViewState {\n  currentView: 'albums' | 'photos'\n  selectedAlbumId?: number\n  selectedPhotoId?: number\n  isZoomModalOpen: boolean\n}\n\nexport interface LoadingState {\n  albums: boolean\n  photos: boolean\n  upload: boolean\n  export: boolean\n}\n\nexport interface ErrorState {\n  message: string\n  type: 'upload' | 'load' | 'delete' | 'export'\n  timestamp: Date\n}\n\n// ============================================================================\n// Pagination and Infinite Scroll Types\n// ============================================================================\n\nexport interface PaginationInfo {\n  page: number\n  pageSize: number\n  totalAlbums: number\n  totalPages: number\n  hasNextPage: boolean\n  hasPreviousPage: boolean\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[]\n  pagination: PaginationInfo\n}\n\nexport interface InfiniteScrollOptions {\n  threshold?: number\n  rootMargin?: string\n  enabled?: boolean\n}\n\n// ============================================================================\n// Mock Data Types\n// ============================================================================", "metadata": {}}
{"id": "496", "text": "// ============================================================================\n// Pagination and Infinite Scroll Types\n// ============================================================================\n\nexport interface PaginationInfo {\n  page: number\n  pageSize: number\n  totalAlbums: number\n  totalPages: number\n  hasNextPage: boolean\n  hasPreviousPage: boolean\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[]\n  pagination: PaginationInfo\n}\n\nexport interface InfiniteScrollOptions {\n  threshold?: number\n  rootMargin?: string\n  enabled?: boolean\n}\n\n// ============================================================================\n// Mock Data Types\n// ============================================================================\n\nexport interface MockDataOptions {\n  albumCount?: number\n  photosPerAlbum?: number\n  withDelay?: boolean\n  delayRange?: [number, number]\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\nexport type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>", "metadata": {}}
{"id": "497", "text": "export interface InfiniteScrollOptions {\n  threshold?: number\n  rootMargin?: string\n  enabled?: boolean\n}\n\n// ============================================================================\n// Mock Data Types\n// ============================================================================\n\nexport interface MockDataOptions {\n  albumCount?: number\n  photosPerAlbum?: number\n  withDelay?: boolean\n  delayRange?: [number, number]\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\nexport type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>\n\n// Helper type for component ref forwarding\nexport type ComponentWithRef<T, P = {}> = React.ForwardRefExoticComponent<\n  P & React.RefAttributes<T>\n>\n\n// Helper type for async component states\nexport type AsyncState<T> = {\n  data: T | null\n  loading: boolean\n  error: string | null\n}", "metadata": {}}
{"id": "498", "text": "import { Image } from './image';\nimport { User } from './user';\n\nexport interface ImageDetailState {\n  isOpen: boolean;\n  selectedImage: Image | null;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport interface GalleryState {\n  images: Image[];\n  filters: GalleryFilters;\n  selectedImageId: string | null;\n  isDetailOpen: boolean;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport interface GalleryFilters {\n  searchQuery?: string;\n  tags?: string[];\n  dateRange?: {\n    start: Date;\n    end: Date;\n  };\n  uploadedBy?: string;\n}\n\nexport interface UploadState {\n  isUploading: boolean;\n  progress: number;\n  files: File[];\n  uploadedImages: Image[];\n  error: string | null;\n}\n\nexport interface AppState {\n  gallery: GalleryState;\n  imageDetail: ImageDetailState;\n  upload: UploadState;\n  auth: AuthState;\n}\n\nexport interface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n}", "metadata": {}}
{"id": "499", "text": "export interface UploadState {\n  isUploading: boolean;\n  progress: number;\n  files: File[];\n  uploadedImages: Image[];\n  error: string | null;\n}\n\nexport interface AppState {\n  gallery: GalleryState;\n  imageDetail: ImageDetailState;\n  upload: UploadState;\n  auth: AuthState;\n}\n\nexport interface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport interface ToastMessage {\n  id: string;\n  message: string;\n  type: 'success' | 'error' | 'info' | 'warning';\n  duration?: number;\n}\n\nexport interface ToastState {\n  messages: ToastMessage[];\n}\n\nexport interface LoadingState {\n  isLoading: boolean;\n  message?: string;\n}\n\nexport interface ApiState<T> {\n  data: T | null;\n  isLoading: boolean;\n  error: string | null;\n  lastUpdated: Date | null;\n}", "metadata": {}}
{"id": "500", "text": "export interface User {\n  id: string;\n  username: string;\n  displayName?: string;\n  email: string;\n  avatarUrl?: string;\n}\n\nexport interface UserFormData {\n  username: string;\n  displayName?: string;\n  email: string;\n  password: string;\n}\n\nexport interface UserUpdateData {\n  displayName?: string;\n  email?: string;\n  avatarUrl?: string;\n}\n\nexport interface UserPreferences {\n  theme: 'light' | 'dark' | 'system';\n  language: string;\n  imageDisplayMode: 'grid' | 'list';\n  imageSortOrder: 'newest' | 'oldest' | 'name';\n}\n\nexport interface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n}\n\nexport interface UserProfile {\n  user: User;\n  imageCount: number;\n  totalFileSize: number;\n  joinDate: Date;\n  preferences: UserPreferences;\n}\n\nexport interface UserWithStats extends User {\n  imageCount: number;\n  totalFileSize: number;\n  joinDate: Date;\n}", "metadata": {}}
{"id": "501", "text": "export interface ViewState {\n  currentView: 'albums' | 'photos';\n  isZoomModalOpen: boolean;\n  selectedAlbumId?: number;\n  selectedPhotoId?: number;\n}\n\nexport interface Photo {\n  id: number;\n  url?: string;\n  albumId?: number;\n  // Add more photo properties as needed\n  date?: Date;\n  name?: string;\n  size?: number;\n  width?: number;\n  height?: number;\n}\n\nexport interface Album {\n  id: number;\n  name: string;\n  date: Date;\n  thumbnailPhotoId?: number;\n  photoCount: number;\n  order: number;\n  // Add more album properties as needed\n}\n\nexport interface AlbumGridProps {\n  albums: Album[];\n  onAlbumClick: (albumId: number) => void;\n  onAlbumReorder?: (albumId: number, newOrder: number) => void;\n  onAlbumDelete?: (albumId: number) => void;\n  loading?: boolean;\n  className?: string;\n}", "metadata": {}}
{"id": "502", "text": "export interface Album {\n  id: number;\n  name: string;\n  date: Date;\n  thumbnailPhotoId?: number;\n  photoCount: number;\n  order: number;\n  // Add more album properties as needed\n}\n\nexport interface AlbumGridProps {\n  albums: Album[];\n  onAlbumClick: (albumId: number) => void;\n  onAlbumReorder?: (albumId: number, newOrder: number) => void;\n  onAlbumDelete?: (albumId: number) => void;\n  loading?: boolean;\n  className?: string;\n}\n\nexport interface LandingPageProps {\n  viewState: ViewState;\n  onAlbumClick: (albumId: number) => void;\n  onPhotoClick: (photoId: number) => void;\n  onCloseZoom: () => void;\n}\n\nexport interface LayoutProps {\n  children: React.ReactNode;\n  viewState: ViewState;\n  onBackToAlbums: () => void;\n}", "metadata": {}}
{"id": "503", "text": "/**\nimport * as React from 'react';\n\n/**\n * Bundle Optimization Utilities\n * Runtime performance monitoring and optimization helpers\n */\n\nexport interface BundleMetrics {\n  /** Total bundle size in bytes */\n  totalSize: number\n  /** Number of chunks loaded */\n  chunksLoaded: number\n  /** Load time metrics */\n  loadTimes: {\n    initial: number\n    chunks: Record<string, number>\n    average: number\n  }\n  /** Network information */\n  connection?: {\n    effectiveType: string\n    downlink: number\n    saveData: boolean\n  }\n  /** Memory usage */\n  memory?: {\n    usedJSHeapSize: number\n    totalJSHeapSize: number\n    jsHeapSizeLimit: number\n  }\n}\n\nexport interface OptimizationRecommendations {\n  /** Whether to enable lazy loading */\n  enableLazyLoading: boolean\n  /** Whether to preload critical resources */\n  enablePreloading: boolean\n  /** Whether to defer non-critical JavaScript */\n  deferNonCritical: boolean\n  /** Recommended chunk sizes */\n  chunkSizeRecommendation: {\n    maxSize: number\n    reason: string\n  }\n}", "metadata": {}}
{"id": "504", "text": "export interface OptimizationRecommendations {\n  /** Whether to enable lazy loading */\n  enableLazyLoading: boolean\n  /** Whether to preload critical resources */\n  enablePreloading: boolean\n  /** Whether to defer non-critical JavaScript */\n  deferNonCritical: boolean\n  /** Recommended chunk sizes */\n  chunkSizeRecommendation: {\n    maxSize: number\n    reason: string\n  }\n}\n\nclass BundleOptimizer {\n  private metrics: BundleMetrics = {\n    totalSize: 0,\n    chunksLoaded: 0,\n    loadTimes: {\n      initial: 0,\n      chunks: {},\n      average: 0\n    }\n  }\n\n  private observers: {\n    performance?: PerformanceObserver\n    navigation?: PerformanceObserver\n  } = {}\n\n  private startTime = performance.now()\n\n  constructor() {\n    this.initializeMonitoring()\n    this.collectInitialMetrics()\n  }", "metadata": {}}
{"id": "505", "text": "class BundleOptimizer {\n  private metrics: BundleMetrics = {\n    totalSize: 0,\n    chunksLoaded: 0,\n    loadTimes: {\n      initial: 0,\n      chunks: {},\n      average: 0\n    }\n  }\n\n  private observers: {\n    performance?: PerformanceObserver\n    navigation?: PerformanceObserver\n  } = {}\n\n  private startTime = performance.now()\n\n  constructor() {\n    this.initializeMonitoring()\n    this.collectInitialMetrics()\n  }\n\n  /**\n   * Initialize performance monitoring\n   */\n  private initializeMonitoring(): void {\n    if ('PerformanceObserver' in window) {\n      // Monitor resource loading\n      this.observers.performance = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          this.processPerformanceEntry(entry)\n        }\n      })\n\n      try {\n        this.observers.performance.observe({ entryTypes: ['resource', 'navigation'] })\n      } catch (error) {\n        console.warn('Performance monitoring not fully supported:', error)\n      }\n    }\n  }", "metadata": {}}
{"id": "506", "text": "/**\n   * Initialize performance monitoring\n   */\n  private initializeMonitoring(): void {\n    if ('PerformanceObserver' in window) {\n      // Monitor resource loading\n      this.observers.performance = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          this.processPerformanceEntry(entry)\n        }\n      })\n\n      try {\n        this.observers.performance.observe({ entryTypes: ['resource', 'navigation'] })\n      } catch (error) {\n        console.warn('Performance monitoring not fully supported:', error)\n      }\n    }\n  }\n\n  /**\n   * Collect initial metrics\n   */\n  private collectInitialMetrics(): void {\n    // Network information\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection\n      this.metrics.connection = {\n        effectiveType: connection.effectiveType || 'unknown',\n        downlink: connection.downlink || 0,\n        saveData: connection.saveData || false\n      }\n    }", "metadata": {}}
{"id": "507", "text": "/**\n   * Collect initial metrics\n   */\n  private collectInitialMetrics(): void {\n    // Network information\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection\n      this.metrics.connection = {\n        effectiveType: connection.effectiveType || 'unknown',\n        downlink: connection.downlink || 0,\n        saveData: connection.saveData || false\n      }\n    }\n\n    // Memory information\n    if ('memory' in performance) {\n      const memory = (performance as any).memory\n      this.metrics.memory = {\n        usedJSHeapSize: memory.usedJSHeapSize || 0,\n        totalJSHeapSize: memory.totalJSHeapSize || 0,\n        jsHeapSizeLimit: memory.jsHeapSizeLimit || 0\n      }\n    }\n\n    // Initial load time\n    if (document.readyState === 'complete') {\n      this.metrics.loadTimes.initial = performance.now() - this.startTime\n    } else {\n      window.addEventListener('load', () => {\n        this.metrics.loadTimes.initial = performance.now() - this.startTime\n      })\n    }\n  }", "metadata": {}}
{"id": "508", "text": "// Initial load time\n    if (document.readyState === 'complete') {\n      this.metrics.loadTimes.initial = performance.now() - this.startTime\n    } else {\n      window.addEventListener('load', () => {\n        this.metrics.loadTimes.initial = performance.now() - this.startTime\n      })\n    }\n  }\n\n  /**\n   * Process performance entries\n   */\n  private processPerformanceEntry(entry: PerformanceEntry): void {\n    if (entry.entryType === 'resource') {\n      const resourceEntry = entry as PerformanceResourceTiming\n\n      // Track JavaScript chunks\n      if (resourceEntry.name.includes('.js')) {\n        const chunkName = this.extractChunkName(resourceEntry.name)\n        this.metrics.loadTimes.chunks[chunkName] = resourceEntry.duration\n        this.metrics.chunksLoaded++\n\n        // Estimate bundle size (rough approximation)\n        if (resourceEntry.transferSize) {\n          this.metrics.totalSize += resourceEntry.transferSize\n        }\n      }\n    }", "metadata": {}}
{"id": "509", "text": "// Track JavaScript chunks\n      if (resourceEntry.name.includes('.js')) {\n        const chunkName = this.extractChunkName(resourceEntry.name)\n        this.metrics.loadTimes.chunks[chunkName] = resourceEntry.duration\n        this.metrics.chunksLoaded++\n\n        // Estimate bundle size (rough approximation)\n        if (resourceEntry.transferSize) {\n          this.metrics.totalSize += resourceEntry.transferSize\n        }\n      }\n    }\n\n    // Calculate average load time\n    const chunkTimes = Object.values(this.metrics.loadTimes.chunks)\n    this.metrics.loadTimes.average = chunkTimes.length > 0\n      ? chunkTimes.reduce((sum, time) => sum + time, 0) / chunkTimes.length\n      : 0\n  }\n\n  /**\n   * Extract chunk name from URL\n   */\n  private extractChunkName(url: string): string {\n    const parts = url.split('/')\n    const filename = parts[parts.length - 1]\n    return filename.split('.')[0] || 'unknown'\n  }", "metadata": {}}
{"id": "510", "text": "// Calculate average load time\n    const chunkTimes = Object.values(this.metrics.loadTimes.chunks)\n    this.metrics.loadTimes.average = chunkTimes.length > 0\n      ? chunkTimes.reduce((sum, time) => sum + time, 0) / chunkTimes.length\n      : 0\n  }\n\n  /**\n   * Extract chunk name from URL\n   */\n  private extractChunkName(url: string): string {\n    const parts = url.split('/')\n    const filename = parts[parts.length - 1]\n    return filename.split('.')[0] || 'unknown'\n  }\n\n  /**\n   * Get current bundle metrics\n   */\n  getMetrics(): BundleMetrics {\n    // Update memory if available\n    if ('memory' in performance) {\n      const memory = (performance as any).memory\n      this.metrics.memory = {\n        usedJSHeapSize: memory.usedJSHeapSize || 0,\n        totalJSHeapSize: memory.totalJSHeapSize || 0,\n        jsHeapSizeLimit: memory.jsHeapSizeLimit || 0\n      }\n    }\n\n    return { ...this.metrics }\n  }", "metadata": {}}
{"id": "511", "text": "/**\n   * Get current bundle metrics\n   */\n  getMetrics(): BundleMetrics {\n    // Update memory if available\n    if ('memory' in performance) {\n      const memory = (performance as any).memory\n      this.metrics.memory = {\n        usedJSHeapSize: memory.usedJSHeapSize || 0,\n        totalJSHeapSize: memory.totalJSHeapSize || 0,\n        jsHeapSizeLimit: memory.jsHeapSizeLimit || 0\n      }\n    }\n\n    return { ...this.metrics }\n  }\n\n  /**\n   * Generate optimization recommendations\n   */\n  getRecommendations(): OptimizationRecommendations {\n    const metrics = this.getMetrics()\n\n    // Base recommendations on connection and performance\n    const isSlowConnection = metrics.connection?.effectiveType === '2g' ||\n                           metrics.connection?.effectiveType === 'slow-2g' ||\n                           (metrics.connection?.downlink || 0) < 1\n\n    const isHighMemoryUsage = metrics.memory &&\n                             (metrics.memory.usedJSHeapSize / metrics.memory.jsHeapSizeLimit) > 0.7", "metadata": {}}
{"id": "512", "text": "return { ...this.metrics }\n  }\n\n  /**\n   * Generate optimization recommendations\n   */\n  getRecommendations(): OptimizationRecommendations {\n    const metrics = this.getMetrics()\n\n    // Base recommendations on connection and performance\n    const isSlowConnection = metrics.connection?.effectiveType === '2g' ||\n                           metrics.connection?.effectiveType === 'slow-2g' ||\n                           (metrics.connection?.downlink || 0) < 1\n\n    const isHighMemoryUsage = metrics.memory &&\n                             (metrics.memory.usedJSHeapSize / metrics.memory.jsHeapSizeLimit) > 0.7\n\n    const isSlowLoading = metrics.loadTimes.average > 1000 // 1 second", "metadata": {}}
{"id": "513", "text": "// Base recommendations on connection and performance\n    const isSlowConnection = metrics.connection?.effectiveType === '2g' ||\n                           metrics.connection?.effectiveType === 'slow-2g' ||\n                           (metrics.connection?.downlink || 0) < 1\n\n    const isHighMemoryUsage = metrics.memory &&\n                             (metrics.memory.usedJSHeapSize / metrics.memory.jsHeapSizeLimit) > 0.7\n\n    const isSlowLoading = metrics.loadTimes.average > 1000 // 1 second\n\n    return {\n      enableLazyLoading: isSlowConnection || isHighMemoryUsage || metrics.chunksLoaded > 10,\n      enablePreloading: !isSlowConnection && !metrics.connection?.saveData,\n      deferNonCritical: isSlowConnection || isSlowLoading,\n      chunkSizeRecommendation: {\n        maxSize: isSlowConnection ? 50000 : 200000, // 50KB or 200KB\n        reason: isSlowConnection\n          ? 'Slow connection detected - smaller chunks recommended'\n          : 'Normal connection - standard chunk sizes acceptable'\n      }\n    }\n  }", "metadata": {}}
{"id": "514", "text": "return {\n      enableLazyLoading: isSlowConnection || isHighMemoryUsage || metrics.chunksLoaded > 10,\n      enablePreloading: !isSlowConnection && !metrics.connection?.saveData,\n      deferNonCritical: isSlowConnection || isSlowLoading,\n      chunkSizeRecommendation: {\n        maxSize: isSlowConnection ? 50000 : 200000, // 50KB or 200KB\n        reason: isSlowConnection\n          ? 'Slow connection detected - smaller chunks recommended'\n          : 'Normal connection - standard chunk sizes acceptable'\n      }\n    }\n  }\n\n  /**\n   * Log performance report to console\n   */\n  logReport(): void {\n    const metrics = this.getMetrics()\n    const recommendations = this.getRecommendations()\n\n    console.group('📦 Bundle Optimization Report')", "metadata": {}}
{"id": "515", "text": "/**\n   * Log performance report to console\n   */\n  logReport(): void {\n    const metrics = this.getMetrics()\n    const recommendations = this.getRecommendations()\n\n    console.group('📦 Bundle Optimization Report')\n\n    console.log('Bundle Metrics:', {\n      'Total Size': `${(metrics.totalSize / 1024).toFixed(2)} KB`,\n      'Chunks Loaded': metrics.chunksLoaded,\n      'Initial Load Time': `${metrics.loadTimes.initial.toFixed(2)}ms`,\n      'Average Chunk Load Time': `${metrics.loadTimes.average.toFixed(2)}ms`\n    })\n\n    if (metrics.connection) {\n      console.log('Connection:', {\n        'Effective Type': metrics.connection.effectiveType,\n        'Downlink': `${metrics.connection.downlink} Mbps`,\n        'Save Data': metrics.connection.saveData\n      })\n    }", "metadata": {}}
{"id": "516", "text": "if (metrics.connection) {\n      console.log('Connection:', {\n        'Effective Type': metrics.connection.effectiveType,\n        'Downlink': `${metrics.connection.downlink} Mbps`,\n        'Save Data': metrics.connection.saveData\n      })\n    }\n\n    if (metrics.memory) {\n      console.log('Memory Usage:', {\n        'Used Heap': `${(metrics.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,\n        'Total Heap': `${(metrics.memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,\n        'Heap Limit': `${(metrics.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`\n      })\n    }\n\n    console.log('Recommendations:', recommendations)\n    console.groupEnd()\n  }", "metadata": {}}
{"id": "517", "text": "if (metrics.memory) {\n      console.log('Memory Usage:', {\n        'Used Heap': `${(metrics.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,\n        'Total Heap': `${(metrics.memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,\n        'Heap Limit': `${(metrics.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`\n      })\n    }\n\n    console.log('Recommendations:', recommendations)\n    console.groupEnd()\n  }\n\n  /**\n   * Check if bundle optimization is working effectively\n   */\n  evaluateOptimization(): {\n    score: number // 0-100\n    issues: string[]\n    suggestions: string[]\n  } {\n    const metrics = this.getMetrics()\n    const issues: string[] = []\n    const suggestions: string[] = []\n    let score = 100", "metadata": {}}
{"id": "518", "text": "console.log('Recommendations:', recommendations)\n    console.groupEnd()\n  }\n\n  /**\n   * Check if bundle optimization is working effectively\n   */\n  evaluateOptimization(): {\n    score: number // 0-100\n    issues: string[]\n    suggestions: string[]\n  } {\n    const metrics = this.getMetrics()\n    const issues: string[] = []\n    const suggestions: string[] = []\n    let score = 100\n\n    // Check bundle size\n    if (metrics.totalSize > 1024 * 1024) { // 1MB\n      score -= 20\n      issues.push('Bundle size exceeds 1MB')\n      suggestions.push('Consider code splitting and lazy loading')\n    }\n\n    // Check load times\n    if (metrics.loadTimes.initial > 3000) { // 3 seconds\n      score -= 30\n      issues.push('Initial load time is slow')\n      suggestions.push('Optimize critical path and defer non-essential resources')\n    }", "metadata": {}}
{"id": "519", "text": "// Check bundle size\n    if (metrics.totalSize > 1024 * 1024) { // 1MB\n      score -= 20\n      issues.push('Bundle size exceeds 1MB')\n      suggestions.push('Consider code splitting and lazy loading')\n    }\n\n    // Check load times\n    if (metrics.loadTimes.initial > 3000) { // 3 seconds\n      score -= 30\n      issues.push('Initial load time is slow')\n      suggestions.push('Optimize critical path and defer non-essential resources')\n    }\n\n    // Check chunk count\n    if (metrics.chunksLoaded > 20) {\n      score -= 15\n      issues.push('Too many chunks loaded')\n      suggestions.push('Consider combining smaller chunks')\n    }\n\n    // Check memory usage\n    if (metrics.memory && (metrics.memory.usedJSHeapSize / metrics.memory.jsHeapSizeLimit) > 0.8) {\n      score -= 25\n      issues.push('High memory usage detected')\n      suggestions.push('Implement memory optimization strategies')\n    }", "metadata": {}}
{"id": "520", "text": "// Check chunk count\n    if (metrics.chunksLoaded > 20) {\n      score -= 15\n      issues.push('Too many chunks loaded')\n      suggestions.push('Consider combining smaller chunks')\n    }\n\n    // Check memory usage\n    if (metrics.memory && (metrics.memory.usedJSHeapSize / metrics.memory.jsHeapSizeLimit) > 0.8) {\n      score -= 25\n      issues.push('High memory usage detected')\n      suggestions.push('Implement memory optimization strategies')\n    }\n\n    return {\n      score: Math.max(0, score),\n      issues,\n      suggestions\n    }\n  }\n\n  /**\n   * Clean up observers\n   */\n  dispose(): void {\n    Object.values(this.observers).forEach(observer => {\n      if (observer) {\n        observer.disconnect()\n      }\n    })\n  }\n}\n\n// Global bundle optimizer instance\nexport const bundleOptimizer = new BundleOptimizer()", "metadata": {}}
{"id": "521", "text": "return {\n      score: Math.max(0, score),\n      issues,\n      suggestions\n    }\n  }\n\n  /**\n   * Clean up observers\n   */\n  dispose(): void {\n    Object.values(this.observers).forEach(observer => {\n      if (observer) {\n        observer.disconnect()\n      }\n    })\n  }\n}\n\n// Global bundle optimizer instance\nexport const bundleOptimizer = new BundleOptimizer()\n\n// React hook for bundle optimization\nexport function useBundleOptimization() {\n  const [metrics, setMetrics] = React.useState<BundleMetrics | null>(null)\n  const [recommendations, setRecommendations] = React.useState<OptimizationRecommendations | null>(null)\n\n  React.useEffect(() => {\n    // Initial metrics\n    setMetrics(bundleOptimizer.getMetrics())\n    setRecommendations(bundleOptimizer.getRecommendations())\n\n    // Update metrics periodically\n    const interval = typeof setInterval !== 'undefined' ? setInterval(() => {\n      setMetrics(bundleOptimizer.getMetrics())\n      setRecommendations(bundleOptimizer.getRecommendations())\n    }, 5000) : null", "metadata": {}}
{"id": "522", "text": "React.useEffect(() => {\n    // Initial metrics\n    setMetrics(bundleOptimizer.getMetrics())\n    setRecommendations(bundleOptimizer.getRecommendations())\n\n    // Update metrics periodically\n    const interval = typeof setInterval !== 'undefined' ? setInterval(() => {\n      setMetrics(bundleOptimizer.getMetrics())\n      setRecommendations(bundleOptimizer.getRecommendations())\n    }, 5000) : null\n\n    return () => {\n      if (interval && typeof clearInterval !== 'undefined') {\n        clearInterval(interval)\n      }\n    }\n  }, [])\n\n  const logReport = React.useCallback(() => {\n    bundleOptimizer.logReport()\n  }, [])\n\n  const evaluateOptimization = React.useCallback(() => {\n    return bundleOptimizer.evaluateOptimization()\n  }, [])\n\n  return {\n    metrics,\n    recommendations,\n    logReport,\n    evaluateOptimization\n  }\n}\n\n// Utility for dynamic import with error handling\nexport async function safeDynamicImport<T>(\n  importFunction: () => Promise<T>,\n  fallback?: T,\n  retries: number = 3\n): Promise<T> {\n  let lastError: Error | null = null", "metadata": {}}
{"id": "523", "text": "const logReport = React.useCallback(() => {\n    bundleOptimizer.logReport()\n  }, [])\n\n  const evaluateOptimization = React.useCallback(() => {\n    return bundleOptimizer.evaluateOptimization()\n  }, [])\n\n  return {\n    metrics,\n    recommendations,\n    logReport,\n    evaluateOptimization\n  }\n}\n\n// Utility for dynamic import with error handling\nexport async function safeDynamicImport<T>(\n  importFunction: () => Promise<T>,\n  fallback?: T,\n  retries: number = 3\n): Promise<T> {\n  let lastError: Error | null = null\n\n  for (let attempt = 1; attempt <= retries; attempt++) {\n    try {\n      return await importFunction()\n    } catch (error) {\n      lastError = error as Error\n      console.warn(`Dynamic import attempt ${attempt} failed:`, error)", "metadata": {}}
{"id": "524", "text": "// Utility for dynamic import with error handling\nexport async function safeDynamicImport<T>(\n  importFunction: () => Promise<T>,\n  fallback?: T,\n  retries: number = 3\n): Promise<T> {\n  let lastError: Error | null = null\n\n  for (let attempt = 1; attempt <= retries; attempt++) {\n    try {\n      return await importFunction()\n    } catch (error) {\n      lastError = error as Error\n      console.warn(`Dynamic import attempt ${attempt} failed:`, error)\n\n      if (attempt < retries) {\n        // Wait before retrying (exponential backoff)\n        await new Promise(resolve => {\n          if (typeof setTimeout !== 'undefined') {\n            setTimeout(resolve, Math.pow(2, attempt) * 1000)\n          } else {\n            resolve(undefined)\n          }\n        })\n      }\n    }\n  }\n\n  if (fallback !== undefined) {\n    console.error('Dynamic import failed after all retries, using fallback:', lastError)\n    return fallback\n  }\n\n  throw lastError\n}", "metadata": {}}
{"id": "525", "text": "if (attempt < retries) {\n        // Wait before retrying (exponential backoff)\n        await new Promise(resolve => {\n          if (typeof setTimeout !== 'undefined') {\n            setTimeout(resolve, Math.pow(2, attempt) * 1000)\n          } else {\n            resolve(undefined)\n          }\n        })\n      }\n    }\n  }\n\n  if (fallback !== undefined) {\n    console.error('Dynamic import failed after all retries, using fallback:', lastError)\n    return fallback\n  }\n\n  throw lastError\n}\n\n// Development-only bundle analyzer\nif (process.env.NODE_ENV === 'development' && typeof window !== 'undefined') {\n  // Log initial report after 5 seconds\n  setTimeout(() => {\n    bundleOptimizer.logReport()\n  }, 5000)\n\n  // Global access for debugging\n  (window as any).__bundleOptimizer = bundleOptimizer\n}", "metadata": {}}
{"id": "526", "text": "/**\n * Image Preloader Utilities\n * Provides intelligent image preloading for smooth user experience\n */\n\nexport interface PreloadOptions {\n  /** Priority levels for preloading */\n  priority?: 'high' | 'medium' | 'low'\n  /** Maximum concurrent preloads */\n  maxConcurrent?: number\n  /** Timeout for preload attempts */\n  timeout?: number\n  /** Enable/disable preloading based on connection */\n  respectDataSaver?: boolean\n  /** Enable/disable based on memory constraints */\n  respectMemoryConstraints?: boolean\n}\n\nexport interface PreloadResult {\n  /** Whether the image was successfully preloaded */\n  success: boolean\n  /** Error message if preload failed */\n  error?: string\n  /** Preload duration in milliseconds */\n  duration: number\n  /** Size of preloaded image */\n  size?: { width: number; height: number }\n}", "metadata": {}}
{"id": "527", "text": "export interface PreloadResult {\n  /** Whether the image was successfully preloaded */\n  success: boolean\n  /** Error message if preload failed */\n  error?: string\n  /** Preload duration in milliseconds */\n  duration: number\n  /** Size of preloaded image */\n  size?: { width: number; height: number }\n}\n\nexport interface PreloadStats {\n  /** Total images preloaded */\n  total: number\n  /** Successful preloads */\n  successful: number\n  /** Failed preloads */\n  failed: number\n  /** Total preload time */\n  totalTime: number\n  /** Average preload time */\n  averageTime: number\n  /** Cache hit rate */\n  cacheHitRate: number\n}\n\nclass ImagePreloader {\n  private cache = new Map<string, HTMLImageElement>()\n  private loadingPromises = new Map<string, Promise<PreloadResult>>()\n  private stats: PreloadStats = {\n    total: 0,\n    successful: 0,\n    failed: 0,\n    totalTime: 0,\n    averageTime: 0,\n    cacheHitRate: 0\n  }", "metadata": {}}
{"id": "528", "text": "class ImagePreloader {\n  private cache = new Map<string, HTMLImageElement>()\n  private loadingPromises = new Map<string, Promise<PreloadResult>>()\n  private stats: PreloadStats = {\n    total: 0,\n    successful: 0,\n    failed: 0,\n    totalTime: 0,\n    averageTime: 0,\n    cacheHitRate: 0\n  }\n\n  private readonly defaultOptions: Required<PreloadOptions> = {\n    priority: 'medium',\n    maxConcurrent: 6,\n    timeout: 10000,\n    respectDataSaver: true,\n    respectMemoryConstraints: true\n  }\n\n  /**\n   * Preload a single image\n   */\n  async preload(url: string, options: PreloadOptions = {}): Promise<PreloadResult> {\n    const mergedOptions = { ...this.defaultOptions, ...options }", "metadata": {}}
{"id": "529", "text": "private readonly defaultOptions: Required<PreloadOptions> = {\n    priority: 'medium',\n    maxConcurrent: 6,\n    timeout: 10000,\n    respectDataSaver: true,\n    respectMemoryConstraints: true\n  }\n\n  /**\n   * Preload a single image\n   */\n  async preload(url: string, options: PreloadOptions = {}): Promise<PreloadResult> {\n    const mergedOptions = { ...this.defaultOptions, ...options }\n\n    // Check if already cached\n    if (this.cache.has(url)) {\n      this.updateStats({ success: true, duration: 0, fromCache: true })\n      return {\n        success: true,\n        duration: 0,\n        size: {\n          width: this.cache.get(url)!.naturalWidth,\n          height: this.cache.get(url)!.naturalHeight\n        }\n      }\n    }\n\n    // Check if already loading\n    if (this.loadingPromises.has(url)) {\n      return this.loadingPromises.get(url)!\n    }", "metadata": {}}
{"id": "530", "text": "// Check if already cached\n    if (this.cache.has(url)) {\n      this.updateStats({ success: true, duration: 0, fromCache: true })\n      return {\n        success: true,\n        duration: 0,\n        size: {\n          width: this.cache.get(url)!.naturalWidth,\n          height: this.cache.get(url)!.naturalHeight\n        }\n      }\n    }\n\n    // Check if already loading\n    if (this.loadingPromises.has(url)) {\n      return this.loadingPromises.get(url)!\n    }\n\n    // Check constraints before loading\n    if (!this.shouldPreload(mergedOptions)) {\n      return {\n        success: false,\n        error: 'Preloading skipped due to constraints',\n        duration: 0\n      }\n    }\n\n    const loadPromise = this.loadImage(url, mergedOptions)\n    this.loadingPromises.set(url, loadPromise)", "metadata": {}}
{"id": "531", "text": "// Check if already loading\n    if (this.loadingPromises.has(url)) {\n      return this.loadingPromises.get(url)!\n    }\n\n    // Check constraints before loading\n    if (!this.shouldPreload(mergedOptions)) {\n      return {\n        success: false,\n        error: 'Preloading skipped due to constraints',\n        duration: 0\n      }\n    }\n\n    const loadPromise = this.loadImage(url, mergedOptions)\n    this.loadingPromises.set(url, loadPromise)\n\n    try {\n      const result = await loadPromise\n      if (result.success) {\n        // Cache successful loads\n        const img = new Image()\n        img.src = url\n        this.cache.set(url, img)\n      }\n      return result\n    } finally {\n      this.loadingPromises.delete(url)\n    }\n  }", "metadata": {}}
{"id": "532", "text": "const loadPromise = this.loadImage(url, mergedOptions)\n    this.loadingPromises.set(url, loadPromise)\n\n    try {\n      const result = await loadPromise\n      if (result.success) {\n        // Cache successful loads\n        const img = new Image()\n        img.src = url\n        this.cache.set(url, img)\n      }\n      return result\n    } finally {\n      this.loadingPromises.delete(url)\n    }\n  }\n\n  /**\n   * Preload multiple images with priority queue\n   */\n  async preloadBatch(\n    urls: Array<{ url: string; priority?: PreloadOptions['priority'] }>,\n    options: PreloadOptions = {}\n  ): Promise<PreloadResult[]> {\n    const mergedOptions = { ...this.defaultOptions, ...options }\n\n    // Sort by priority\n    const sortedUrls = urls.sort((a, b) => {\n      const priorityOrder = { high: 3, medium: 2, low: 1 }\n      return priorityOrder[b.priority || 'medium'] - priorityOrder[a.priority || 'medium']\n    })", "metadata": {}}
{"id": "533", "text": "// Sort by priority\n    const sortedUrls = urls.sort((a, b) => {\n      const priorityOrder = { high: 3, medium: 2, low: 1 }\n      return priorityOrder[b.priority || 'medium'] - priorityOrder[a.priority || 'medium']\n    })\n\n    // Process in chunks respecting concurrency limits\n    const results: PreloadResult[] = []\n    for (let i = 0; i < sortedUrls.length; i += mergedOptions.maxConcurrent) {\n      const chunk = sortedUrls.slice(i, i + mergedOptions.maxConcurrent)\n      const chunkResults = await Promise.all(\n        chunk.map(item => this.preload(item.url, { ...mergedOptions, priority: item.priority }))\n      )\n      results.push(...chunkResults)\n    }\n\n    return results\n  }", "metadata": {}}
{"id": "534", "text": "// Process in chunks respecting concurrency limits\n    const results: PreloadResult[] = []\n    for (let i = 0; i < sortedUrls.length; i += mergedOptions.maxConcurrent) {\n      const chunk = sortedUrls.slice(i, i + mergedOptions.maxConcurrent)\n      const chunkResults = await Promise.all(\n        chunk.map(item => this.preload(item.url, { ...mergedOptions, priority: item.priority }))\n      )\n      results.push(...chunkResults)\n    }\n\n    return results\n  }\n\n  /**\n   * Preload images in viewport and adjacent areas\n   */\n  async preloadInViewport(\n    imageUrls: string[],\n    viewportBuffer: number = 1,\n    options: PreloadOptions = {}\n  ): Promise<void> {\n    // This would integrate with IntersectionObserver in a real implementation\n    // For now, we'll preload based on priority\n    const prioritizedUrls = imageUrls.map((url, index) => ({\n      url,\n      priority: index < 10 ? 'high' : index < 50 ? 'medium' : 'low' as const\n    }))", "metadata": {}}
{"id": "535", "text": "/**\n   * Preload images in viewport and adjacent areas\n   */\n  async preloadInViewport(\n    imageUrls: string[],\n    viewportBuffer: number = 1,\n    options: PreloadOptions = {}\n  ): Promise<void> {\n    // This would integrate with IntersectionObserver in a real implementation\n    // For now, we'll preload based on priority\n    const prioritizedUrls = imageUrls.map((url, index) => ({\n      url,\n      priority: index < 10 ? 'high' : index < 50 ? 'medium' : 'low' as const\n    }))\n\n    await this.preloadBatch(prioritizedUrls, options)\n  }", "metadata": {}}
{"id": "536", "text": "await this.preloadBatch(prioritizedUrls, options)\n  }\n\n  /**\n   * Smart preloading based on user behavior patterns\n   */\n  async smartPreload(\n    images: Array<{ url: string; importance: number; userInteraction?: boolean }>,\n    options: PreloadOptions = {}\n  ): Promise<PreloadResult[]> {\n    // Sort by importance and user interaction signals\n    const smartSorted = images\n      .sort((a, b) => {\n        // User interaction signals get highest priority\n        if (a.userInteraction && !b.userInteraction) return -1\n        if (!a.userInteraction && b.userInteraction) return 1\n\n        // Then sort by importance score\n        return b.importance - a.importance\n      })\n      .map(item => ({\n        url: item.url,\n        priority: item.userInteraction ? 'high' :\n                 item.importance > 0.7 ? 'high' :\n                 item.importance > 0.3 ? 'medium' : 'low' as const\n      }))\n\n    return this.preloadBatch(smartSorted, options)\n  }", "metadata": {}}
{"id": "537", "text": "// Then sort by importance score\n        return b.importance - a.importance\n      })\n      .map(item => ({\n        url: item.url,\n        priority: item.userInteraction ? 'high' :\n                 item.importance > 0.7 ? 'high' :\n                 item.importance > 0.3 ? 'medium' : 'low' as const\n      }))\n\n    return this.preloadBatch(smartSorted, options)\n  }\n\n  /**\n   * Clear cache and stats\n   */\n  clear(): void {\n    this.cache.clear()\n    this.loadingPromises.clear()\n    this.stats = {\n      total: 0,\n      successful: 0,\n      failed: 0,\n      totalTime: 0,\n      averageTime: 0,\n      cacheHitRate: 0\n    }\n  }\n\n  /**\n   * Get current preloading statistics\n   */\n  getStats(): PreloadStats {\n    return { ...this.stats }\n  }", "metadata": {}}
{"id": "538", "text": "return this.preloadBatch(smartSorted, options)\n  }\n\n  /**\n   * Clear cache and stats\n   */\n  clear(): void {\n    this.cache.clear()\n    this.loadingPromises.clear()\n    this.stats = {\n      total: 0,\n      successful: 0,\n      failed: 0,\n      totalTime: 0,\n      averageTime: 0,\n      cacheHitRate: 0\n    }\n  }\n\n  /**\n   * Get current preloading statistics\n   */\n  getStats(): PreloadStats {\n    return { ...this.stats }\n  }\n\n  /**\n   * Get cache size and memory usage estimate\n   */\n  getCacheInfo(): { size: number; memoryEstimateMB: number } {\n    const size = this.cache.size\n    // Rough estimate: average image ~100KB\n    const memoryEstimateMB = (size * 100) / 1024\n    return { size, memoryEstimateMB }\n  }", "metadata": {}}
{"id": "539", "text": "/**\n   * Get current preloading statistics\n   */\n  getStats(): PreloadStats {\n    return { ...this.stats }\n  }\n\n  /**\n   * Get cache size and memory usage estimate\n   */\n  getCacheInfo(): { size: number; memoryEstimateMB: number } {\n    const size = this.cache.size\n    // Rough estimate: average image ~100KB\n    const memoryEstimateMB = (size * 100) / 1024\n    return { size, memoryEstimateMB }\n  }\n\n  /**\n   * Load a single image with timeout and error handling\n   */\n  private loadImage(url: string, options: Required<PreloadOptions>): Promise<PreloadResult> {\n    return new Promise((resolve) => {\n      const startTime = performance.now()\n      const img = new Image()", "metadata": {}}
{"id": "540", "text": "/**\n   * Load a single image with timeout and error handling\n   */\n  private loadImage(url: string, options: Required<PreloadOptions>): Promise<PreloadResult> {\n    return new Promise((resolve) => {\n      const startTime = performance.now()\n      const img = new Image()\n\n      // Set up timeout\n      const timeout = setTimeout(() => {\n        this.updateStats({ success: false, duration: performance.now() - startTime })\n        resolve({\n          success: false,\n          error: 'Timeout',\n          duration: performance.now() - startTime\n        })\n      }, options.timeout)\n\n      // Success handler\n      img.onload = () => {\n        clearTimeout(timeout)\n        const duration = performance.now() - startTime\n        this.updateStats({ success: true, duration })\n        resolve({\n          success: true,\n          duration,\n          size: {\n            width: img.naturalWidth,\n            height: img.naturalHeight\n          }\n        })\n      }", "metadata": {}}
{"id": "541", "text": "// Success handler\n      img.onload = () => {\n        clearTimeout(timeout)\n        const duration = performance.now() - startTime\n        this.updateStats({ success: true, duration })\n        resolve({\n          success: true,\n          duration,\n          size: {\n            width: img.naturalWidth,\n            height: img.naturalHeight\n          }\n        })\n      }\n\n      // Error handler\n      img.onerror = () => {\n        clearTimeout(timeout)\n        const duration = performance.now() - startTime\n        this.updateStats({ success: false, duration })\n        resolve({\n          success: false,\n          error: 'Load error',\n          duration\n        })\n      }\n\n      // Start loading\n      img.src = url\n    })\n  }", "metadata": {}}
{"id": "542", "text": "// Error handler\n      img.onerror = () => {\n        clearTimeout(timeout)\n        const duration = performance.now() - startTime\n        this.updateStats({ success: false, duration })\n        resolve({\n          success: false,\n          error: 'Load error',\n          duration\n        })\n      }\n\n      // Start loading\n      img.src = url\n    })\n  }\n\n  /**\n   * Check if preloading should proceed based on constraints\n   */\n  private shouldPreload(options: Required<PreloadOptions>): boolean {\n    // Check data saver mode\n    if (options.respectDataSaver && 'connection' in navigator) {\n      const connection = (navigator as any).connection\n      if (connection && connection.saveData) {\n        return false\n      }\n    }\n\n    // Check memory constraints\n    if (options.respectMemoryConstraints) {\n      const cacheInfo = this.getCacheInfo()\n      // Don't preload if cache is using more than 50MB\n      if (cacheInfo.memoryEstimateMB > 50) {\n        return false\n      }", "metadata": {}}
{"id": "543", "text": "// Check memory constraints\n    if (options.respectMemoryConstraints) {\n      const cacheInfo = this.getCacheInfo()\n      // Don't preload if cache is using more than 50MB\n      if (cacheInfo.memoryEstimateMB > 50) {\n        return false\n      }\n\n      // Check device memory if available\n      if ('deviceMemory' in navigator) {\n        const deviceMemory = (navigator as any).deviceMemory\n        // Don't preload on devices with less than 2GB RAM\n        if (deviceMemory && deviceMemory < 2) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Update internal statistics\n   */\n  private updateStats(result: { success: boolean; duration: number; fromCache?: boolean }): void {\n    this.stats.total++\n\n    if (result.success) {\n      this.stats.successful++\n    } else {\n      this.stats.failed++\n    }\n\n    this.stats.totalTime += result.duration\n    this.stats.averageTime = this.stats.totalTime / this.stats.total", "metadata": {}}
{"id": "544", "text": "return true\n  }\n\n  /**\n   * Update internal statistics\n   */\n  private updateStats(result: { success: boolean; duration: number; fromCache?: boolean }): void {\n    this.stats.total++\n\n    if (result.success) {\n      this.stats.successful++\n    } else {\n      this.stats.failed++\n    }\n\n    this.stats.totalTime += result.duration\n    this.stats.averageTime = this.stats.totalTime / this.stats.total\n\n    if (result.fromCache) {\n      this.stats.cacheHitRate = (this.stats.cacheHitRate * (this.stats.total - 1) + 1) / this.stats.total\n    } else {\n      this.stats.cacheHitRate = (this.stats.cacheHitRate * (this.stats.total - 1)) / this.stats.total\n    }\n  }\n}\n\n// Global preloader instance\nexport const imagePreloader = new ImagePreloader()", "metadata": {}}
{"id": "545", "text": "this.stats.totalTime += result.duration\n    this.stats.averageTime = this.stats.totalTime / this.stats.total\n\n    if (result.fromCache) {\n      this.stats.cacheHitRate = (this.stats.cacheHitRate * (this.stats.total - 1) + 1) / this.stats.total\n    } else {\n      this.stats.cacheHitRate = (this.stats.cacheHitRate * (this.stats.total - 1)) / this.stats.total\n    }\n  }\n}\n\n// Global preloader instance\nexport const imagePreloader = new ImagePreloader()\n\n// React hook for component-level image preloading\nexport function useImagePreloader(options: PreloadOptions = {}) {\n  return {\n    preload: (url: string) => imagePreloader.preload(url, options),\n    preloadBatch: (urls: Array<{ url: string; priority?: PreloadOptions['priority'] }>) =>\n      imagePreloader.preloadBatch(urls, options),\n    preloadInViewport: (urls: string[], buffer?: number) =>\n      imagePreloader.preloadInViewport(urls, buffer, options),\n    smartPreload: (images: Array<{ url: string; importance: number; userInteraction?: boolean }>) =>\n      imagePreloader.smartPreload(images, options),\n    getStats: () => imagePreloader.getStats(),\n    getCacheInfo: () => imagePreloader.getCacheInfo(),\n    clear: () => imagePreloader.clear()\n  }\n}", "metadata": {}}
{"id": "546", "text": "// Utility for automatic viewport-based preloading\nexport function createIntersectionPreloader(\n  options: PreloadOptions & { rootMargin?: string; threshold?: number } = {}\n) {\n  const { rootMargin = '100px', threshold = 0.1, ...preloadOptions } = options\n\n  return new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          const imgElement = entry.target as HTMLImageElement\n          const src = imgElement.dataset.src || imgElement.src\n\n          if (src) {\n            imagePreloader.preload(src, preloadOptions).then((result) => {\n              if (result.success) {\n                imgElement.src = src\n                imgElement.classList.remove('preloading')\n                imgElement.classList.add('loaded')\n              }\n            })\n          }\n        }\n      })\n    },\n    { rootMargin, threshold }\n  )\n}", "metadata": {}}
{"id": "547", "text": "import { Image } from '../types/image';\n\n/**\n * Generate a display URL for an image\n */\nexport function getImageUrl(image: Image): string {\n  // If we have a blob URL, use it directly\n  if (image.url.startsWith('blob:')) {\n    return image.url;\n  }\n  \n  // If we have a data URL, use it directly\n  if (image.url.startsWith('data:')) {\n    return image.url;\n  }\n  \n  // For remote URLs, ensure they're absolute\n  if (image.url.startsWith('http')) {\n    return image.url;\n  }\n  \n  // For relative paths, construct API URL\n  if (image.url.startsWith('/')) {\n    // In development, we might need to add the base URL\n    if (process.env.NODE_ENV === 'development') {\n      return `http://localhost:5173${image.url}`;\n    }\n    return image.url;\n  }\n  \n  // Fallback to API endpoint\n  return `/api/images/${image.id}/file`;\n}", "metadata": {}}
{"id": "548", "text": "/**\n * Generate a thumbnail URL for an image\n */\nexport function getThumbnailUrl(image: Image, size: 'small' | 'medium' | 'large' = 'medium'): string {\n  const sizeMap = {\n    small: '150x150',\n    medium: '300x300',\n    large: '600x600',\n  };\n  \n  // If we have a blob URL, we can't generate thumbnails on the fly\n  // In a real app, this would be handled by the server\n  if (image.url.startsWith('blob:') || image.url.startsWith('data:')) {\n    return image.url;\n  }\n  \n  return `/api/images/${image.id}/thumbnail?size=${sizeMap[size]}`;\n}", "metadata": {}}
{"id": "549", "text": "/**\n * Format file size in human readable format\n */\nexport function formatFileSize(bytes: number): string {\n  if (bytes === 0) return '0 Bytes';\n  \n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  \n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\n/**\n * Format image dimensions\n */\nexport function formatDimensions(width?: number, height?: number): string {\n  if (!width || !height) return 'Unknown';\n  return `${width.toLocaleString()} × ${height.toLocaleString()} px`;\n}\n\n/**\n * Format date in a user-friendly way\n */\nexport function formatDate(date: Date | string): string {\n  const d = typeof date === 'string' ?", "metadata": {}}
{"id": "550", "text": "/**\n * Format image dimensions\n */\nexport function formatDimensions(width?: number, height?: number): string {\n  if (!width || !height) return 'Unknown';\n  return `${width.toLocaleString()} × ${height.toLocaleString()} px`;\n}\n\n/**\n * Format date in a user-friendly way\n */\nexport function formatDate(date: Date | string): string {\n  const d = typeof date === 'string' ? new Date(date) : date;\n  \n  // Check if the date is valid\n  if (isNaN(d.getTime())) {\n    return 'Invalid date';\n  }\n  \n  const now = new Date();\n  const diffInDays = Math.floor((now.getTime() - d.getTime()) / (1000 * 60 * 60 * 24));\n  \n  if (diffInDays === 0) {\n    return 'Today';\n  } else if (diffInDays === 1) {\n    return 'Yesterday';\n  } else if (diffInDays < 7) {\n    return `${diffInDays} days ago`;\n  } else if (diffInDays < 30) {\n    const weeks = Math.floor(diffInDays / 7);\n    return `${weeks} week${weeks > 1 ?", "metadata": {}}
{"id": "551", "text": "'s' : ''} ago`;\n  } else if (diffInDays < 365) {\n    const months = Math.floor(diffInDays / 30);\n    return `${months} month${months > 1 ? 's' : ''} ago`;\n  } else {\n    const years = Math.floor(diffInDays / 365);\n    return `${years} year${years > 1 ? 's' : ''} ago`;\n  }\n}\n\n/**\n * Get image orientation\n */\nexport function getImageOrientation(width?: number, height?: number): 'landscape' | 'portrait' | 'square' {\n  if (!width || !height) return 'landscape';\n  \n  if (width > height) return 'landscape';\n  if (height > width) return 'portrait';\n  return 'square';\n}\n\n/**\n * Calculate aspect ratio\n */\nexport function getAspectRatio(width?: number, height?: number): number {\n  if (!width || !height || height === 0) return 1;\n  return width / height;\n}", "metadata": {}}
{"id": "552", "text": "/**\n * Get image orientation\n */\nexport function getImageOrientation(width?: number, height?: number): 'landscape' | 'portrait' | 'square' {\n  if (!width || !height) return 'landscape';\n  \n  if (width > height) return 'landscape';\n  if (height > width) return 'portrait';\n  return 'square';\n}\n\n/**\n * Calculate aspect ratio\n */\nexport function getAspectRatio(width?: number, height?: number): number {\n  if (!width || !height || height === 0) return 1;\n  return width / height;\n}\n\n/**\n * Generate a safe filename for download\n */\nexport function getSafeFilename(image: Image): string {\n  // Remove special characters and spaces\n  const safeName = image.filename\n    .replace(/[^a-zA-Z0-9.-]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  // Ensure it has the correct extension\n  const extension = image.mimeType.split('/')[1]?.toLowerCase() || 'jpg';\n  if (!safeName.endsWith(`.${extension}`)) {\n    return `${safeName}.${extension}`;\n  }\n  \n  return safeName;\n}", "metadata": {}}
{"id": "553", "text": "/**\n * Debounce function for search inputs\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  \n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n/**\n * Check if an image is loaded\n */\nexport function isImageLoaded(img: HTMLImageElement): boolean {\n  return img.complete && img.naturalHeight !== 0;\n}\n\n/**\n * Preload an image\n */\nexport function preloadImage(url: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error(`Failed to load image: ${url}`));\n    img.src = url;\n  });\n}", "metadata": {}}
{"id": "554", "text": "/**\n * Performance monitoring utilities for infinite scroll and UI interactions\n * Tracks metrics like scroll performance, render times, and memory usage\n */\n\nexport interface PerformanceMetrics {\n  scrollFPS: number[]\n  renderTime: number[]\n  memoryUsage: number[]\n  loadTime: number[]\n  intersectionTime: number[]\n  timestamp: number\n}\n\nexport interface ScrollPerformanceOptions {\n  enableFPSMonitoring?: boolean\n  enableMemoryMonitoring?: boolean\n  enableRenderTimeMonitoring?: boolean\n  sampleSize?: number\n  reportingInterval?: number\n  onReport?: (metrics: PerformanceMetrics) => void\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetrics = {\n    scrollFPS: [],\n    renderTime: [],\n    memoryUsage: [],\n    loadTime: [],\n    intersectionTime: [],\n    timestamp: Date.now()\n  }\n\n  private options: Required<ScrollPerformanceOptions> = {\n    enableFPSMonitoring: true,\n    enableMemoryMonitoring: true,\n    enableRenderTimeMonitoring: true,\n    sampleSize: 100,\n    reportingInterval: 5000,\n    onReport: () => {}\n  }", "metadata": {}}
{"id": "555", "text": "class PerformanceMonitor {\n  private metrics: PerformanceMetrics = {\n    scrollFPS: [],\n    renderTime: [],\n    memoryUsage: [],\n    loadTime: [],\n    intersectionTime: [],\n    timestamp: Date.now()\n  }\n\n  private options: Required<ScrollPerformanceOptions> = {\n    enableFPSMonitoring: true,\n    enableMemoryMonitoring: true,\n    enableRenderTimeMonitoring: true,\n    sampleSize: 100,\n    reportingInterval: 5000,\n    onReport: () => {}\n  }\n\n  private isMonitoring = false\n  private animationFrameId: number | null = null\n  private reportingIntervalId: NodeJS.Timeout | null = null\n  private lastFrameTime = 0\n  private frameCount = 0\n  private fpsStartTime = 0\n\n  constructor(options: ScrollPerformanceOptions = {}) {\n    this.options = { ...this.options, ...options }\n  }\n\n  /**\n   * Start performance monitoring\n   */\n  start(): void {\n    if (this.isMonitoring) return", "metadata": {}}
{"id": "556", "text": "private isMonitoring = false\n  private animationFrameId: number | null = null\n  private reportingIntervalId: NodeJS.Timeout | null = null\n  private lastFrameTime = 0\n  private frameCount = 0\n  private fpsStartTime = 0\n\n  constructor(options: ScrollPerformanceOptions = {}) {\n    this.options = { ...this.options, ...options }\n  }\n\n  /**\n   * Start performance monitoring\n   */\n  start(): void {\n    if (this.isMonitoring) return\n\n    this.isMonitoring = true\n    this.fpsStartTime = performance.now()\n    this.lastFrameTime = performance.now()\n\n    if (this.options.enableFPSMonitoring) {\n      this.startFPSMonitoring()\n    }\n\n    if (this.options.reportingInterval > 0) {\n      this.reportingIntervalId = setInterval(() => {\n        this.generateReport()\n      }, this.options.reportingInterval)\n    }\n  }\n\n  /**\n   * Stop performance monitoring\n   */\n  stop(): void {\n    this.isMonitoring = false", "metadata": {}}
{"id": "557", "text": "this.isMonitoring = true\n    this.fpsStartTime = performance.now()\n    this.lastFrameTime = performance.now()\n\n    if (this.options.enableFPSMonitoring) {\n      this.startFPSMonitoring()\n    }\n\n    if (this.options.reportingInterval > 0) {\n      this.reportingIntervalId = setInterval(() => {\n        this.generateReport()\n      }, this.options.reportingInterval)\n    }\n  }\n\n  /**\n   * Stop performance monitoring\n   */\n  stop(): void {\n    this.isMonitoring = false\n\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId)\n      this.animationFrameId = null\n    }\n\n    if (this.reportingIntervalId) {\n      clearInterval(this.reportingIntervalId)\n      this.reportingIntervalId = null\n    }\n  }\n\n  /**\n   * Record render time for a specific operation\n   */\n  recordRenderTime(startTime: number): void {\n    if (!this.options.enableRenderTimeMonitoring) return\n\n    const renderTime = performance.now() - startTime\n    this.addMetric('renderTime', renderTime)\n  }", "metadata": {}}
{"id": "558", "text": "if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId)\n      this.animationFrameId = null\n    }\n\n    if (this.reportingIntervalId) {\n      clearInterval(this.reportingIntervalId)\n      this.reportingIntervalId = null\n    }\n  }\n\n  /**\n   * Record render time for a specific operation\n   */\n  recordRenderTime(startTime: number): void {\n    if (!this.options.enableRenderTimeMonitoring) return\n\n    const renderTime = performance.now() - startTime\n    this.addMetric('renderTime', renderTime)\n  }\n\n  /**\n   * Record load time for data fetching\n   */\n  recordLoadTime(startTime: number): void {\n    const loadTime = performance.now() - startTime\n    this.addMetric('loadTime', loadTime)\n  }\n\n  /**\n   * Record intersection observer timing\n   */\n  recordIntersectionTime(startTime: number): void {\n    const intersectionTime = performance.now() - startTime\n    this.addMetric('intersectionTime', intersectionTime)\n  }", "metadata": {}}
{"id": "559", "text": "const renderTime = performance.now() - startTime\n    this.addMetric('renderTime', renderTime)\n  }\n\n  /**\n   * Record load time for data fetching\n   */\n  recordLoadTime(startTime: number): void {\n    const loadTime = performance.now() - startTime\n    this.addMetric('loadTime', loadTime)\n  }\n\n  /**\n   * Record intersection observer timing\n   */\n  recordIntersectionTime(startTime: number): void {\n    const intersectionTime = performance.now() - startTime\n    this.addMetric('intersectionTime', intersectionTime)\n  }\n\n  /**\n   * Get current performance metrics\n   */\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics }\n  }\n\n  /**\n   * Reset all metrics\n   */\n  reset(): void {\n    this.metrics = {\n      scrollFPS: [],\n      renderTime: [],\n      memoryUsage: [],\n      loadTime: [],\n      intersectionTime: [],\n      timestamp: Date.now()\n    }\n  }", "metadata": {}}
{"id": "560", "text": "/**\n   * Get current performance metrics\n   */\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics }\n  }\n\n  /**\n   * Reset all metrics\n   */\n  reset(): void {\n    this.metrics = {\n      scrollFPS: [],\n      renderTime: [],\n      memoryUsage: [],\n      loadTime: [],\n      intersectionTime: [],\n      timestamp: Date.now()\n    }\n  }\n\n  /**\n   * Generate and report performance summary\n   */\n  private generateReport(): void {\n    const report = this.calculateSummary()\n    this.options.onReport(this.metrics)", "metadata": {}}
{"id": "561", "text": "/**\n   * Get current performance metrics\n   */\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics }\n  }\n\n  /**\n   * Reset all metrics\n   */\n  reset(): void {\n    this.metrics = {\n      scrollFPS: [],\n      renderTime: [],\n      memoryUsage: [],\n      loadTime: [],\n      intersectionTime: [],\n      timestamp: Date.now()\n    }\n  }\n\n  /**\n   * Generate and report performance summary\n   */\n  private generateReport(): void {\n    const report = this.calculateSummary()\n    this.options.onReport(this.metrics)\n\n    // Log to console if no custom reporter\n    if (this.options.onReport === (() => {})) {\n      console.group('🚀 Infinite Scroll Performance Report')\n      console.log('Average FPS:', report.avgFPS.toFixed(2))\n      console.log('Min FPS:', report.minFPS.toFixed(2))\n      console.log('Average Render Time:', report.avgRenderTime.toFixed(2), 'ms')\n      console.log('Average Load Time:', report.avgLoadTime.toFixed(2), 'ms')\n      console.log('Memory Usage:', report.memoryUsageMB.toFixed(2), 'MB')\n      console.groupEnd()\n    }\n  }", "metadata": {}}
{"id": "562", "text": "/**\n   * Calculate performance summary statistics\n   */\n  private calculateSummary() {\n    return {\n      avgFPS: this.average(this.metrics.scrollFPS),\n      minFPS: Math.min(...this.metrics.scrollFPS),\n      maxFPS: Math.max(...this.metrics.scrollFPS),\n      avgRenderTime: this.average(this.metrics.renderTime),\n      avgLoadTime: this.average(this.metrics.loadTime),\n      avgIntersectionTime: this.average(this.metrics.intersectionTime),\n      memoryUsageMB: this.getMemoryUsageMB()\n    }\n  }\n\n  /**\n   * Start FPS monitoring using requestAnimationFrame\n   */\n  private startFPSMonitoring(): void {\n    const measureFrame = () => {\n      if (!this.isMonitoring) return\n\n      const currentTime = performance.now()\n      const deltaTime = currentTime - this.lastFrameTime\n\n      if (deltaTime > 0) {\n        const fps = 1000 / deltaTime\n        this.addMetric('scrollFPS', fps)\n      }\n\n      this.lastFrameTime = currentTime\n      this.frameCount++", "metadata": {}}
{"id": "563", "text": "/**\n   * Start FPS monitoring using requestAnimationFrame\n   */\n  private startFPSMonitoring(): void {\n    const measureFrame = () => {\n      if (!this.isMonitoring) return\n\n      const currentTime = performance.now()\n      const deltaTime = currentTime - this.lastFrameTime\n\n      if (deltaTime > 0) {\n        const fps = 1000 / deltaTime\n        this.addMetric('scrollFPS', fps)\n      }\n\n      this.lastFrameTime = currentTime\n      this.frameCount++\n\n      // Record memory usage periodically\n      if (this.options.enableMemoryMonitoring && this.frameCount % 60 === 0) {\n        this.recordMemoryUsage()\n      }\n\n      this.animationFrameId = requestAnimationFrame(measureFrame)\n    }\n\n    this.animationFrameId = requestAnimationFrame(measureFrame)\n  }", "metadata": {}}
{"id": "564", "text": "if (deltaTime > 0) {\n        const fps = 1000 / deltaTime\n        this.addMetric('scrollFPS', fps)\n      }\n\n      this.lastFrameTime = currentTime\n      this.frameCount++\n\n      // Record memory usage periodically\n      if (this.options.enableMemoryMonitoring && this.frameCount % 60 === 0) {\n        this.recordMemoryUsage()\n      }\n\n      this.animationFrameId = requestAnimationFrame(measureFrame)\n    }\n\n    this.animationFrameId = requestAnimationFrame(measureFrame)\n  }\n\n  /**\n   * Record current memory usage if available\n   */\n  private recordMemoryUsage(): void {\n    // @ts-ignore - performance.memory is not in all TypeScript definitions\n    if ('memory' in performance && performance.memory) {\n      // @ts-ignore\n      const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024\n      this.addMetric('memoryUsage', memoryMB)\n    }\n  }", "metadata": {}}
{"id": "565", "text": "this.animationFrameId = requestAnimationFrame(measureFrame)\n    }\n\n    this.animationFrameId = requestAnimationFrame(measureFrame)\n  }\n\n  /**\n   * Record current memory usage if available\n   */\n  private recordMemoryUsage(): void {\n    // @ts-ignore - performance.memory is not in all TypeScript definitions\n    if ('memory' in performance && performance.memory) {\n      // @ts-ignore\n      const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024\n      this.addMetric('memoryUsage', memoryMB)\n    }\n  }\n\n  /**\n   * Get current memory usage in MB\n   */\n  private getMemoryUsageMB(): number {\n    // @ts-ignore - performance.memory is not in all TypeScript definitions\n    if ('memory' in performance && performance.memory) {\n      // @ts-ignore\n      return performance.memory.usedJSHeapSize / 1024 / 1024\n    }\n    return 0\n  }", "metadata": {}}
{"id": "566", "text": "/**\n   * Get current memory usage in MB\n   */\n  private getMemoryUsageMB(): number {\n    // @ts-ignore - performance.memory is not in all TypeScript definitions\n    if ('memory' in performance && performance.memory) {\n      // @ts-ignore\n      return performance.memory.usedJSHeapSize / 1024 / 1024\n    }\n    return 0\n  }\n\n  /**\n   * Add a metric value and maintain sample size limit\n   */\n  private addMetric(type: keyof Omit<PerformanceMetrics, 'timestamp'>, value: number): void {\n    const metrics = this.metrics[type]\n    metrics.push(value)\n\n    // Keep only the latest samples\n    if (metrics.length > this.options.sampleSize) {\n      metrics.shift()\n    }\n  }\n\n  /**\n   * Calculate average of an array of numbers\n   */\n  private average(values: number[]): number {\n    if (values.length === 0) return 0\n    return values.reduce((sum, value) => sum + value, 0) / values.length\n  }\n}", "metadata": {}}
{"id": "567", "text": "// Keep only the latest samples\n    if (metrics.length > this.options.sampleSize) {\n      metrics.shift()\n    }\n  }\n\n  /**\n   * Calculate average of an array of numbers\n   */\n  private average(values: number[]): number {\n    if (values.length === 0) return 0\n    return values.reduce((sum, value) => sum + value, 0) / values.length\n  }\n}\n\n// Create a singleton instance for global use\nexport const performanceMonitor = new PerformanceMonitor()\n\n// Hook for React components\nexport function usePerformanceMonitor(options: ScrollPerformanceOptions = {}) {\n  const monitor = new PerformanceMonitor(options)\n\n  return {\n    start: () => monitor.start(),\n    stop: () => monitor.stop(),\n    recordRenderTime: (startTime: number) => monitor.recordRenderTime(startTime),\n    recordLoadTime: (startTime: number) => monitor.recordLoadTime(startTime),\n    recordIntersectionTime: (startTime: number) => monitor.recordIntersectionTime(startTime),\n    getMetrics: () => monitor.getMetrics(),\n    reset: () => monitor.reset()\n  }\n}", "metadata": {}}
{"id": "568", "text": "// Hook for React components\nexport function usePerformanceMonitor(options: ScrollPerformanceOptions = {}) {\n  const monitor = new PerformanceMonitor(options)\n\n  return {\n    start: () => monitor.start(),\n    stop: () => monitor.stop(),\n    recordRenderTime: (startTime: number) => monitor.recordRenderTime(startTime),\n    recordLoadTime: (startTime: number) => monitor.recordLoadTime(startTime),\n    recordIntersectionTime: (startTime: number) => monitor.recordIntersectionTime(startTime),\n    getMetrics: () => monitor.getMetrics(),\n    reset: () => monitor.reset()\n  }\n}\n\n// Utility for measuring render time\nexport function measureRenderTime<T>(fn: () => T, monitor?: PerformanceMonitor): T {\n  const startTime = performance.now()\n  const result = fn()\n\n  if (monitor) {\n    monitor.recordRenderTime(startTime)\n  } else {\n    performanceMonitor.recordRenderTime(startTime)\n  }\n\n  return result\n}", "metadata": {}}
{"id": "569", "text": "// Utility for measuring render time\nexport function measureRenderTime<T>(fn: () => T, monitor?: PerformanceMonitor): T {\n  const startTime = performance.now()\n  const result = fn()\n\n  if (monitor) {\n    monitor.recordRenderTime(startTime)\n  } else {\n    performanceMonitor.recordRenderTime(startTime)\n  }\n\n  return result\n}\n\n// Utility for measuring async operations\nexport async function measureAsyncTime<T>(\n  fn: () => Promise<T>,\n  monitor?: PerformanceMonitor\n): Promise<T> {\n  const startTime = performance.now()\n  const result = await fn()\n\n  if (monitor) {\n    monitor.recordLoadTime(startTime)\n  } else {\n    performanceMonitor.recordLoadTime(startTime)\n  }\n\n  return result\n}", "metadata": {}}
{"id": "570", "text": "import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { axe, toHaveNoViolations } from 'jest-axe';\nimport { ImageDetailModal } from '../../src/components/ImageDetailModal/ImageDetailModal';\nimport { useImageDetail } from '../../src/hooks/useImageDetail';\nimport { createTestImage } from '../utils/test-utils';\n\n// Extend jest matchers\nexpect.extend(toHaveNoViolations);\n\n// Mock the hook\nvi.mock('../../src/hooks/useImageDetail');\n\nconst mockImage = createTestImage({\n  id: '1',\n  filename: 'test.jpg',\n  caption: 'Beautiful sunset at the beach',\n  uploadedBy: { id: 'user1', username: 'john_doe', displayName: 'John Doe' }\n});\n\ndescribe('Modal Accessibility Test', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });", "metadata": {}}
{"id": "571", "text": "// Extend jest matchers\nexpect.extend(toHaveNoViolations);\n\n// Mock the hook\nvi.mock('../../src/hooks/useImageDetail');\n\nconst mockImage = createTestImage({\n  id: '1',\n  filename: 'test.jpg',\n  caption: 'Beautiful sunset at the beach',\n  uploadedBy: { id: 'user1', username: 'john_doe', displayName: 'John Doe' }\n});\n\ndescribe('Modal Accessibility Test', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it('should have no axe violations', async () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    const { container } = render(<ImageDetailModal />);", "metadata": {}}
{"id": "572", "text": "describe('Modal Accessibility Test', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it('should have no axe violations', async () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    const { container } = render(<ImageDetailModal />);\n\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n\n  it('should have proper ARIA attributes', () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);", "metadata": {}}
{"id": "573", "text": "const { container } = render(<ImageDetailModal />);\n\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n\n  it('should have proper ARIA attributes', () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Check dialog role\n    const dialog = screen.getByRole('dialog');\n    expect(dialog).toBeInTheDocument();\n    expect(dialog).toHaveAttribute('aria-modal', 'true');\n    expect(dialog).toHaveAttribute('aria-labelledby');\n    expect(dialog).toHaveAttribute('aria-describedby');\n  });", "metadata": {}}
{"id": "574", "text": "render(<ImageDetailModal />);\n\n    // Check dialog role\n    const dialog = screen.getByRole('dialog');\n    expect(dialog).toBeInTheDocument();\n    expect(dialog).toHaveAttribute('aria-modal', 'true');\n    expect(dialog).toHaveAttribute('aria-labelledby');\n    expect(dialog).toHaveAttribute('aria-describedby');\n  });\n\n  it('should trap focus within modal when open', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Focus should be on modal when it opens\n    const dialog = screen.getByRole('dialog');\n    expect(document.activeElement).toBe(dialog);", "metadata": {}}
{"id": "575", "text": "it('should trap focus within modal when open', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Focus should be on modal when it opens\n    const dialog = screen.getByRole('dialog');\n    expect(document.activeElement).toBe(dialog);\n\n    // Tab through elements\n    await userEvent.tab();\n    // Should focus on close button or first interactive element\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    expect(document.activeElement).toBe(closeButton);\n\n    // Continue tabbing - should stay within modal\n    await userEvent.tab();\n    expect(dialog.contains(document.activeElement)).toBe(true);\n  });", "metadata": {}}
{"id": "576", "text": "render(<ImageDetailModal />);\n\n    // Focus should be on modal when it opens\n    const dialog = screen.getByRole('dialog');\n    expect(document.activeElement).toBe(dialog);\n\n    // Tab through elements\n    await userEvent.tab();\n    // Should focus on close button or first interactive element\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    expect(document.activeElement).toBe(closeButton);\n\n    // Continue tabbing - should stay within modal\n    await userEvent.tab();\n    expect(dialog.contains(document.activeElement)).toBe(true);\n  });\n\n  it('should be keyboard navigable', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);", "metadata": {}}
{"id": "577", "text": "// Continue tabbing - should stay within modal\n    await userEvent.tab();\n    expect(dialog.contains(document.activeElement)).toBe(true);\n  });\n\n  it('should be keyboard navigable', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Navigate with keyboard\n    await userEvent.tab();\n    await userEvent.tab();\n    await userEvent.tab();\n\n    // All interactive elements should be reachable by tab\n    const interactiveElements = screen.getAllByRole('button');\n    expect(interactiveElements.length).toBeGreaterThan(0);\n  });", "metadata": {}}
{"id": "578", "text": "render(<ImageDetailModal />);\n\n    // Navigate with keyboard\n    await userEvent.tab();\n    await userEvent.tab();\n    await userEvent.tab();\n\n    // All interactive elements should be reachable by tab\n    const interactiveElements = screen.getAllByRole('button');\n    expect(interactiveElements.length).toBeGreaterThan(0);\n  });\n\n  it('should support screen reader announcements', () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Check for aria-live regions or announcements\n    const liveRegion = document.querySelector('[aria-live]');\n    if (liveRegion) {\n      expect(liveRegion).toBeInTheDocument();\n    }\n  });", "metadata": {}}
{"id": "579", "text": "it('should support screen reader announcements', () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Check for aria-live regions or announcements\n    const liveRegion = document.querySelector('[aria-live]');\n    if (liveRegion) {\n      expect(liveRegion).toBeInTheDocument();\n    }\n  });\n\n  it('should have descriptive labels for all interactive elements', () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);", "metadata": {}}
{"id": "580", "text": "// Check for aria-live regions or announcements\n    const liveRegion = document.querySelector('[aria-live]');\n    if (liveRegion) {\n      expect(liveRegion).toBeInTheDocument();\n    }\n  });\n\n  it('should have descriptive labels for all interactive elements', () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Check image alt text\n    const image = screen.getByAltText(mockImage.caption || 'Image detail');\n    expect(image).toBeInTheDocument();\n\n    // Check button labels\n    const buttons = screen.getAllByRole('button');\n    buttons.forEach(button => {\n      expect(button).toHaveAttribute('aria-label');\n      expect(button).toHaveAccessibleName();\n    });\n  });", "metadata": {}}
{"id": "581", "text": "render(<ImageDetailModal />);\n\n    // Check image alt text\n    const image = screen.getByAltText(mockImage.caption || 'Image detail');\n    expect(image).toBeInTheDocument();\n\n    // Check button labels\n    const buttons = screen.getAllByRole('button');\n    buttons.forEach(button => {\n      expect(button).toHaveAttribute('aria-label');\n      expect(button).toHaveAccessibleName();\n    });\n  });\n\n  it('should maintain proper heading structure', () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);", "metadata": {}}
{"id": "582", "text": "it('should maintain proper heading structure', () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Check that headings are properly nested\n    const headings = screen.getAllByRole('heading');\n    if (headings.length > 0) {\n      // First heading should be h1 or h2\n      expect(['h1', 'h2']).toContain(headings[0].tagName.toLowerCase());\n    }\n  });", "metadata": {}}
{"id": "583", "text": "render(<ImageDetailModal />);\n\n    // Check that headings are properly nested\n    const headings = screen.getAllByRole('heading');\n    if (headings.length > 0) {\n      // First heading should be h1 or h2\n      expect(['h1', 'h2']).toContain(headings[0].tagName.toLowerCase());\n    }\n  });\n\n  it('should handle loading and error states accessibly', async () => {\n    // Test loading state\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: true,\n      loading: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    const { rerender } = render(<ImageDetailModal />);\n\n    // Loading message should be accessible\n    const loadingMessage = screen.getByText(/Loading image details.../);\n    expect(loadingMessage).toBeInTheDocument();", "metadata": {}}
{"id": "584", "text": "const { rerender } = render(<ImageDetailModal />);\n\n    // Loading message should be accessible\n    const loadingMessage = screen.getByText(/Loading image details.../);\n    expect(loadingMessage).toBeInTheDocument();\n\n    // Test error state\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: true,\n      error: 'Failed to load image',\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    rerender(<ImageDetailModal />);\n\n    // Error message should be accessible\n    const errorMessage = screen.getByText(/Failed to load image/);\n    expect(errorMessage).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "585", "text": "// Test error state\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: true,\n      error: 'Failed to load image',\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    rerender(<ImageDetailModal />);\n\n    // Error message should be accessible\n    const errorMessage = screen.getByText(/Failed to load image/);\n    expect(errorMessage).toBeInTheDocument();\n  });\n\n  it('should have proper color contrast', () => {\n    // This would typically be checked with a tool like pa11y\n    // For now, we verify that text elements don't have inline styles that could affect contrast\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);", "metadata": {}}
{"id": "586", "text": "it('should have proper color contrast', () => {\n    // This would typically be checked with a tool like pa11y\n    // For now, we verify that text elements don't have inline styles that could affect contrast\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Check that text elements don't have color styles that could reduce contrast\n    const textElements = screen.getAllByText(/.+/);\n    textElements.forEach(element => {\n      const style = window.getComputedStyle(element);\n      // Should not have very low contrast colors\n      expect(style.color).not.toBe('rgb(255, 255, 255)'); // White on white\n      expect(style.color).not.toBe('rgb(0, 0, 0)'); // Black on black\n    });\n  });", "metadata": {}}
{"id": "587", "text": "render(<ImageDetailModal />);\n\n    // Check that text elements don't have color styles that could reduce contrast\n    const textElements = screen.getAllByText(/.+/);\n    textElements.forEach(element => {\n      const style = window.getComputedStyle(element);\n      // Should not have very low contrast colors\n      expect(style.color).not.toBe('rgb(255, 255, 255)'); // White on white\n      expect(style.color).not.toBe('rgb(0, 0, 0)'); // Black on black\n    });\n  });\n\n  it('should be responsive and accessible on mobile', () => {\n    // Mock mobile viewport\n    Object.defineProperty(window, 'innerWidth', {\n      writable: true,\n      configurable: true,\n      value: 375,\n    });\n\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });", "metadata": {}}
{"id": "588", "text": "it('should be responsive and accessible on mobile', () => {\n    // Mock mobile viewport\n    Object.defineProperty(window, 'innerWidth', {\n      writable: true,\n      configurable: true,\n      value: 375,\n    });\n\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Modal should still be accessible on mobile\n    const dialog = screen.getByRole('dialog');\n    expect(dialog).toBeInTheDocument();\n\n    // Interactive elements should be large enough for touch\n    const buttons = screen.getAllByRole('button');\n    buttons.forEach(button => {\n      const rect = button.getBoundingClientRect();\n      // Touch targets should be at least 44x44 pixels\n      expect(rect.width).toBeGreaterThanOrEqual(44);\n      expect(rect.height).toBeGreaterThanOrEqual(44);\n    });\n  });\n});", "metadata": {}}
{"id": "589", "text": "/**\n * AlbumGrid Component Tests\n * Tests the main album grid container component following TDD approach\n */\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { screen, fireEvent, within } from '@testing-library/react'\nimport AlbumGrid from '../../src/components/AlbumGrid'\nimport { render, createMockAlbums, mockIntersectionObserver } from '../utils'\nimport { AlbumGridProps } from '../../src/types'\n\ndescribe('AlbumGrid', () => {\n  const mockOnAlbumClick = vi.fn()\n  const mockOnAlbumReorder = vi.fn()\n  const mockOnAlbumDelete = vi.fn()\n\n  const defaultProps: AlbumGridProps = {\n    albums: createMockAlbums(6),\n    onAlbumClick: mockOnAlbumClick,\n    onAlbumReorder: mockOnAlbumReorder,\n    onAlbumDelete: mockOnAlbumDelete,\n  }\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    mockIntersectionObserver()\n  })", "metadata": {}}
{"id": "590", "text": "describe('AlbumGrid', () => {\n  const mockOnAlbumClick = vi.fn()\n  const mockOnAlbumReorder = vi.fn()\n  const mockOnAlbumDelete = vi.fn()\n\n  const defaultProps: AlbumGridProps = {\n    albums: createMockAlbums(6),\n    onAlbumClick: mockOnAlbumClick,\n    onAlbumReorder: mockOnAlbumReorder,\n    onAlbumDelete: mockOnAlbumDelete,\n  }\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    mockIntersectionObserver()\n  })\n\n  describe('Rendering', () => {\n    it('renders all albums in a grid layout', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      expect(albums).toHaveLength(6)\n\n      // Check that first few album names are rendered\n      expect(screen.getByText('Album 1')).toBeInTheDocument()\n      expect(screen.getByText('Album 2')).toBeInTheDocument()\n      expect(screen.getByText('Album 3')).toBeInTheDocument()\n    })", "metadata": {}}
{"id": "591", "text": "beforeEach(() => {\n    vi.clearAllMocks()\n    mockIntersectionObserver()\n  })\n\n  describe('Rendering', () => {\n    it('renders all albums in a grid layout', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      expect(albums).toHaveLength(6)\n\n      // Check that first few album names are rendered\n      expect(screen.getByText('Album 1')).toBeInTheDocument()\n      expect(screen.getByText('Album 2')).toBeInTheDocument()\n      expect(screen.getByText('Album 3')).toBeInTheDocument()\n    })\n\n    it('renders with correct CSS Grid layout classes', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const gridContainer = screen.getByTestId('album-grid')\n      expect(gridContainer).toHaveClass(\n        'grid',\n        'grid-cols-1',\n        'md:grid-cols-2',\n        'lg:grid-cols-3',\n        'gap-6'\n      )\n    })", "metadata": {}}
{"id": "592", "text": "it('renders with correct CSS Grid layout classes', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const gridContainer = screen.getByTestId('album-grid')\n      expect(gridContainer).toHaveClass(\n        'grid',\n        'grid-cols-1',\n        'md:grid-cols-2',\n        'lg:grid-cols-3',\n        'gap-6'\n      )\n    })\n\n    it('renders empty state when no albums provided', () => {\n      render(<AlbumGrid {...defaultProps} albums={[]} />)\n\n      expect(screen.getByText('No albums found')).toBeInTheDocument()\n      expect(screen.getByText('Upload photos to create your first album')).toBeInTheDocument()\n    })\n\n    it('renders loading state when loading prop is true', () => {\n      render(<AlbumGrid {...defaultProps} loading={true} />)\n\n      expect(screen.getByTestId('album-grid-loading')).toBeInTheDocument()\n      expect(screen.getByText('Loading albums...')).toBeInTheDocument()", "metadata": {}}
{"id": "593", "text": "it('renders empty state when no albums provided', () => {\n      render(<AlbumGrid {...defaultProps} albums={[]} />)\n\n      expect(screen.getByText('No albums found')).toBeInTheDocument()\n      expect(screen.getByText('Upload photos to create your first album')).toBeInTheDocument()\n    })\n\n    it('renders loading state when loading prop is true', () => {\n      render(<AlbumGrid {...defaultProps} loading={true} />)\n\n      expect(screen.getByTestId('album-grid-loading')).toBeInTheDocument()\n      expect(screen.getByText('Loading albums...')).toBeInTheDocument()\n\n      // Should show skeleton placeholders\n      const skeletons = screen.getAllByTestId(/^album-skeleton-/)\n      expect(skeletons.length).toBeGreaterThan(0)\n    })\n\n    it('applies custom className when provided', () => {\n      render(<AlbumGrid {...defaultProps} className=\"custom-grid\" />)\n\n      const gridContainer = screen.getByTestId('album-grid')\n      expect(gridContainer).toHaveClass('custom-grid')\n    })", "metadata": {}}
{"id": "594", "text": "expect(screen.getByTestId('album-grid-loading')).toBeInTheDocument()\n      expect(screen.getByText('Loading albums...')).toBeInTheDocument()\n\n      // Should show skeleton placeholders\n      const skeletons = screen.getAllByTestId(/^album-skeleton-/)\n      expect(skeletons.length).toBeGreaterThan(0)\n    })\n\n    it('applies custom className when provided', () => {\n      render(<AlbumGrid {...defaultProps} className=\"custom-grid\" />)\n\n      const gridContainer = screen.getByTestId('album-grid')\n      expect(gridContainer).toHaveClass('custom-grid')\n    })\n\n    it('applies custom data-testid when provided', () => {\n      render(<AlbumGrid {...defaultProps} data-testid=\"custom-album-grid\" />)\n\n      expect(screen.getByTestId('custom-album-grid')).toBeInTheDocument()\n    })\n  })\n\n  describe('Album Interactions', () => {\n    it('calls onAlbumClick when album tile is clicked', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const firstAlbum = screen.getByTestId('album-tile-1')\n      fireEvent.click(firstAlbum)", "metadata": {}}
{"id": "595", "text": "it('applies custom data-testid when provided', () => {\n      render(<AlbumGrid {...defaultProps} data-testid=\"custom-album-grid\" />)\n\n      expect(screen.getByTestId('custom-album-grid')).toBeInTheDocument()\n    })\n  })\n\n  describe('Album Interactions', () => {\n    it('calls onAlbumClick when album tile is clicked', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const firstAlbum = screen.getByTestId('album-tile-1')\n      fireEvent.click(firstAlbum)\n\n      expect(mockOnAlbumClick).toHaveBeenCalledWith(1)\n      expect(mockOnAlbumClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('calls onAlbumDelete when album delete button is clicked', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const firstAlbum = screen.getByTestId('album-tile-1')\n      const deleteButton = within(firstAlbum).getByRole('button', { name: /delete album/i })\n      fireEvent.click(deleteButton)", "metadata": {}}
{"id": "596", "text": "const firstAlbum = screen.getByTestId('album-tile-1')\n      fireEvent.click(firstAlbum)\n\n      expect(mockOnAlbumClick).toHaveBeenCalledWith(1)\n      expect(mockOnAlbumClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('calls onAlbumDelete when album delete button is clicked', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const firstAlbum = screen.getByTestId('album-tile-1')\n      const deleteButton = within(firstAlbum).getByRole('button', { name: /delete album/i })\n      fireEvent.click(deleteButton)\n\n      expect(mockOnAlbumDelete).toHaveBeenCalledWith(1)\n      expect(mockOnAlbumDelete).toHaveBeenCalledTimes(1)\n    })\n\n    it('does not render delete buttons when onAlbumDelete not provided', () => {\n      const propsWithoutDelete = { ...defaultProps }\n      delete propsWithoutDelete.onAlbumDelete\n\n      render(<AlbumGrid {...propsWithoutDelete} />)\n\n      const deleteButtons = screen.queryAllByRole('button', { name: /delete album/i })\n      expect(deleteButtons).toHaveLength(0)\n    })\n  })", "metadata": {}}
{"id": "597", "text": "expect(mockOnAlbumDelete).toHaveBeenCalledWith(1)\n      expect(mockOnAlbumDelete).toHaveBeenCalledTimes(1)\n    })\n\n    it('does not render delete buttons when onAlbumDelete not provided', () => {\n      const propsWithoutDelete = { ...defaultProps }\n      delete propsWithoutDelete.onAlbumDelete\n\n      render(<AlbumGrid {...propsWithoutDelete} />)\n\n      const deleteButtons = screen.queryAllByRole('button', { name: /delete album/i })\n      expect(deleteButtons).toHaveLength(0)\n    })\n  })\n\n  describe('Drag and Drop', () => {\n    it('enables drag and drop functionality for album reordering', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n      const secondAlbum = albums[1]\n\n      expect(firstAlbum).toHaveAttribute('draggable', 'true')\n      expect(secondAlbum).toHaveAttribute('draggable', 'true')\n    })", "metadata": {}}
{"id": "598", "text": "describe('Drag and Drop', () => {\n    it('enables drag and drop functionality for album reordering', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n      const secondAlbum = albums[1]\n\n      expect(firstAlbum).toHaveAttribute('draggable', 'true')\n      expect(secondAlbum).toHaveAttribute('draggable', 'true')\n    })\n\n    it('calls onAlbumReorder when album is dragged to new position', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n      const thirdAlbum = albums[2]\n\n      // Simulate drag and drop from position 0 to position 2\n      fireEvent.dragStart(firstAlbum, {\n        dataTransfer: { setData: vi.fn(), getData: vi.fn(() => '1') }\n      })\n      fireEvent.dragOver(thirdAlbum)\n      fireEvent.drop(thirdAlbum)", "metadata": {}}
{"id": "599", "text": "it('calls onAlbumReorder when album is dragged to new position', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n      const thirdAlbum = albums[2]\n\n      // Simulate drag and drop from position 0 to position 2\n      fireEvent.dragStart(firstAlbum, {\n        dataTransfer: { setData: vi.fn(), getData: vi.fn(() => '1') }\n      })\n      fireEvent.dragOver(thirdAlbum)\n      fireEvent.drop(thirdAlbum)\n\n      expect(mockOnAlbumReorder).toHaveBeenCalledWith(1, 3)\n      expect(mockOnAlbumReorder).toHaveBeenCalledTimes(1)\n    })\n\n    it('provides visual feedback during drag operations', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n\n      fireEvent.dragStart(firstAlbum)\n      expect(firstAlbum).toHaveClass('opacity-50')", "metadata": {}}
{"id": "600", "text": "expect(mockOnAlbumReorder).toHaveBeenCalledWith(1, 3)\n      expect(mockOnAlbumReorder).toHaveBeenCalledTimes(1)\n    })\n\n    it('provides visual feedback during drag operations', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n\n      fireEvent.dragStart(firstAlbum)\n      expect(firstAlbum).toHaveClass('opacity-50')\n\n      fireEvent.dragEnd(firstAlbum)\n      expect(firstAlbum).not.toHaveClass('opacity-50')\n    })\n\n    it('shows drop zones when dragging over valid drop targets', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n      const targetAlbum = albums[1]\n\n      fireEvent.dragStart(firstAlbum)\n      fireEvent.dragEnter(targetAlbum)\n\n      expect(targetAlbum).toHaveClass('ring-2', 'ring-primary')", "metadata": {}}
{"id": "601", "text": "fireEvent.dragEnd(firstAlbum)\n      expect(firstAlbum).not.toHaveClass('opacity-50')\n    })\n\n    it('shows drop zones when dragging over valid drop targets', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n      const targetAlbum = albums[1]\n\n      fireEvent.dragStart(firstAlbum)\n      fireEvent.dragEnter(targetAlbum)\n\n      expect(targetAlbum).toHaveClass('ring-2', 'ring-primary')\n\n      fireEvent.dragLeave(targetAlbum)\n      expect(targetAlbum).not.toHaveClass('ring-2', 'ring-primary')\n    })\n  })\n\n  describe('Infinite Scroll', () => {\n    it('renders infinite scroll trigger element', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const scrollTrigger = screen.getByTestId('infinite-scroll-trigger')\n      expect(scrollTrigger).toBeInTheDocument()\n    })", "metadata": {}}
{"id": "602", "text": "fireEvent.dragStart(firstAlbum)\n      fireEvent.dragEnter(targetAlbum)\n\n      expect(targetAlbum).toHaveClass('ring-2', 'ring-primary')\n\n      fireEvent.dragLeave(targetAlbum)\n      expect(targetAlbum).not.toHaveClass('ring-2', 'ring-primary')\n    })\n  })\n\n  describe('Infinite Scroll', () => {\n    it('renders infinite scroll trigger element', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const scrollTrigger = screen.getByTestId('infinite-scroll-trigger')\n      expect(scrollTrigger).toBeInTheDocument()\n    })\n\n    it('calls onLoadMore when scroll trigger becomes visible', () => {\n      const mockOnLoadMore = vi.fn()\n      render(<AlbumGrid {...defaultProps} onLoadMore={mockOnLoadMore} hasNextPage={true} />)\n\n      const scrollTrigger = screen.getByTestId('infinite-scroll-trigger')", "metadata": {}}
{"id": "603", "text": "describe('Infinite Scroll', () => {\n    it('renders infinite scroll trigger element', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const scrollTrigger = screen.getByTestId('infinite-scroll-trigger')\n      expect(scrollTrigger).toBeInTheDocument()\n    })\n\n    it('calls onLoadMore when scroll trigger becomes visible', () => {\n      const mockOnLoadMore = vi.fn()\n      render(<AlbumGrid {...defaultProps} onLoadMore={mockOnLoadMore} hasNextPage={true} />)\n\n      const scrollTrigger = screen.getByTestId('infinite-scroll-trigger')\n\n      // Simulate intersection observer callback\n      const observerCallback = vi.mocked(IntersectionObserver).mock.calls[0][0]\n      observerCallback([{ isIntersecting: true, target: scrollTrigger }] as any, {} as any)\n\n      expect(mockOnLoadMore).toHaveBeenCalledTimes(1)\n    })", "metadata": {}}
{"id": "604", "text": "const scrollTrigger = screen.getByTestId('infinite-scroll-trigger')\n\n      // Simulate intersection observer callback\n      const observerCallback = vi.mocked(IntersectionObserver).mock.calls[0][0]\n      observerCallback([{ isIntersecting: true, target: scrollTrigger }] as any, {} as any)\n\n      expect(mockOnLoadMore).toHaveBeenCalledTimes(1)\n    })\n\n    it('does not trigger loading when hasNextPage is false', () => {\n      const mockOnLoadMore = vi.fn()\n      render(<AlbumGrid {...defaultProps} onLoadMore={mockOnLoadMore} hasNextPage={false} />)\n\n      const scrollTrigger = screen.getByTestId('infinite-scroll-trigger')\n\n      // Simulate intersection observer callback\n      const observerCallback = vi.mocked(IntersectionObserver).mock.calls[0][0]\n      observerCallback([{ isIntersecting: true, target: scrollTrigger }] as any, {} as any)\n\n      expect(mockOnLoadMore).not.toHaveBeenCalled()\n    })", "metadata": {}}
{"id": "605", "text": "const scrollTrigger = screen.getByTestId('infinite-scroll-trigger')\n\n      // Simulate intersection observer callback\n      const observerCallback = vi.mocked(IntersectionObserver).mock.calls[0][0]\n      observerCallback([{ isIntersecting: true, target: scrollTrigger }] as any, {} as any)\n\n      expect(mockOnLoadMore).not.toHaveBeenCalled()\n    })\n\n    it('shows loading spinner during infinite loading', () => {\n      render(<AlbumGrid {...defaultProps} loading={true} hasNextPage={true} />)\n\n      const loadingSpinner = screen.getByTestId('infinite-loading-spinner')\n      expect(loadingSpinner).toBeInTheDocument()\n      expect(loadingSpinner).toHaveClass('animate-spin')\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('has proper ARIA labels for grid navigation', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const gridContainer = screen.getByTestId('album-grid')\n      expect(gridContainer).toHaveAttribute('role', 'grid')\n      expect(gridContainer).toHaveAttribute('aria-label', 'Photo albums grid')\n    })", "metadata": {}}
{"id": "606", "text": "const loadingSpinner = screen.getByTestId('infinite-loading-spinner')\n      expect(loadingSpinner).toBeInTheDocument()\n      expect(loadingSpinner).toHaveClass('animate-spin')\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('has proper ARIA labels for grid navigation', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const gridContainer = screen.getByTestId('album-grid')\n      expect(gridContainer).toHaveAttribute('role', 'grid')\n      expect(gridContainer).toHaveAttribute('aria-label', 'Photo albums grid')\n    })\n\n    it('supports keyboard navigation between albums', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n\n      firstAlbum.focus()\n      expect(firstAlbum).toHaveFocus()\n\n      // Arrow key navigation\n      fireEvent.keyDown(firstAlbum, { key: 'ArrowRight' })\n      expect(albums[1]).toHaveFocus()", "metadata": {}}
{"id": "607", "text": "it('supports keyboard navigation between albums', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n\n      firstAlbum.focus()\n      expect(firstAlbum).toHaveFocus()\n\n      // Arrow key navigation\n      fireEvent.keyDown(firstAlbum, { key: 'ArrowRight' })\n      expect(albums[1]).toHaveFocus()\n\n      fireEvent.keyDown(albums[1], { key: 'ArrowLeft' })\n      expect(firstAlbum).toHaveFocus()\n    })\n\n    it('announces drag and drop operations to screen readers', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const liveRegion = screen.getByTestId('drag-drop-announcements')\n      expect(liveRegion).toHaveAttribute('aria-live', 'polite')\n      expect(liveRegion).toHaveAttribute('aria-atomic', 'true')\n    })\n\n    it('provides proper focus management during drag operations', () => {\n      render(<AlbumGrid {...defaultProps} />)", "metadata": {}}
{"id": "608", "text": "it('announces drag and drop operations to screen readers', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const liveRegion = screen.getByTestId('drag-drop-announcements')\n      expect(liveRegion).toHaveAttribute('aria-live', 'polite')\n      expect(liveRegion).toHaveAttribute('aria-atomic', 'true')\n    })\n\n    it('provides proper focus management during drag operations', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n\n      firstAlbum.focus()\n      fireEvent.keyDown(firstAlbum, { key: 'Space' }) // Start drag with keyboard\n\n      expect(screen.getByText(/drag mode activated/i)).toBeInTheDocument()\n    })\n  })\n\n  describe('Performance', () => {\n    it('renders efficiently with large album lists', () => {\n      const largeAlbumList = createMockAlbums(100)\n      render(<AlbumGrid {...defaultProps} albums={largeAlbumList} />)", "metadata": {}}
{"id": "609", "text": "const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n\n      firstAlbum.focus()\n      fireEvent.keyDown(firstAlbum, { key: 'Space' }) // Start drag with keyboard\n\n      expect(screen.getByText(/drag mode activated/i)).toBeInTheDocument()\n    })\n  })\n\n  describe('Performance', () => {\n    it('renders efficiently with large album lists', () => {\n      const largeAlbumList = createMockAlbums(100)\n      render(<AlbumGrid {...defaultProps} albums={largeAlbumList} />)\n\n      // Should only render visible albums (virtualization)\n      const renderedAlbums = screen.getAllByTestId(/^album-tile-/)\n      expect(renderedAlbums.length).toBeLessThanOrEqual(20) // Max visible at once\n    })\n\n    it('uses memo to prevent unnecessary rerenders', () => {\n      const { rerender } = render(<AlbumGrid {...defaultProps} />)\n\n      // Same props should not cause rerender\n      rerender(<AlbumGrid {...defaultProps} />)", "metadata": {}}
{"id": "610", "text": "// Should only render visible albums (virtualization)\n      const renderedAlbums = screen.getAllByTestId(/^album-tile-/)\n      expect(renderedAlbums.length).toBeLessThanOrEqual(20) // Max visible at once\n    })\n\n    it('uses memo to prevent unnecessary rerenders', () => {\n      const { rerender } = render(<AlbumGrid {...defaultProps} />)\n\n      // Same props should not cause rerender\n      rerender(<AlbumGrid {...defaultProps} />)\n\n      // Component should be memoized (this is more of an implementation detail)\n      expect(screen.getAllByTestId(/^album-tile-/)).toHaveLength(6)\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('handles missing thumbnail gracefully', () => {\n      const albumsWithMissingThumbnails = defaultProps.albums.map(album => ({\n        ...album,\n        thumbnailPhotoId: null,\n      }))\n\n      render(<AlbumGrid {...defaultProps} albums={albumsWithMissingThumbnails} />)", "metadata": {}}
{"id": "611", "text": "// Component should be memoized (this is more of an implementation detail)\n      expect(screen.getAllByTestId(/^album-tile-/)).toHaveLength(6)\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('handles missing thumbnail gracefully', () => {\n      const albumsWithMissingThumbnails = defaultProps.albums.map(album => ({\n        ...album,\n        thumbnailPhotoId: null,\n      }))\n\n      render(<AlbumGrid {...defaultProps} albums={albumsWithMissingThumbnails} />)\n\n      // Should render placeholder thumbnails\n      const placeholders = screen.getAllByTestId(/^album-placeholder-thumbnail-/)\n      expect(placeholders).toHaveLength(6)\n    })\n\n    it('displays error state when albums fail to load', () => {\n      render(<AlbumGrid {...defaultProps} error=\"Failed to load albums\" />)\n\n      expect(screen.getByText('Failed to load albums')).toBeInTheDocument()\n      expect(screen.getByRole('button', { name: /retry/i })).toBeInTheDocument()\n    })\n\n    it('handles drag and drop errors gracefully', () => {\n      render(<AlbumGrid {...defaultProps} />)", "metadata": {}}
{"id": "612", "text": "// Should render placeholder thumbnails\n      const placeholders = screen.getAllByTestId(/^album-placeholder-thumbnail-/)\n      expect(placeholders).toHaveLength(6)\n    })\n\n    it('displays error state when albums fail to load', () => {\n      render(<AlbumGrid {...defaultProps} error=\"Failed to load albums\" />)\n\n      expect(screen.getByText('Failed to load albums')).toBeInTheDocument()\n      expect(screen.getByRole('button', { name: /retry/i })).toBeInTheDocument()\n    })\n\n    it('handles drag and drop errors gracefully', () => {\n      render(<AlbumGrid {...defaultProps} />)\n\n      const albums = screen.getAllByTestId(/^album-tile-/)\n      const firstAlbum = albums[0]\n\n      // Simulate failed drag operation\n      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})\n\n      fireEvent.dragStart(firstAlbum)\n      fireEvent.drop(firstAlbum) // Drop on self (invalid)\n\n      expect(consoleSpy).not.toHaveBeenCalled()\n      consoleSpy.mockRestore()\n    })\n  })\n})", "metadata": {}}
{"id": "613", "text": "/**\n * AlbumTile Component Tests\n * Tests individual album tile component following TDD approach\n */\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { screen, fireEvent, within } from '@testing-library/react'\nimport AlbumTile from '../../src/components/AlbumTile'\nimport { render, createMockAlbum, setupURLMocks } from '../utils'\nimport { AlbumTileProps } from '../../src/types'\n\ndescribe('AlbumTile', () => {\n  const mockOnClick = vi.fn()\n  const mockOnDelete = vi.fn()\n\n  const defaultProps: AlbumTileProps = {\n    album: createMockAlbum({ id: 1, name: 'Test Album', photoCount: 25 }),\n    thumbnailSrc: 'https://picsum.photos/300/200?random=1',\n    onClick: mockOnClick,\n    onDelete: mockOnDelete,\n  }\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    setupURLMocks()\n  })\n\n  describe('Rendering', () => {\n    it('renders album information correctly', () => {\n      render(<AlbumTile {...defaultProps} />)", "metadata": {}}
{"id": "614", "text": "const defaultProps: AlbumTileProps = {\n    album: createMockAlbum({ id: 1, name: 'Test Album', photoCount: 25 }),\n    thumbnailSrc: 'https://picsum.photos/300/200?random=1',\n    onClick: mockOnClick,\n    onDelete: mockOnDelete,\n  }\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    setupURLMocks()\n  })\n\n  describe('Rendering', () => {\n    it('renders album information correctly', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      expect(screen.getByText('Test Album')).toBeInTheDocument()\n      expect(screen.getByText('25 photos')).toBeInTheDocument()\n      expect(screen.getByText(/2024-09-15/)).toBeInTheDocument() // Capture date\n    })\n\n    it('renders thumbnail image with correct attributes', () => {\n      render(<AlbumTile {...defaultProps} />)", "metadata": {}}
{"id": "615", "text": "beforeEach(() => {\n    vi.clearAllMocks()\n    setupURLMocks()\n  })\n\n  describe('Rendering', () => {\n    it('renders album information correctly', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      expect(screen.getByText('Test Album')).toBeInTheDocument()\n      expect(screen.getByText('25 photos')).toBeInTheDocument()\n      expect(screen.getByText(/2024-09-15/)).toBeInTheDocument() // Capture date\n    })\n\n    it('renders thumbnail image with correct attributes', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      expect(thumbnail).toHaveAttribute('src', defaultProps.thumbnailSrc)\n      expect(thumbnail).toHaveAttribute('alt', 'Test Album thumbnail')\n    })\n\n    it('renders placeholder when no thumbnailSrc provided', () => {\n      const propsWithoutThumbnail = { ...defaultProps, thumbnailSrc: undefined }\n      render(<AlbumTile {...propsWithoutThumbnail} />)", "metadata": {}}
{"id": "616", "text": "it('renders thumbnail image with correct attributes', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      expect(thumbnail).toHaveAttribute('src', defaultProps.thumbnailSrc)\n      expect(thumbnail).toHaveAttribute('alt', 'Test Album thumbnail')\n    })\n\n    it('renders placeholder when no thumbnailSrc provided', () => {\n      const propsWithoutThumbnail = { ...defaultProps, thumbnailSrc: undefined }\n      render(<AlbumTile {...propsWithoutThumbnail} />)\n\n      const placeholder = screen.getByTestId('album-thumbnail-placeholder')\n      expect(placeholder).toBeInTheDocument()\n      expect(placeholder).toHaveClass('bg-muted', 'flex', 'items-center', 'justify-center')\n    })\n\n    it('applies custom className when provided', () => {\n      render(<AlbumTile {...defaultProps} className=\"custom-tile\" />)\n\n      const tileContainer = screen.getByTestId('album-tile-1')\n      expect(tileContainer).toHaveClass('custom-tile')\n    })", "metadata": {}}
{"id": "617", "text": "const placeholder = screen.getByTestId('album-thumbnail-placeholder')\n      expect(placeholder).toBeInTheDocument()\n      expect(placeholder).toHaveClass('bg-muted', 'flex', 'items-center', 'justify-center')\n    })\n\n    it('applies custom className when provided', () => {\n      render(<AlbumTile {...defaultProps} className=\"custom-tile\" />)\n\n      const tileContainer = screen.getByTestId('album-tile-1')\n      expect(tileContainer).toHaveClass('custom-tile')\n    })\n\n    it('applies custom data-testid when provided', () => {\n      render(<AlbumTile {...defaultProps} data-testid=\"custom-album-tile\" />)\n\n      expect(screen.getByTestId('custom-album-tile')).toBeInTheDocument()\n    })\n\n    it('displays formatted capture date', () => {\n      const albumWithDate = createMockAlbum({\n        captureDate: new Date('2024-07-15T10:30:00Z')\n      })\n\n      render(<AlbumTile {...defaultProps} album={albumWithDate} />)", "metadata": {}}
{"id": "618", "text": "it('applies custom data-testid when provided', () => {\n      render(<AlbumTile {...defaultProps} data-testid=\"custom-album-tile\" />)\n\n      expect(screen.getByTestId('custom-album-tile')).toBeInTheDocument()\n    })\n\n    it('displays formatted capture date', () => {\n      const albumWithDate = createMockAlbum({\n        captureDate: new Date('2024-07-15T10:30:00Z')\n      })\n\n      render(<AlbumTile {...defaultProps} album={albumWithDate} />)\n\n      expect(screen.getByText(/July 15, 2024/)).toBeInTheDocument()\n    })\n\n    it('handles single photo count correctly', () => {\n      const albumWithOnePhoto = createMockAlbum({ photoCount: 1 })\n\n      render(<AlbumTile {...defaultProps} album={albumWithOnePhoto} />)\n\n      expect(screen.getByText('1 photo')).toBeInTheDocument()\n    })\n\n    it('handles zero photo count correctly', () => {\n      const emptyAlbum = createMockAlbum({ photoCount: 0 })", "metadata": {}}
{"id": "619", "text": "expect(screen.getByText(/July 15, 2024/)).toBeInTheDocument()\n    })\n\n    it('handles single photo count correctly', () => {\n      const albumWithOnePhoto = createMockAlbum({ photoCount: 1 })\n\n      render(<AlbumTile {...defaultProps} album={albumWithOnePhoto} />)\n\n      expect(screen.getByText('1 photo')).toBeInTheDocument()\n    })\n\n    it('handles zero photo count correctly', () => {\n      const emptyAlbum = createMockAlbum({ photoCount: 0 })\n\n      render(<AlbumTile {...defaultProps} album={emptyAlbum} />)\n\n      expect(screen.getByText('0 photos')).toBeInTheDocument()\n    })\n  })\n\n  describe('Interactions', () => {\n    it('calls onClick when tile is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.click(tile)\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('calls onClick when thumbnail is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)", "metadata": {}}
{"id": "620", "text": "render(<AlbumTile {...defaultProps} album={emptyAlbum} />)\n\n      expect(screen.getByText('0 photos')).toBeInTheDocument()\n    })\n  })\n\n  describe('Interactions', () => {\n    it('calls onClick when tile is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.click(tile)\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('calls onClick when thumbnail is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      fireEvent.click(thumbnail)\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('calls onClick when title is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const title = screen.getByText('Test Album')\n      fireEvent.click(title)\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })", "metadata": {}}
{"id": "621", "text": "it('calls onClick when thumbnail is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      fireEvent.click(thumbnail)\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('calls onClick when title is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const title = screen.getByText('Test Album')\n      fireEvent.click(title)\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('calls onDelete when delete button is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const deleteButton = screen.getByRole('button', { name: /delete album/i })\n      fireEvent.click(deleteButton)\n\n      expect(mockOnDelete).toHaveBeenCalledTimes(1)\n      expect(mockOnClick).not.toHaveBeenCalled() // Should not trigger tile click\n    })\n\n    it('does not render delete button when onDelete not provided', () => {\n      const propsWithoutDelete = { ...defaultProps }\n      delete propsWithoutDelete.onDelete", "metadata": {}}
{"id": "622", "text": "it('calls onDelete when delete button is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const deleteButton = screen.getByRole('button', { name: /delete album/i })\n      fireEvent.click(deleteButton)\n\n      expect(mockOnDelete).toHaveBeenCalledTimes(1)\n      expect(mockOnClick).not.toHaveBeenCalled() // Should not trigger tile click\n    })\n\n    it('does not render delete button when onDelete not provided', () => {\n      const propsWithoutDelete = { ...defaultProps }\n      delete propsWithoutDelete.onDelete\n\n      render(<AlbumTile {...propsWithoutDelete} />)\n\n      const deleteButton = screen.queryByRole('button', { name: /delete album/i })\n      expect(deleteButton).not.toBeInTheDocument()\n    })\n\n    it('prevents event propagation when delete button is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const deleteButton = screen.getByRole('button', { name: /delete album/i })\n      fireEvent.click(deleteButton)", "metadata": {}}
{"id": "623", "text": "render(<AlbumTile {...propsWithoutDelete} />)\n\n      const deleteButton = screen.queryByRole('button', { name: /delete album/i })\n      expect(deleteButton).not.toBeInTheDocument()\n    })\n\n    it('prevents event propagation when delete button is clicked', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const deleteButton = screen.getByRole('button', { name: /delete album/i })\n      fireEvent.click(deleteButton)\n\n      // onClick should not be called when delete is clicked\n      expect(mockOnClick).not.toHaveBeenCalled()\n      expect(mockOnDelete).toHaveBeenCalledTimes(1)\n    })\n  })\n\n  describe('Drag and Drop', () => {\n    const dragHandleProps = {\n      'data-testid': 'drag-handle',\n      onMouseDown: vi.fn(),\n      onTouchStart: vi.fn(),\n    }\n\n    it('renders drag handle when dragHandleProps provided', () => {\n      render(<AlbumTile {...defaultProps} dragHandleProps={dragHandleProps} />)", "metadata": {}}
{"id": "624", "text": "// onClick should not be called when delete is clicked\n      expect(mockOnClick).not.toHaveBeenCalled()\n      expect(mockOnDelete).toHaveBeenCalledTimes(1)\n    })\n  })\n\n  describe('Drag and Drop', () => {\n    const dragHandleProps = {\n      'data-testid': 'drag-handle',\n      onMouseDown: vi.fn(),\n      onTouchStart: vi.fn(),\n    }\n\n    it('renders drag handle when dragHandleProps provided', () => {\n      render(<AlbumTile {...defaultProps} dragHandleProps={dragHandleProps} />)\n\n      const dragHandle = screen.getByTestId('drag-handle')\n      expect(dragHandle).toBeInTheDocument()\n      expect(dragHandle).toHaveClass('cursor-grab')\n    })\n\n    it('applies dragging styles when isDragging is true', () => {\n      render(<AlbumTile {...defaultProps} isDragging={true} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveClass('opacity-50', 'transform', 'rotate-2')\n    })", "metadata": {}}
{"id": "625", "text": "const dragHandle = screen.getByTestId('drag-handle')\n      expect(dragHandle).toBeInTheDocument()\n      expect(dragHandle).toHaveClass('cursor-grab')\n    })\n\n    it('applies dragging styles when isDragging is true', () => {\n      render(<AlbumTile {...defaultProps} isDragging={true} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveClass('opacity-50', 'transform', 'rotate-2')\n    })\n\n    it('does not apply dragging styles when isDragging is false', () => {\n      render(<AlbumTile {...defaultProps} isDragging={false} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).not.toHaveClass('opacity-50', 'transform', 'rotate-2')\n    })\n\n    it('shows drag cursor when hovering over drag handle', () => {\n      render(<AlbumTile {...defaultProps} dragHandleProps={dragHandleProps} />)", "metadata": {}}
{"id": "626", "text": "it('does not apply dragging styles when isDragging is false', () => {\n      render(<AlbumTile {...defaultProps} isDragging={false} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).not.toHaveClass('opacity-50', 'transform', 'rotate-2')\n    })\n\n    it('shows drag cursor when hovering over drag handle', () => {\n      render(<AlbumTile {...defaultProps} dragHandleProps={dragHandleProps} />)\n\n      const dragHandle = screen.getByTestId('drag-handle')\n      expect(dragHandle).toHaveClass('cursor-grab')\n\n      fireEvent.mouseDown(dragHandle)\n      expect(dragHandle).toHaveClass('cursor-grabbing')\n    })\n\n    it('makes tile draggable when drag handle is present', () => {\n      render(<AlbumTile {...defaultProps} dragHandleProps={dragHandleProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveAttribute('draggable', 'true')\n    })", "metadata": {}}
{"id": "627", "text": "const dragHandle = screen.getByTestId('drag-handle')\n      expect(dragHandle).toHaveClass('cursor-grab')\n\n      fireEvent.mouseDown(dragHandle)\n      expect(dragHandle).toHaveClass('cursor-grabbing')\n    })\n\n    it('makes tile draggable when drag handle is present', () => {\n      render(<AlbumTile {...defaultProps} dragHandleProps={dragHandleProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveAttribute('draggable', 'true')\n    })\n\n    it('is not draggable when no drag handle provided', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).not.toHaveAttribute('draggable')\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('has proper ARIA labels for tile interaction', () => {\n      render(<AlbumTile {...defaultProps} />)", "metadata": {}}
{"id": "628", "text": "const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveAttribute('draggable', 'true')\n    })\n\n    it('is not draggable when no drag handle provided', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).not.toHaveAttribute('draggable')\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('has proper ARIA labels for tile interaction', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveAttribute('role', 'button')\n      expect(tile).toHaveAttribute('aria-label', 'Open Test Album with 25 photos')\n    })\n\n    it('has proper keyboard navigation support', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveAttribute('tabIndex', '0')", "metadata": {}}
{"id": "629", "text": "const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveAttribute('role', 'button')\n      expect(tile).toHaveAttribute('aria-label', 'Open Test Album with 25 photos')\n    })\n\n    it('has proper keyboard navigation support', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveAttribute('tabIndex', '0')\n\n      tile.focus()\n      expect(tile).toHaveFocus()\n    })\n\n    it('responds to Enter key press', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.keyDown(tile, { key: 'Enter' })\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('responds to Space key press', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.keyDown(tile, { key: ' ' })", "metadata": {}}
{"id": "630", "text": "it('responds to Enter key press', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.keyDown(tile, { key: 'Enter' })\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('responds to Space key press', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.keyDown(tile, { key: ' ' })\n\n      expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('has proper ARIA label for delete button', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const deleteButton = screen.getByRole('button', { name: /delete album/i })\n      expect(deleteButton).toHaveAttribute('aria-label', 'Delete Test Album')\n    })\n\n    it('provides proper focus management for delete button', () => {\n      render(<AlbumTile {...defaultProps} />)", "metadata": {}}
{"id": "631", "text": "expect(mockOnClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('has proper ARIA label for delete button', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const deleteButton = screen.getByRole('button', { name: /delete album/i })\n      expect(deleteButton).toHaveAttribute('aria-label', 'Delete Test Album')\n    })\n\n    it('provides proper focus management for delete button', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const deleteButton = screen.getByRole('button', { name: /delete album/i })\n\n      deleteButton.focus()\n      expect(deleteButton).toHaveFocus()\n\n      fireEvent.keyDown(deleteButton, { key: 'Enter' })\n      expect(mockOnDelete).toHaveBeenCalledTimes(1)\n    })\n\n    it('announces thumbnail loading state to screen readers', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      expect(thumbnail).toHaveAttribute('loading', 'lazy')\n    })\n  })", "metadata": {}}
{"id": "632", "text": "const deleteButton = screen.getByRole('button', { name: /delete album/i })\n\n      deleteButton.focus()\n      expect(deleteButton).toHaveFocus()\n\n      fireEvent.keyDown(deleteButton, { key: 'Enter' })\n      expect(mockOnDelete).toHaveBeenCalledTimes(1)\n    })\n\n    it('announces thumbnail loading state to screen readers', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      expect(thumbnail).toHaveAttribute('loading', 'lazy')\n    })\n  })\n\n  describe('Visual States', () => {\n    it('applies hover styles on mouse enter', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.mouseEnter(tile)\n\n      expect(tile).toHaveClass('hover:shadow-lg', 'hover:scale-105')\n    })\n\n    it('removes hover styles on mouse leave', () => {\n      render(<AlbumTile {...defaultProps} />)", "metadata": {}}
{"id": "633", "text": "describe('Visual States', () => {\n    it('applies hover styles on mouse enter', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.mouseEnter(tile)\n\n      expect(tile).toHaveClass('hover:shadow-lg', 'hover:scale-105')\n    })\n\n    it('removes hover styles on mouse leave', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      fireEvent.mouseEnter(tile)\n      fireEvent.mouseLeave(tile)\n\n      // Hover classes are managed by CSS, but component should not have focus-like state\n      expect(tile).not.toHaveClass('ring-2')\n    })\n\n    it('shows focus outline when focused', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      tile.focus()", "metadata": {}}
{"id": "634", "text": "const tile = screen.getByTestId('album-tile-1')\n      fireEvent.mouseEnter(tile)\n      fireEvent.mouseLeave(tile)\n\n      // Hover classes are managed by CSS, but component should not have focus-like state\n      expect(tile).not.toHaveClass('ring-2')\n    })\n\n    it('shows focus outline when focused', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      tile.focus()\n\n      expect(tile).toHaveClass('focus:outline-none', 'focus:ring-2', 'focus:ring-primary')\n    })\n\n    it('applies proper card styling from shadcn/ui', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveClass(\n        'rounded-lg',\n        'border',\n        'bg-card',\n        'text-card-foreground',\n        'shadow-sm'\n      )\n    })\n  })", "metadata": {}}
{"id": "635", "text": "expect(tile).toHaveClass('focus:outline-none', 'focus:ring-2', 'focus:ring-primary')\n    })\n\n    it('applies proper card styling from shadcn/ui', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const tile = screen.getByTestId('album-tile-1')\n      expect(tile).toHaveClass(\n        'rounded-lg',\n        'border',\n        'bg-card',\n        'text-card-foreground',\n        'shadow-sm'\n      )\n    })\n  })\n\n  describe('Image Loading', () => {\n    it('shows loading placeholder while thumbnail loads', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n\n      // Simulate loading state\n      fireEvent.load(thumbnail)\n      expect(thumbnail).toHaveAttribute('src', defaultProps.thumbnailSrc)\n    })\n\n    it('shows error placeholder when thumbnail fails to load', () => {\n      render(<AlbumTile {...defaultProps} />)", "metadata": {}}
{"id": "636", "text": "describe('Image Loading', () => {\n    it('shows loading placeholder while thumbnail loads', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n\n      // Simulate loading state\n      fireEvent.load(thumbnail)\n      expect(thumbnail).toHaveAttribute('src', defaultProps.thumbnailSrc)\n    })\n\n    it('shows error placeholder when thumbnail fails to load', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      fireEvent.error(thumbnail)\n\n      // Should show error placeholder\n      expect(screen.getByTestId('album-thumbnail-error')).toBeInTheDocument()\n    })\n\n    it('uses lazy loading for thumbnail images', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      expect(thumbnail).toHaveAttribute('loading', 'lazy')\n    })\n  })", "metadata": {}}
{"id": "637", "text": "const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      fireEvent.error(thumbnail)\n\n      // Should show error placeholder\n      expect(screen.getByTestId('album-thumbnail-error')).toBeInTheDocument()\n    })\n\n    it('uses lazy loading for thumbnail images', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      expect(thumbnail).toHaveAttribute('loading', 'lazy')\n    })\n  })\n\n  describe('Content Overflow', () => {\n    it('truncates long album names', () => {\n      const albumWithLongName = createMockAlbum({\n        name: 'This is a very long album name that should be truncated to prevent layout issues'\n      })\n\n      render(<AlbumTile {...defaultProps} album={albumWithLongName} />)\n\n      const titleElement = screen.getByText(/This is a very long album name/)\n      expect(titleElement).toHaveClass('truncate')\n    })", "metadata": {}}
{"id": "638", "text": "describe('Content Overflow', () => {\n    it('truncates long album names', () => {\n      const albumWithLongName = createMockAlbum({\n        name: 'This is a very long album name that should be truncated to prevent layout issues'\n      })\n\n      render(<AlbumTile {...defaultProps} album={albumWithLongName} />)\n\n      const titleElement = screen.getByText(/This is a very long album name/)\n      expect(titleElement).toHaveClass('truncate')\n    })\n\n    it('handles very large photo counts', () => {\n      const albumWithManyPhotos = createMockAlbum({ photoCount: 9999 })\n\n      render(<AlbumTile {...defaultProps} album={albumWithManyPhotos} />)\n\n      expect(screen.getByText('9,999 photos')).toBeInTheDocument()\n    })\n  })\n\n  describe('Performance', () => {\n    it('uses React.memo to prevent unnecessary rerenders', () => {\n      const { rerender } = render(<AlbumTile {...defaultProps} />)\n\n      // Same props should not cause rerender\n      rerender(<AlbumTile {...defaultProps} />)", "metadata": {}}
{"id": "639", "text": "render(<AlbumTile {...defaultProps} album={albumWithManyPhotos} />)\n\n      expect(screen.getByText('9,999 photos')).toBeInTheDocument()\n    })\n  })\n\n  describe('Performance', () => {\n    it('uses React.memo to prevent unnecessary rerenders', () => {\n      const { rerender } = render(<AlbumTile {...defaultProps} />)\n\n      // Same props should not cause rerender\n      rerender(<AlbumTile {...defaultProps} />)\n\n      // Component should be memoized (implementation detail)\n      expect(screen.getByText('Test Album')).toBeInTheDocument()\n    })\n\n    it('only loads thumbnail when in viewport', () => {\n      render(<AlbumTile {...defaultProps} />)\n\n      const thumbnail = screen.getByRole('img', { name: /test album thumbnail/i })\n      expect(thumbnail).toHaveAttribute('loading', 'lazy')\n    })\n  })\n})", "metadata": {}}
{"id": "640", "text": "import { render, screen } from '@testing-library/react';\nimport { ImageMetadata, ImageMetadataCompact } from '../../src/components/ImageMetadata/ImageMetadata';\nimport { Image, User } from '../../src/types';\n\ndescribe('ImageMetadata', () => {\n  const mockImage: Image = {\n    id: 'test-id',\n    filename: 'test-image.jpg',\n    path: '/images/test-image.jpg',\n    url: 'https://example.com/test-image.jpg',\n    caption: 'A beautiful sunset',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date('2024-01-15T10:30:00Z'),\n    capturedAt: new Date('2024-01-15T09:15:00Z'),\n    fileSize: 2457600,\n    width: 1920,\n    height: 1080,\n    mimeType: 'image/jpeg',\n    cameraModel: 'Canon EOS R5',\n    location: 'San Francisco, CA',\n    tags: ['landscape', 'nature', 'sunset'],\n  };", "metadata": {}}
{"id": "641", "text": "const mockUser: User = {\n    id: 'user-123',\n    username: 'photographer',\n    displayName: 'John Photographer',\n    email: 'john@example.com',\n    avatarUrl: 'https://example.com/avatar.jpg',\n  };\n\n  it('should display image filename', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Filename')).toBeInTheDocument();\n    expect(screen.getByText('test-image.jpg')).toBeInTheDocument();\n  });\n\n  it('should display image caption when provided', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Caption')).toBeInTheDocument();\n    expect(screen.getByText('A beautiful sunset')).toBeInTheDocument();\n  });\n\n  it('should not display caption when not provided', () => {\n    const imageWithoutCaption = { ...mockImage, caption: undefined };\n    render(<ImageMetadata image={imageWithoutCaption} />);\n    \n    expect(screen.queryByText('Caption')).not.toBeInTheDocument();\n  });", "metadata": {}}
{"id": "642", "text": "it('should display image caption when provided', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Caption')).toBeInTheDocument();\n    expect(screen.getByText('A beautiful sunset')).toBeInTheDocument();\n  });\n\n  it('should not display caption when not provided', () => {\n    const imageWithoutCaption = { ...mockImage, caption: undefined };\n    render(<ImageMetadata image={imageWithoutCaption} />);\n    \n    expect(screen.queryByText('Caption')).not.toBeInTheDocument();\n  });\n\n  it('should display file size in human readable format', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('File Size')).toBeInTheDocument();\n    expect(screen.getByText('2.35 MB')).toBeInTheDocument();\n  });\n\n  it('should display file type', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('File Type')).toBeInTheDocument();\n    expect(screen.getByText('JPEG')).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "643", "text": "it('should display file size in human readable format', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('File Size')).toBeInTheDocument();\n    expect(screen.getByText('2.35 MB')).toBeInTheDocument();\n  });\n\n  it('should display file type', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('File Type')).toBeInTheDocument();\n    expect(screen.getByText('JPEG')).toBeInTheDocument();\n  });\n\n  it('should display image dimensions', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Dimensions')).toBeInTheDocument();\n    expect(screen.getByText('1,920 × 1,080 px')).toBeInTheDocument();\n  });\n\n  it('should display upload date', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Uploaded')).toBeInTheDocument();\n    expect(screen.getByText(/January 15, 2024/)).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "644", "text": "it('should display image dimensions', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Dimensions')).toBeInTheDocument();\n    expect(screen.getByText('1,920 × 1,080 px')).toBeInTheDocument();\n  });\n\n  it('should display upload date', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Uploaded')).toBeInTheDocument();\n    expect(screen.getByText(/January 15, 2024/)).toBeInTheDocument();\n  });\n\n  it('should display capture date when available', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Captured')).toBeInTheDocument();\n    expect(screen.getByText(/January 15, 2024/)).toBeInTheDocument();\n  });\n\n  it('should not display capture date when not available', () => {\n    const imageWithoutCaptureDate = { ...mockImage, capturedAt: undefined };\n    render(<ImageMetadata image={imageWithoutCaptureDate} />);\n    \n    expect(screen.queryByText('Captured')).not.toBeInTheDocument();\n  });", "metadata": {}}
{"id": "645", "text": "it('should display capture date when available', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Captured')).toBeInTheDocument();\n    expect(screen.getByText(/January 15, 2024/)).toBeInTheDocument();\n  });\n\n  it('should not display capture date when not available', () => {\n    const imageWithoutCaptureDate = { ...mockImage, capturedAt: undefined };\n    render(<ImageMetadata image={imageWithoutCaptureDate} />);\n    \n    expect(screen.queryByText('Captured')).not.toBeInTheDocument();\n  });\n\n  it('should display uploader information when user is provided', () => {\n    render(<ImageMetadata image={mockImage} user={mockUser} />);\n    \n    expect(screen.getByText('Uploaded By')).toBeInTheDocument();\n    expect(screen.getByText('John Photographer')).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "646", "text": "it('should not display capture date when not available', () => {\n    const imageWithoutCaptureDate = { ...mockImage, capturedAt: undefined };\n    render(<ImageMetadata image={imageWithoutCaptureDate} />);\n    \n    expect(screen.queryByText('Captured')).not.toBeInTheDocument();\n  });\n\n  it('should display uploader information when user is provided', () => {\n    render(<ImageMetadata image={mockImage} user={mockUser} />);\n    \n    expect(screen.getByText('Uploaded By')).toBeInTheDocument();\n    expect(screen.getByText('John Photographer')).toBeInTheDocument();\n  });\n\n  it('should display user avatar when provided', () => {\n    render(<ImageMetadata image={mockImage} user={mockUser} />);\n    \n    const avatar = screen.getByAltText('John Photographer');\n    expect(avatar).toBeInTheDocument();\n    expect(avatar).toHaveAttribute('src', 'https://example.com/avatar.jpg');\n  });", "metadata": {}}
{"id": "647", "text": "it('should display uploader information when user is provided', () => {\n    render(<ImageMetadata image={mockImage} user={mockUser} />);\n    \n    expect(screen.getByText('Uploaded By')).toBeInTheDocument();\n    expect(screen.getByText('John Photographer')).toBeInTheDocument();\n  });\n\n  it('should display user avatar when provided', () => {\n    render(<ImageMetadata image={mockImage} user={mockUser} />);\n    \n    const avatar = screen.getByAltText('John Photographer');\n    expect(avatar).toBeInTheDocument();\n    expect(avatar).toHaveAttribute('src', 'https://example.com/avatar.jpg');\n  });\n\n  it('should display username when display name is not available', () => {\n    const userWithoutDisplayName = { ...mockUser, displayName: undefined };\n    render(<ImageMetadata image={mockImage} user={userWithoutDisplayName} />);\n    \n    expect(screen.getByText('photographer')).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "648", "text": "it('should display username when display name is not available', () => {\n    const userWithoutDisplayName = { ...mockUser, displayName: undefined };\n    render(<ImageMetadata image={mockImage} user={userWithoutDisplayName} />);\n    \n    expect(screen.getByText('photographer')).toBeInTheDocument();\n  });\n\n  it('should display camera model when available', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Camera')).toBeInTheDocument();\n    expect(screen.getByText('Canon EOS R5')).toBeInTheDocument();\n  });\n\n  it('should display location when available', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Location')).toBeInTheDocument();\n    expect(screen.getByText('San Francisco, CA')).toBeInTheDocument();\n  });\n\n  it('should display tags when available', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Tags')).toBeInTheDocument();\n    expect(screen.getByText('landscape')).toBeInTheDocument();\n    expect(screen.getByText('nature')).toBeInTheDocument();\n    expect(screen.getByText('sunset')).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "649", "text": "it('should display location when available', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Location')).toBeInTheDocument();\n    expect(screen.getByText('San Francisco, CA')).toBeInTheDocument();\n  });\n\n  it('should display tags when available', () => {\n    render(<ImageMetadata image={mockImage} />);\n    \n    expect(screen.getByText('Tags')).toBeInTheDocument();\n    expect(screen.getByText('landscape')).toBeInTheDocument();\n    expect(screen.getByText('nature')).toBeInTheDocument();\n    expect(screen.getByText('sunset')).toBeInTheDocument();\n  });\n\n  it('should not display tags section when no tags', () => {\n    const imageWithoutTags = { ...mockImage, tags: [] };\n    render(<ImageMetadata image={imageWithoutTags} />);\n    \n    expect(screen.queryByText('Tags')).not.toBeInTheDocument();\n  });\n\n  it('should apply custom className', () => {\n    const { container } = render(\n      <ImageMetadata image={mockImage} className=\"custom-class\" />\n    );\n    \n    expect(container.firstChild).toHaveClass('custom-class');\n  });\n});", "metadata": {}}
{"id": "650", "text": "it('should not display tags section when no tags', () => {\n    const imageWithoutTags = { ...mockImage, tags: [] };\n    render(<ImageMetadata image={imageWithoutTags} />);\n    \n    expect(screen.queryByText('Tags')).not.toBeInTheDocument();\n  });\n\n  it('should apply custom className', () => {\n    const { container } = render(\n      <ImageMetadata image={mockImage} className=\"custom-class\" />\n    );\n    \n    expect(container.firstChild).toHaveClass('custom-class');\n  });\n});\n\ndescribe('ImageMetadataCompact', () => {\n  const mockImage: Image = {\n    id: 'test-id',\n    filename: 'test-image.jpg',\n    path: '/images/test-image.jpg',\n    url: 'https://example.com/test-image.jpg',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date(),\n    fileSize: 2457600,\n    width: 1920,\n    height: 1080,\n    mimeType: 'image/jpeg',\n    tags: [],\n  };", "metadata": {}}
{"id": "651", "text": "describe('ImageMetadataCompact', () => {\n  const mockImage: Image = {\n    id: 'test-id',\n    filename: 'test-image.jpg',\n    path: '/images/test-image.jpg',\n    url: 'https://example.com/test-image.jpg',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date(),\n    fileSize: 2457600,\n    width: 1920,\n    height: 1080,\n    mimeType: 'image/jpeg',\n    tags: [],\n  };\n\n  it('should display file size in compact format', () => {\n    render(<ImageMetadataCompact image={mockImage} />);\n    \n    expect(screen.getByText('2.3 MB')).toBeInTheDocument();\n  });\n\n  it('should display dimensions when available', () => {\n    render(<ImageMetadataCompact image={mockImage} />);\n    \n    expect(screen.getByText('1920×1080')).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "652", "text": "it('should display file size in compact format', () => {\n    render(<ImageMetadataCompact image={mockImage} />);\n    \n    expect(screen.getByText('2.3 MB')).toBeInTheDocument();\n  });\n\n  it('should display dimensions when available', () => {\n    render(<ImageMetadataCompact image={mockImage} />);\n    \n    expect(screen.getByText('1920×1080')).toBeInTheDocument();\n  });\n\n  it('should not display dimensions when not available', () => {\n    const imageWithoutDimensions = { ...mockImage, width: undefined, height: undefined };\n    render(<ImageMetadataCompact image={imageWithoutDimensions} />);\n    \n    expect(screen.queryByText(/×/)).not.toBeInTheDocument();\n  });", "metadata": {}}
{"id": "653", "text": "it('should display dimensions when available', () => {\n    render(<ImageMetadataCompact image={mockImage} />);\n    \n    expect(screen.getByText('1920×1080')).toBeInTheDocument();\n  });\n\n  it('should not display dimensions when not available', () => {\n    const imageWithoutDimensions = { ...mockImage, width: undefined, height: undefined };\n    render(<ImageMetadataCompact image={imageWithoutDimensions} />);\n    \n    expect(screen.queryByText(/×/)).not.toBeInTheDocument();\n  });\n\n  it('should display capture date when available', () => {\n    const imageWithCaptureDate = { \n      ...mockImage, \n      capturedAt: new Date('2024-01-15T10:30:00Z')\n    };\n    render(<ImageMetadataCompact image={imageWithCaptureDate} />);\n    \n    expect(screen.getByText(/Captured: January 15, 2024/)).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "654", "text": "it('should display capture date when available', () => {\n    const imageWithCaptureDate = { \n      ...mockImage, \n      capturedAt: new Date('2024-01-15T10:30:00Z')\n    };\n    render(<ImageMetadataCompact image={imageWithCaptureDate} />);\n    \n    expect(screen.getByText(/Captured: January 15, 2024/)).toBeInTheDocument();\n  });\n\n  it('should not display capture date when not available', () => {\n    render(<ImageMetadataCompact image={mockImage} />);\n    \n    expect(screen.queryByText(/Captured:/)).not.toBeInTheDocument();\n  });\n\n  it('should apply custom className', () => {\n    const { container } = render(\n      <ImageMetadataCompact image={mockImage} className=\"custom-class\" />\n    );\n    \n    expect(container.firstChild).toHaveClass('custom-class');\n  });\n});", "metadata": {}}
{"id": "655", "text": "import { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport { http } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { getImageFile } from '../../src/services/imageService';\nimport { createTestImage } from '../utils/test-utils';\n\nconst mockImage = createTestImage();\nconst mockImageData = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]); // PNG header\n\nconst server = setupServer(\n  http.get('/api/images/:id/file', (req, res, ctx) => {\n    const { id } = req.params;\n    const url = new URL(req.url);\n    const size = url.searchParams.get('size') || 'medium';\n\n    if (id === mockImage.id) {\n      return res(\n        ctx.set('Content-Type', 'image/png'),\n        ctx.set('Content-Length', mockImageData.length.toString()),\n        ctx.body(mockImageData)\n      );\n    }\n    return res(ctx.status(404));\n  })\n);", "metadata": {}}
{"id": "656", "text": "const server = setupServer(\n  http.get('/api/images/:id/file', (req, res, ctx) => {\n    const { id } = req.params;\n    const url = new URL(req.url);\n    const size = url.searchParams.get('size') || 'medium';\n\n    if (id === mockImage.id) {\n      return res(\n        ctx.set('Content-Type', 'image/png'),\n        ctx.set('Content-Length', mockImageData.length.toString()),\n        ctx.body(mockImageData)\n      );\n    }\n    return res(ctx.status(404));\n  })\n);\n\ndescribe('GET /api/images/{id}/file Contract Test', () => {\n  beforeAll(() => server.listen());\n  afterAll(() => server.close());\n\n  it('should return 200 and image file for valid ID', async () => {\n    const response = await fetch(`/api/images/${mockImage.id}/file`);\n\n    expect(response.status).toBe(200);\n    expect(response.headers.get('Content-Type')).toBe('image/png');\n    expect(response.headers.get('Content-Length')).toBe(mockImageData.length.toString());", "metadata": {}}
{"id": "657", "text": "describe('GET /api/images/{id}/file Contract Test', () => {\n  beforeAll(() => server.listen());\n  afterAll(() => server.close());\n\n  it('should return 200 and image file for valid ID', async () => {\n    const response = await fetch(`/api/images/${mockImage.id}/file`);\n\n    expect(response.status).toBe(200);\n    expect(response.headers.get('Content-Type')).toBe('image/png');\n    expect(response.headers.get('Content-Length')).toBe(mockImageData.length.toString());\n\n    const arrayBuffer = await response.arrayBuffer();\n    const data = new Uint8Array(arrayBuffer);\n    expect(data).toEqual(mockImageData);\n  });\n\n  it('should return 404 for non-existent image ID', async () => {\n    const response = await fetch('/api/images/550e8400-e29b-41d4-a716-446655440001/file');\n\n    expect(response.status).toBe(404);\n  });", "metadata": {}}
{"id": "658", "text": "const arrayBuffer = await response.arrayBuffer();\n    const data = new Uint8Array(arrayBuffer);\n    expect(data).toEqual(mockImageData);\n  });\n\n  it('should return 404 for non-existent image ID', async () => {\n    const response = await fetch('/api/images/550e8400-e29b-41d4-a716-446655440001/file');\n\n    expect(response.status).toBe(404);\n  });\n\n  it('should support size parameter with default to medium', async () => {\n    const response = await fetch(`/api/images/${mockImage.id}/file`);\n    const responseThumb = await fetch(`/api/images/${mockImage.id}/file?size=thumb`);\n    const responseLarge = await fetch(`/api/images/${mockImage.id}/file?size=large`);\n\n    expect(response.status).toBe(200);\n    expect(responseThumb.status).toBe(200);\n    expect(responseLarge.status).toBe(200);\n  });", "metadata": {}}
{"id": "659", "text": "expect(response.status).toBe(404);\n  });\n\n  it('should support size parameter with default to medium', async () => {\n    const response = await fetch(`/api/images/${mockImage.id}/file`);\n    const responseThumb = await fetch(`/api/images/${mockImage.id}/file?size=thumb`);\n    const responseLarge = await fetch(`/api/images/${mockImage.id}/file?size=large`);\n\n    expect(response.status).toBe(200);\n    expect(responseThumb.status).toBe(200);\n    expect(responseLarge.status).toBe(200);\n  });\n\n  it('should validate size parameter values', async () => {\n    const responseInvalid = await fetch(`/api/images/${mockImage.id}/file?size=invalid`);\n    expect(responseInvalid.status).toBe(400);\n  });\n\n  it('should return correct MIME type based on image', async () => {\n    const response = await getImageFile(mockImage.id);\n    expect(response.type).toBe('image/png');\n  });\n});", "metadata": {}}
{"id": "660", "text": "import { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport { http } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { createTestImage } from '../utils/test-utils';\nimport { getImage } from '../../src/services/imageService';\n\nconst mockImage = createTestImage();\n\nconst server = setupServer(\n  http.get('/api/images/:id', (req, res, ctx) => {\n    const { id } = req.params;\n    if (id === mockImage.id) {\n      return res(ctx.json(mockImage));\n    }\n    return res(ctx.status(404), ctx.json({ error: 'Image not found' }));\n  })\n);\n\ndescribe('GET /api/images/{id} Contract Test', () => {\n  beforeAll(() => server.listen());\n  afterAll(() => server.close());\n\n  it('should return 200 and image details for valid ID', async () => {\n    const response = await fetch(`/api/images/${mockImage.id}`);\n\n    expect(response.status).toBe(200);\n    const data = await response.json();", "metadata": {}}
{"id": "661", "text": "describe('GET /api/images/{id} Contract Test', () => {\n  beforeAll(() => server.listen());\n  afterAll(() => server.close());\n\n  it('should return 200 and image details for valid ID', async () => {\n    const response = await fetch(`/api/images/${mockImage.id}`);\n\n    expect(response.status).toBe(200);\n    const data = await response.json();\n\n    expect(data).toEqual(mockImage);\n    expect(data.id).toBe(mockImage.id);\n    expect(data.filename).toBe(mockImage.filename);\n    expect(data.uploadedBy).toBeDefined();\n  });\n\n  it('should return 404 for non-existent image ID', async () => {\n    const response = await fetch('/api/images/550e8400-e29b-41d4-a716-446655440001');\n\n    expect(response.status).toBe(404);\n    const data = await response.json();\n    expect(data.error).toBe('Image not found');\n  });\n\n  it('should return image with all required fields', async () => {\n    const image = await getImage(mockImage.id);", "metadata": {}}
{"id": "662", "text": "it('should return 404 for non-existent image ID', async () => {\n    const response = await fetch('/api/images/550e8400-e29b-41d4-a716-446655440001');\n\n    expect(response.status).toBe(404);\n    const data = await response.json();\n    expect(data.error).toBe('Image not found');\n  });\n\n  it('should return image with all required fields', async () => {\n    const image = await getImage(mockImage.id);\n\n    expect(image).toHaveProperty('id');\n    expect(image).toHaveProperty('filename');\n    expect(image).toHaveProperty('path');\n    expect(image).toHaveProperty('uploadedBy');\n    expect(image).toHaveProperty('uploadedAt');\n    expect(image).toHaveProperty('fileSize');\n    expect(image).toHaveProperty('mimeType');\n  });\n\n  it('should include optional fields when present', async () => {\n    const image = await getImage(mockImage.id);", "metadata": {}}
{"id": "663", "text": "it('should return image with all required fields', async () => {\n    const image = await getImage(mockImage.id);\n\n    expect(image).toHaveProperty('id');\n    expect(image).toHaveProperty('filename');\n    expect(image).toHaveProperty('path');\n    expect(image).toHaveProperty('uploadedBy');\n    expect(image).toHaveProperty('uploadedAt');\n    expect(image).toHaveProperty('fileSize');\n    expect(image).toHaveProperty('mimeType');\n  });\n\n  it('should include optional fields when present', async () => {\n    const image = await getImage(mockImage.id);\n\n    expect(image).toHaveProperty('caption');\n    expect(image).toHaveProperty('capturedAt');\n    expect(image).toHaveProperty('width');\n    expect(image).toHaveProperty('height');\n    expect(image).toHaveProperty('tags');\n  });\n});", "metadata": {}}
{"id": "664", "text": "import { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport { http } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { updateImage } from '../../src/services/imageService';\nimport { createTestImage } from '../utils/test-utils';\n\nconst mockImage = createTestImage();\n\nconst server = setupServer(\n  http.put('/api/images/:id', async (req, res, ctx) => {\n    const { id } = req.params;\n    const body = await req.json();\n\n    if (id === mockImage.id) {\n      const updatedImage = {\n        ...mockImage,\n        caption: body.caption || mockImage.caption,\n        tags: body.tags || mockImage.tags\n      };\n      return res(ctx.json(updatedImage));\n    }\n    return res(ctx.status(404), ctx.json({ error: 'Image not found' }));\n  })\n);\n\ndescribe('PUT /api/images/{id} Contract Test', () => {\n  beforeAll(() => server.listen());\n  afterAll(() => server.close());", "metadata": {}}
{"id": "665", "text": "if (id === mockImage.id) {\n      const updatedImage = {\n        ...mockImage,\n        caption: body.caption || mockImage.caption,\n        tags: body.tags || mockImage.tags\n      };\n      return res(ctx.json(updatedImage));\n    }\n    return res(ctx.status(404), ctx.json({ error: 'Image not found' }));\n  })\n);\n\ndescribe('PUT /api/images/{id} Contract Test', () => {\n  beforeAll(() => server.listen());\n  afterAll(() => server.close());\n\n  it('should update image caption successfully', async () => {\n    const updateData = {\n      caption: 'Updated beautiful sunset photo'\n    };\n\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(200);\n    const data = await response.json();\n    expect(data.caption).toBe(updateData.caption);\n    expect(data.id).toBe(mockImage.id);\n  });", "metadata": {}}
{"id": "666", "text": "it('should update image caption successfully', async () => {\n    const updateData = {\n      caption: 'Updated beautiful sunset photo'\n    };\n\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(200);\n    const data = await response.json();\n    expect(data.caption).toBe(updateData.caption);\n    expect(data.id).toBe(mockImage.id);\n  });\n\n  it('should update image tags successfully', async () => {\n    const updateData = {\n      tags: ['nature', 'landscape', 'sunset']\n    };\n\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(200);\n    const data = await response.json();\n    expect(data.tags).toEqual(updateData.tags);\n  });", "metadata": {}}
{"id": "667", "text": "it('should update image tags successfully', async () => {\n    const updateData = {\n      tags: ['nature', 'landscape', 'sunset']\n    };\n\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(200);\n    const data = await response.json();\n    expect(data.tags).toEqual(updateData.tags);\n  });\n\n  it('should update both caption and tags together', async () => {\n    const updateData = {\n      caption: 'Beach vacation',\n      tags: ['vacation', 'beach', 'family']\n    };\n\n    const response = await updateImage(mockImage.id, updateData);\n\n    expect(response).toBeDefined();\n    expect(response.caption).toBe(updateData.caption);\n    expect(response.tags).toEqual(updateData.tags);\n  });", "metadata": {}}
{"id": "668", "text": "expect(response.status).toBe(200);\n    const data = await response.json();\n    expect(data.tags).toEqual(updateData.tags);\n  });\n\n  it('should update both caption and tags together', async () => {\n    const updateData = {\n      caption: 'Beach vacation',\n      tags: ['vacation', 'beach', 'family']\n    };\n\n    const response = await updateImage(mockImage.id, updateData);\n\n    expect(response).toBeDefined();\n    expect(response.caption).toBe(updateData.caption);\n    expect(response.tags).toEqual(updateData.tags);\n  });\n\n  it('should return 404 for non-existent image ID', async () => {\n    const updateData = { caption: 'New caption' };\n    const response = await fetch('/api/images/550e8400-e29b-41d4-a716-446655440001', {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(404);\n  });", "metadata": {}}
{"id": "669", "text": "it('should return 404 for non-existent image ID', async () => {\n    const updateData = { caption: 'New caption' };\n    const response = await fetch('/api/images/550e8400-e29b-41d4-a716-446655440001', {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(404);\n  });\n\n  it('should validate caption length', async () => {\n    const updateData = {\n      caption: 'a'.repeat(501) // Exceeds 500 char limit\n    };\n\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(400);\n  });", "metadata": {}}
{"id": "670", "text": "expect(response.status).toBe(404);\n  });\n\n  it('should validate caption length', async () => {\n    const updateData = {\n      caption: 'a'.repeat(501) // Exceeds 500 char limit\n    };\n\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(400);\n  });\n\n  it('should validate tag length', async () => {\n    const updateData = {\n      tags: ['a'.repeat(51)] // Exceeds 50 char limit\n    };\n\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(400);\n  });", "metadata": {}}
{"id": "671", "text": "expect(response.status).toBe(400);\n  });\n\n  it('should validate tag length', async () => {\n    const updateData = {\n      tags: ['a'.repeat(51)] // Exceeds 50 char limit\n    };\n\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    expect(response.status).toBe(400);\n  });\n\n  it('should reject invalid JSON', async () => {\n    const response = await fetch(`/api/images/${mockImage.id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: 'invalid json',\n    });\n\n    expect(response.status).toBe(400);\n  });\n});", "metadata": {}}
{"id": "672", "text": "import { renderHook, act } from '@testing-library/react';\nimport { useImageDetail, useImageDetailById, useImageFile } from '../../src/hooks/useImageDetail';\nimport { Image } from '../../src/types/image';\n\n// Mock the image service\nvi.mock('../../src/services/imageService', () => ({\n  getImage: vi.fn(),\n  getImageFile: vi.fn(),\n}));\n\ndescribe('useImageDetail', () => {\n  const mockImage: Image = {\n    id: 'test-id',\n    filename: 'test.jpg',\n    path: '/images/test.jpg',\n    url: 'https://example.com/test.jpg',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date(),\n    fileSize: 1024,\n    mimeType: 'image/jpeg',\n    tags: [],\n  };\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should initialize with default state', () => {\n    const { result } = renderHook(() => useImageDetail());", "metadata": {}}
{"id": "673", "text": "describe('useImageDetail', () => {\n  const mockImage: Image = {\n    id: 'test-id',\n    filename: 'test.jpg',\n    path: '/images/test.jpg',\n    url: 'https://example.com/test.jpg',\n    uploadedBy: 'user-123',\n    uploadedAt: new Date(),\n    fileSize: 1024,\n    mimeType: 'image/jpeg',\n    tags: [],\n  };\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should initialize with default state', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    expect(result.current.state).toEqual({\n      isOpen: false,\n      selectedImage: null,\n      isLoading: false,\n      error: null,\n    });\n  });\n\n  it('should open detail with image object', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.openDetail(mockImage);\n    });", "metadata": {}}
{"id": "674", "text": "beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should initialize with default state', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    expect(result.current.state).toEqual({\n      isOpen: false,\n      selectedImage: null,\n      isLoading: false,\n      error: null,\n    });\n  });\n\n  it('should open detail with image object', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.openDetail(mockImage);\n    });\n\n    expect(result.current.state.isOpen).toBe(true);\n    expect(result.current.state.selectedImage).toEqual(mockImage);\n    expect(result.current.state.isLoading).toBe(false);\n  });\n\n  it('should open detail with image ID and set loading', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.openDetail('test-id');\n    });", "metadata": {}}
{"id": "675", "text": "it('should open detail with image object', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.openDetail(mockImage);\n    });\n\n    expect(result.current.state.isOpen).toBe(true);\n    expect(result.current.state.selectedImage).toEqual(mockImage);\n    expect(result.current.state.isLoading).toBe(false);\n  });\n\n  it('should open detail with image ID and set loading', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.openDetail('test-id');\n    });\n\n    expect(result.current.state.isOpen).toBe(true);\n    expect(result.current.state.selectedImage).toBeNull();\n    expect(result.current.state.isLoading).toBe(true);\n  });\n\n  it('should close detail and reset state', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    // First open with an image\n    act(() => {\n      result.current.openDetail(mockImage);\n    });\n\n    // Then close\n    act(() => {\n      result.current.closeDetail();\n    });", "metadata": {}}
{"id": "676", "text": "act(() => {\n      result.current.openDetail('test-id');\n    });\n\n    expect(result.current.state.isOpen).toBe(true);\n    expect(result.current.state.selectedImage).toBeNull();\n    expect(result.current.state.isLoading).toBe(true);\n  });\n\n  it('should close detail and reset state', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    // First open with an image\n    act(() => {\n      result.current.openDetail(mockImage);\n    });\n\n    // Then close\n    act(() => {\n      result.current.closeDetail();\n    });\n\n    expect(result.current.state.isOpen).toBe(false);\n    expect(result.current.state.selectedImage).toBeNull();\n    expect(result.current.state.isLoading).toBe(false);\n    expect(result.current.state.error).toBeNull();\n  });\n\n  it('should set image data', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.setImage(mockImage);\n    });", "metadata": {}}
{"id": "677", "text": "// First open with an image\n    act(() => {\n      result.current.openDetail(mockImage);\n    });\n\n    // Then close\n    act(() => {\n      result.current.closeDetail();\n    });\n\n    expect(result.current.state.isOpen).toBe(false);\n    expect(result.current.state.selectedImage).toBeNull();\n    expect(result.current.state.isLoading).toBe(false);\n    expect(result.current.state.error).toBeNull();\n  });\n\n  it('should set image data', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.setImage(mockImage);\n    });\n\n    expect(result.current.state.selectedImage).toEqual(mockImage);\n    expect(result.current.state.isLoading).toBe(false);\n    expect(result.current.state.error).toBeNull();\n  });\n\n  it('should set loading state', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.setLoading(true);\n    });\n\n    expect(result.current.state.isLoading).toBe(true);\n  });", "metadata": {}}
{"id": "678", "text": "act(() => {\n      result.current.setImage(mockImage);\n    });\n\n    expect(result.current.state.selectedImage).toEqual(mockImage);\n    expect(result.current.state.isLoading).toBe(false);\n    expect(result.current.state.error).toBeNull();\n  });\n\n  it('should set loading state', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.setLoading(true);\n    });\n\n    expect(result.current.state.isLoading).toBe(true);\n  });\n\n  it('should set error state', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.setError('Test error');\n    });\n\n    expect(result.current.state.error).toBe('Test error');\n    expect(result.current.state.isLoading).toBe(false);\n  });\n\n  it('should accept initial state', () => {\n    const initialState = {\n      isOpen: true,\n      selectedImage: mockImage,\n      isLoading: true,\n      error: 'Initial error',\n    };\n\n    const { result } = renderHook(() => useImageDetail(initialState));", "metadata": {}}
{"id": "679", "text": "it('should set error state', () => {\n    const { result } = renderHook(() => useImageDetail());\n\n    act(() => {\n      result.current.setError('Test error');\n    });\n\n    expect(result.current.state.error).toBe('Test error');\n    expect(result.current.state.isLoading).toBe(false);\n  });\n\n  it('should accept initial state', () => {\n    const initialState = {\n      isOpen: true,\n      selectedImage: mockImage,\n      isLoading: true,\n      error: 'Initial error',\n    };\n\n    const { result } = renderHook(() => useImageDetail(initialState));\n\n    expect(result.current.state).toEqual(initialState);\n  });\n});\n\ndescribe('useImageDetailById', () => {\n  const { getImage } = require('../../src/services/imageService');\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });", "metadata": {}}
{"id": "680", "text": "it('should accept initial state', () => {\n    const initialState = {\n      isOpen: true,\n      selectedImage: mockImage,\n      isLoading: true,\n      error: 'Initial error',\n    };\n\n    const { result } = renderHook(() => useImageDetail(initialState));\n\n    expect(result.current.state).toEqual(initialState);\n  });\n});\n\ndescribe('useImageDetailById', () => {\n  const { getImage } = require('../../src/services/imageService');\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should fetch image by ID successfully', async () => {\n    const mockImage = {\n      id: 'test-id',\n      filename: 'test.jpg',\n    };\n    \n    getImage.mockResolvedValue(mockImage);\n    \n    const { result } = renderHook(() => useImageDetailById());\n    \n    await act(async () => {\n      const image = await result.current.getImageById('test-id');\n      expect(image).toEqual(mockImage);\n    });\n    \n    expect(getImage).toHaveBeenCalledWith('test-id');\n    expect(result.current.isLoading).toBe(false);\n    expect(result.current.error).toBeNull();\n  });", "metadata": {}}
{"id": "681", "text": "it('should fetch image by ID successfully', async () => {\n    const mockImage = {\n      id: 'test-id',\n      filename: 'test.jpg',\n    };\n    \n    getImage.mockResolvedValue(mockImage);\n    \n    const { result } = renderHook(() => useImageDetailById());\n    \n    await act(async () => {\n      const image = await result.current.getImageById('test-id');\n      expect(image).toEqual(mockImage);\n    });\n    \n    expect(getImage).toHaveBeenCalledWith('test-id');\n    expect(result.current.isLoading).toBe(false);\n    expect(result.current.error).toBeNull();\n  });\n\n  it('should handle error when fetching image', async () => {\n    const error = new Error('Image not found');\n    getImage.mockRejectedValue(error);\n    \n    const { result } = renderHook(() => useImageDetailById());\n    \n    await act(async () => {\n      const image = await result.current.getImageById('invalid-id');\n      expect(image).toBeNull();\n    });\n    \n    expect(result.current.isLoading).toBe(false);\n    expect(result.current.error).toBe('Image not found');\n  });", "metadata": {}}
{"id": "682", "text": "it('should handle error when fetching image', async () => {\n    const error = new Error('Image not found');\n    getImage.mockRejectedValue(error);\n    \n    const { result } = renderHook(() => useImageDetailById());\n    \n    await act(async () => {\n      const image = await result.current.getImageById('invalid-id');\n      expect(image).toBeNull();\n    });\n    \n    expect(result.current.isLoading).toBe(false);\n    expect(result.current.error).toBe('Image not found');\n  });\n\n  it('should set loading state during fetch', async () => {\n    // Create a promise that we can resolve manually\n    let resolvePromise: any;\n    const mockPromise = new Promise((resolve) => {\n      resolvePromise = resolve;\n    });\n    \n    getImage.mockReturnValue(mockPromise);\n    \n    const { result } = renderHook(() => useImageDetailById());\n    \n    // Start the fetch\n    const fetchPromise = act(() => result.current.getImageById('test-id'));\n    \n    // Should be loading immediately\n    expect(result.current.isLoading).toBe(true);\n    \n    // Resolve the promise\n    await act(async () => {\n      resolvePromise({ id: 'test-id' });\n      await fetchPromise;\n    });\n    \n    // Should no longer be loading\n    expect(result.current.isLoading).toBe(false);\n  });\n});", "metadata": {}}
{"id": "683", "text": "describe('useImageFile', () => {\n  const { getImageFile } = require('../../src/services/imageService');\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should fetch image file URL successfully', async () => {\n    const mockUrl = 'blob:test-url';\n    getImageFile.mockResolvedValue(mockUrl);\n    \n    const { result } = renderHook(() => useImageFile());\n    \n    await act(async () => {\n      const url = await result.current.getImageFile('test-id');\n      expect(url).toBe(mockUrl);\n    });\n    \n    expect(getImageFile).toHaveBeenCalledWith('test-id');\n    expect(result.current.isLoading).toBe(false);\n    expect(result.current.error).toBeNull();\n  });", "metadata": {}}
{"id": "684", "text": "beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should fetch image file URL successfully', async () => {\n    const mockUrl = 'blob:test-url';\n    getImageFile.mockResolvedValue(mockUrl);\n    \n    const { result } = renderHook(() => useImageFile());\n    \n    await act(async () => {\n      const url = await result.current.getImageFile('test-id');\n      expect(url).toBe(mockUrl);\n    });\n    \n    expect(getImageFile).toHaveBeenCalledWith('test-id');\n    expect(result.current.isLoading).toBe(false);\n    expect(result.current.error).toBeNull();\n  });\n\n  it('should handle error when fetching image file', async () => {\n    const error = new Error('File not found');\n    getImageFile.mockRejectedValue(error);\n    \n    const { result } = renderHook(() => useImageFile());\n    \n    await act(async () => {\n      const url = await result.current.getImageFile('invalid-id');\n      expect(url).toBeNull();\n    });\n    \n    expect(result.current.isLoading).toBe(false);\n    expect(result.current.error).toBe('File not found');\n  });\n});", "metadata": {}}
{"id": "685", "text": "/**\n * useInfiniteScroll Hook Tests\n * Tests the infinite scroll hook functionality following TDD approach\n */\n\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { renderHook, act, waitFor } from '@testing-library/react'\nimport { useInfiniteScroll } from '../../src/hooks/useInfiniteScroll'\nimport { mockIntersectionObserver, setupURLMocks } from '../utils'\nimport { InfiniteScrollOptions } from '../../src/types'\n\ndescribe('useInfiniteScroll', () => {\n  let mockObserverInstance: {\n    observe: ReturnType<typeof vi.fn>\n    disconnect: ReturnType<typeof vi.fn>\n    unobserve: ReturnType<typeof vi.fn>\n  }\n\n  beforeEach(() => {\n    setupURLMocks()\n    mockObserverInstance = mockIntersectionObserver()\n  })\n\n  afterEach(() => {\n    vi.clearAllMocks()\n  })\n\n  describe('Basic Functionality', () => {\n    it('returns correct initial state', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() =>\n        useInfiniteScroll(mockCallback, { enabled: true })\n      )", "metadata": {}}
{"id": "686", "text": "beforeEach(() => {\n    setupURLMocks()\n    mockObserverInstance = mockIntersectionObserver()\n  })\n\n  afterEach(() => {\n    vi.clearAllMocks()\n  })\n\n  describe('Basic Functionality', () => {\n    it('returns correct initial state', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() =>\n        useInfiniteScroll(mockCallback, { enabled: true })\n      )\n\n      expect(result.current.isLoading).toBe(false)\n      expect(result.current.hasNextPage).toBe(true)\n      expect(result.current.error).toBe(null)\n      expect(result.current.triggerRef).toBeDefined()\n    })\n\n    it('provides a trigger ref for DOM element attachment', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      expect(result.current.triggerRef).toBeDefined()\n      expect(result.current.triggerRef.current).toBe(null)\n    })\n\n    it('creates IntersectionObserver when hook mounts', () => {\n      const mockCallback = vi.fn()\n      renderHook(() => useInfiniteScroll(mockCallback))", "metadata": {}}
{"id": "687", "text": "it('provides a trigger ref for DOM element attachment', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      expect(result.current.triggerRef).toBeDefined()\n      expect(result.current.triggerRef.current).toBe(null)\n    })\n\n    it('creates IntersectionObserver when hook mounts', () => {\n      const mockCallback = vi.fn()\n      renderHook(() => useInfiniteScroll(mockCallback))\n\n      expect(IntersectionObserver).toHaveBeenCalledWith(\n        expect.any(Function),\n        expect.objectContaining({\n          rootMargin: '50px',\n          threshold: 0.1,\n        })\n      )\n    })\n\n    it('observes trigger element when ref is attached', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      // Simulate ref attachment\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })", "metadata": {}}
{"id": "688", "text": "expect(IntersectionObserver).toHaveBeenCalledWith(\n        expect.any(Function),\n        expect.objectContaining({\n          rootMargin: '50px',\n          threshold: 0.1,\n        })\n      )\n    })\n\n    it('observes trigger element when ref is attached', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      // Simulate ref attachment\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(\n        mockTriggerElement\n      )\n    })\n\n    it('disconnects observer on unmount', () => {\n      const mockCallback = vi.fn()\n      const { unmount } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      unmount()\n\n      expect(mockObserverInstance.disconnect).toHaveBeenCalled()\n    })\n  })", "metadata": {}}
{"id": "689", "text": "// Simulate ref attachment\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(\n        mockTriggerElement\n      )\n    })\n\n    it('disconnects observer on unmount', () => {\n      const mockCallback = vi.fn()\n      const { unmount } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      unmount()\n\n      expect(mockObserverInstance.disconnect).toHaveBeenCalled()\n    })\n  })\n\n  describe('Configuration Options', () => {\n    it('accepts custom threshold option', () => {\n      const mockCallback = vi.fn()\n      const options: InfiniteScrollOptions = {\n        threshold: 0.5,\n        enabled: true,\n      }\n\n      renderHook(() => useInfiniteScroll(mockCallback, options))\n\n      expect(IntersectionObserver).toHaveBeenCalledWith(\n        expect.any(Function),\n        expect.objectContaining({\n          threshold: 0.5,\n        })\n      )\n    })", "metadata": {}}
{"id": "690", "text": "unmount()\n\n      expect(mockObserverInstance.disconnect).toHaveBeenCalled()\n    })\n  })\n\n  describe('Configuration Options', () => {\n    it('accepts custom threshold option', () => {\n      const mockCallback = vi.fn()\n      const options: InfiniteScrollOptions = {\n        threshold: 0.5,\n        enabled: true,\n      }\n\n      renderHook(() => useInfiniteScroll(mockCallback, options))\n\n      expect(IntersectionObserver).toHaveBeenCalledWith(\n        expect.any(Function),\n        expect.objectContaining({\n          threshold: 0.5,\n        })\n      )\n    })\n\n    it('accepts custom rootMargin option', () => {\n      const mockCallback = vi.fn()\n      const options: InfiniteScrollOptions = {\n        rootMargin: '100px',\n        enabled: true,\n      }\n\n      renderHook(() => useInfiniteScroll(mockCallback, options))\n\n      expect(IntersectionObserver).toHaveBeenCalledWith(\n        expect.any(Function),\n        expect.objectContaining({\n          rootMargin: '100px',\n        })\n      )\n    })", "metadata": {}}
{"id": "691", "text": "expect(IntersectionObserver).toHaveBeenCalledWith(\n        expect.any(Function),\n        expect.objectContaining({\n          threshold: 0.5,\n        })\n      )\n    })\n\n    it('accepts custom rootMargin option', () => {\n      const mockCallback = vi.fn()\n      const options: InfiniteScrollOptions = {\n        rootMargin: '100px',\n        enabled: true,\n      }\n\n      renderHook(() => useInfiniteScroll(mockCallback, options))\n\n      expect(IntersectionObserver).toHaveBeenCalledWith(\n        expect.any(Function),\n        expect.objectContaining({\n          rootMargin: '100px',\n        })\n      )\n    })\n\n    it('respects enabled option when false', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() =>\n        useInfiniteScroll(mockCallback, { enabled: false })\n      )\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      // Should not observe when disabled\n      expect(mockObserverInstance.observe).not.toHaveBeenCalled()\n    })", "metadata": {}}
{"id": "692", "text": "it('respects enabled option when false', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() =>\n        useInfiniteScroll(mockCallback, { enabled: false })\n      )\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      // Should not observe when disabled\n      expect(mockObserverInstance.observe).not.toHaveBeenCalled()\n    })\n\n    it('starts observing when enabled changes from false to true', () => {\n      const mockCallback = vi.fn()\n      let enabled = false\n\n      const { result, rerender } = renderHook(() =>\n        useInfiniteScroll(mockCallback, { enabled })\n      )\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      // Initially not observing\n      expect(mockObserverInstance.observe).not.toHaveBeenCalled()\n\n      // Enable and rerender\n      enabled = true\n      rerender()", "metadata": {}}
{"id": "693", "text": "it('starts observing when enabled changes from false to true', () => {\n      const mockCallback = vi.fn()\n      let enabled = false\n\n      const { result, rerender } = renderHook(() =>\n        useInfiniteScroll(mockCallback, { enabled })\n      )\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      // Initially not observing\n      expect(mockObserverInstance.observe).not.toHaveBeenCalled()\n\n      // Enable and rerender\n      enabled = true\n      rerender()\n\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(\n        mockTriggerElement\n      )\n    })\n  })\n\n  describe('Intersection Handling', () => {\n    it('calls callback when trigger element intersects', async () => {\n      const mockCallback = vi.fn().mockResolvedValue(undefined)\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })", "metadata": {}}
{"id": "694", "text": "// Enable and rerender\n      enabled = true\n      rerender()\n\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(\n        mockTriggerElement\n      )\n    })\n  })\n\n  describe('Intersection Handling', () => {\n    it('calls callback when trigger element intersects', async () => {\n      const mockCallback = vi.fn().mockResolvedValue(undefined)\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      // Get the intersection callback\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      // Simulate intersection\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n    })", "metadata": {}}
{"id": "695", "text": "const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      // Get the intersection callback\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      // Simulate intersection\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n    })\n\n    it('does not call callback when element is not intersecting', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]", "metadata": {}}
{"id": "696", "text": "expect(mockCallback).toHaveBeenCalledTimes(1)\n    })\n\n    it('does not call callback when element is not intersecting', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: false,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n\n    it('does not call callback when hasNextPage is false', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))", "metadata": {}}
{"id": "697", "text": "const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: false,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n\n    it('does not call callback when hasNextPage is false', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      // Set hasNextPage to false\n      act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]", "metadata": {}}
{"id": "698", "text": "it('does not call callback when hasNextPage is false', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      // Set hasNextPage to false\n      act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n\n    it('does not call callback when already loading', async () => {\n      const mockCallback = vi\n        .fn()\n        .mockImplementationOnce(\n          () => new Promise(resolve => setTimeout(resolve, 100))\n        )", "metadata": {}}
{"id": "699", "text": "act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n\n    it('does not call callback when already loading', async () => {\n      const mockCallback = vi\n        .fn()\n        .mockImplementationOnce(\n          () => new Promise(resolve => setTimeout(resolve, 100))\n        )\n\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]", "metadata": {}}
{"id": "700", "text": "it('does not call callback when already loading', async () => {\n      const mockCallback = vi\n        .fn()\n        .mockImplementationOnce(\n          () => new Promise(resolve => setTimeout(resolve, 100))\n        )\n\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      // First intersection - should trigger\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(result.current.isLoading).toBe(true)", "metadata": {}}
{"id": "701", "text": "const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      // First intersection - should trigger\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(result.current.isLoading).toBe(true)\n\n      // Second intersection while loading - should not trigger\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n    })\n  })", "metadata": {}}
{"id": "702", "text": "expect(result.current.isLoading).toBe(true)\n\n      // Second intersection while loading - should not trigger\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n    })\n  })\n\n  describe('Loading State Management', () => {\n    it('sets loading state during async callback execution', async () => {\n      const mockCallback = vi\n        .fn()\n        .mockImplementation(\n          () => new Promise(resolve => setTimeout(resolve, 50))\n        )\n\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]", "metadata": {}}
{"id": "703", "text": "describe('Loading State Management', () => {\n    it('sets loading state during async callback execution', async () => {\n      const mockCallback = vi\n        .fn()\n        .mockImplementation(\n          () => new Promise(resolve => setTimeout(resolve, 50))\n        )\n\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(result.current.isLoading).toBe(true)\n\n      await waitFor(\n        () => {\n          expect(result.current.isLoading).toBe(false)\n        },\n        { timeout: 100 }\n      )\n    })", "metadata": {}}
{"id": "704", "text": "const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(result.current.isLoading).toBe(true)\n\n      await waitFor(\n        () => {\n          expect(result.current.isLoading).toBe(false)\n        },\n        { timeout: 100 }\n      )\n    })\n\n    it('provides manual loading control', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      act(() => {\n        result.current.setIsLoading(true)\n      })\n\n      expect(result.current.isLoading).toBe(true)\n\n      act(() => {\n        result.current.setIsLoading(false)\n      })\n\n      expect(result.current.isLoading).toBe(false)\n    })\n  })", "metadata": {}}
{"id": "705", "text": "await waitFor(\n        () => {\n          expect(result.current.isLoading).toBe(false)\n        },\n        { timeout: 100 }\n      )\n    })\n\n    it('provides manual loading control', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      act(() => {\n        result.current.setIsLoading(true)\n      })\n\n      expect(result.current.isLoading).toBe(true)\n\n      act(() => {\n        result.current.setIsLoading(false)\n      })\n\n      expect(result.current.isLoading).toBe(false)\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('handles callback errors gracefully', async () => {\n      const mockCallback = vi.fn().mockRejectedValue(new Error('Load failed'))\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]", "metadata": {}}
{"id": "706", "text": "expect(result.current.isLoading).toBe(false)\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('handles callback errors gracefully', async () => {\n      const mockCallback = vi.fn().mockRejectedValue(new Error('Load failed'))\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.error).toBe('Load failed')\n        expect(result.current.isLoading).toBe(false)\n      })\n    })", "metadata": {}}
{"id": "707", "text": "const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.error).toBe('Load failed')\n        expect(result.current.isLoading).toBe(false)\n      })\n    })\n\n    it('clears error on successful callback', async () => {\n      const mockCallback = vi\n        .fn()\n        .mockRejectedValueOnce(new Error('First error'))\n        .mockResolvedValueOnce(undefined)\n\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]", "metadata": {}}
{"id": "708", "text": "it('clears error on successful callback', async () => {\n      const mockCallback = vi\n        .fn()\n        .mockRejectedValueOnce(new Error('First error'))\n        .mockResolvedValueOnce(undefined)\n\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      // First call - should fail\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.error).toBe('First error')\n      })", "metadata": {}}
{"id": "709", "text": "const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      // First call - should fail\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.error).toBe('First error')\n      })\n\n      // Second call - should succeed and clear error\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.error).toBe(null)\n      })\n    })", "metadata": {}}
{"id": "710", "text": "await waitFor(() => {\n        expect(result.current.error).toBe('First error')\n      })\n\n      // Second call - should succeed and clear error\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.error).toBe(null)\n      })\n    })\n\n    it('provides manual error control', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      act(() => {\n        result.current.setError('Manual error')\n      })\n\n      expect(result.current.error).toBe('Manual error')\n\n      act(() => {\n        result.current.setError(null)\n      })\n\n      expect(result.current.error).toBe(null)\n    })\n  })", "metadata": {}}
{"id": "711", "text": "await waitFor(() => {\n        expect(result.current.error).toBe(null)\n      })\n    })\n\n    it('provides manual error control', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      act(() => {\n        result.current.setError('Manual error')\n      })\n\n      expect(result.current.error).toBe('Manual error')\n\n      act(() => {\n        result.current.setError(null)\n      })\n\n      expect(result.current.error).toBe(null)\n    })\n  })\n\n  describe('HasNextPage Management', () => {\n    it('provides manual hasNextPage control', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      expect(result.current.hasNextPage).toBe(true)\n\n      act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      expect(result.current.hasNextPage).toBe(false)\n    })", "metadata": {}}
{"id": "712", "text": "act(() => {\n        result.current.setError(null)\n      })\n\n      expect(result.current.error).toBe(null)\n    })\n  })\n\n  describe('HasNextPage Management', () => {\n    it('provides manual hasNextPage control', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      expect(result.current.hasNextPage).toBe(true)\n\n      act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      expect(result.current.hasNextPage).toBe(false)\n    })\n\n    it('stops triggering when hasNextPage is false', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]", "metadata": {}}
{"id": "713", "text": "expect(result.current.hasNextPage).toBe(false)\n    })\n\n    it('stops triggering when hasNextPage is false', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n  })", "metadata": {}}
{"id": "714", "text": "const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n  })\n\n  describe('Manual Trigger', () => {\n    it('provides loadMore function for manual triggering', async () => {\n      const mockCallback = vi.fn().mockResolvedValue(undefined)\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      await act(async () => {\n        await result.current.loadMore()\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n    })", "metadata": {}}
{"id": "715", "text": "expect(mockCallback).not.toHaveBeenCalled()\n    })\n  })\n\n  describe('Manual Trigger', () => {\n    it('provides loadMore function for manual triggering', async () => {\n      const mockCallback = vi.fn().mockResolvedValue(undefined)\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      await act(async () => {\n        await result.current.loadMore()\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n    })\n\n    it('prevents manual trigger when loading', async () => {\n      const mockCallback = vi\n        .fn()\n        .mockImplementation(\n          () => new Promise(resolve => setTimeout(resolve, 50))\n        )\n\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      // Start loading\n      const loadPromise = act(async () => {\n        await result.current.loadMore()\n      })\n\n      // Try to trigger again while loading\n      await act(async () => {\n        await result.current.loadMore()\n      })\n\n      await loadPromise\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n    })", "metadata": {}}
{"id": "716", "text": "const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      // Start loading\n      const loadPromise = act(async () => {\n        await result.current.loadMore()\n      })\n\n      // Try to trigger again while loading\n      await act(async () => {\n        await result.current.loadMore()\n      })\n\n      await loadPromise\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n    })\n\n    it('prevents manual trigger when hasNextPage is false', async () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      await act(async () => {\n        await result.current.loadMore()\n      })\n\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n  })\n\n  describe('Cleanup and Memory Management', () => {\n    it('unobserves element when ref changes', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))", "metadata": {}}
{"id": "717", "text": "act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      await act(async () => {\n        await result.current.loadMore()\n      })\n\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n  })\n\n  describe('Cleanup and Memory Management', () => {\n    it('unobserves element when ref changes', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const firstElement = document.createElement('div')\n      const secondElement = document.createElement('div')\n\n      // Attach first element\n      act(() => {\n        result.current.triggerRef.current = firstElement\n      })\n\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(firstElement)\n\n      // Change to second element\n      act(() => {\n        result.current.triggerRef.current = secondElement\n      })\n\n      expect(mockObserverInstance.unobserve).toHaveBeenCalledWith(firstElement)\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(secondElement)\n    })", "metadata": {}}
{"id": "718", "text": "const firstElement = document.createElement('div')\n      const secondElement = document.createElement('div')\n\n      // Attach first element\n      act(() => {\n        result.current.triggerRef.current = firstElement\n      })\n\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(firstElement)\n\n      // Change to second element\n      act(() => {\n        result.current.triggerRef.current = secondElement\n      })\n\n      expect(mockObserverInstance.unobserve).toHaveBeenCalledWith(firstElement)\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(secondElement)\n    })\n\n    it('cleans up observer when ref is cleared', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const element = document.createElement('div')\n\n      act(() => {\n        result.current.triggerRef.current = element\n      })\n\n      act(() => {\n        result.current.triggerRef.current = null\n      })\n\n      expect(mockObserverInstance.unobserve).toHaveBeenCalledWith(element)\n    })", "metadata": {}}
{"id": "719", "text": "expect(mockObserverInstance.unobserve).toHaveBeenCalledWith(firstElement)\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(secondElement)\n    })\n\n    it('cleans up observer when ref is cleared', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const element = document.createElement('div')\n\n      act(() => {\n        result.current.triggerRef.current = element\n      })\n\n      act(() => {\n        result.current.triggerRef.current = null\n      })\n\n      expect(mockObserverInstance.unobserve).toHaveBeenCalledWith(element)\n    })\n\n    it('handles multiple rapid ref changes gracefully', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const elements = Array.from({ length: 5 }, () =>\n        document.createElement('div')\n      )\n\n      elements.forEach(element => {\n        act(() => {\n          result.current.triggerRef.current = element\n        })\n      })", "metadata": {}}
{"id": "720", "text": "act(() => {\n        result.current.triggerRef.current = null\n      })\n\n      expect(mockObserverInstance.unobserve).toHaveBeenCalledWith(element)\n    })\n\n    it('handles multiple rapid ref changes gracefully', () => {\n      const mockCallback = vi.fn()\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const elements = Array.from({ length: 5 }, () =>\n        document.createElement('div')\n      )\n\n      elements.forEach(element => {\n        act(() => {\n          result.current.triggerRef.current = element\n        })\n      })\n\n      // Should observe the last element\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(elements[4])\n      // Should unobserve previous elements\n      expect(mockObserverInstance.unobserve).toHaveBeenCalledTimes(4)\n    })\n  })\n\n  describe('Integration Scenarios', () => {\n    it('works with paginated data loading pattern', async () => {\n      let currentPage = 0\n      const mockCallback = vi.fn().mockImplementation(async () => {\n        currentPage++\n        return { page: currentPage, hasMore: currentPage < 3 }\n      })", "metadata": {}}
{"id": "721", "text": "// Should observe the last element\n      expect(mockObserverInstance.observe).toHaveBeenCalledWith(elements[4])\n      // Should unobserve previous elements\n      expect(mockObserverInstance.unobserve).toHaveBeenCalledTimes(4)\n    })\n  })\n\n  describe('Integration Scenarios', () => {\n    it('works with paginated data loading pattern', async () => {\n      let currentPage = 0\n      const mockCallback = vi.fn().mockImplementation(async () => {\n        currentPage++\n        return { page: currentPage, hasMore: currentPage < 3 }\n      })\n\n      const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]", "metadata": {}}
{"id": "722", "text": "const { result } = renderHook(() => useInfiniteScroll(mockCallback))\n\n      const mockTriggerElement = document.createElement('div')\n      act(() => {\n        result.current.triggerRef.current = mockTriggerElement\n      })\n\n      const intersectionCallback =\n        vi.mocked(IntersectionObserver).mock.calls[0][0]\n\n      // Load first page\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.isLoading).toBe(false)\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n\n      // Load second page\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.isLoading).toBe(false)\n      })", "metadata": {}}
{"id": "723", "text": "await waitFor(() => {\n        expect(result.current.isLoading).toBe(false)\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(1)\n\n      // Load second page\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      await waitFor(() => {\n        expect(result.current.isLoading).toBe(false)\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(2)\n\n      // Simulate no more pages\n      act(() => {\n        result.current.setHasNextPage(false)\n      })\n\n      // Should not load more\n      act(() => {\n        intersectionCallback(\n          [\n            {\n              isIntersecting: true,\n              target: mockTriggerElement,\n            },\n          ] as IntersectionObserverEntry[],\n          mockObserverInstance as any\n        )\n      })\n\n      expect(mockCallback).toHaveBeenCalledTimes(2)\n    })\n  })\n})", "metadata": {}}
{"id": "724", "text": "/**\n * useRetry Hook Tests\n * Tests the retry functionality with exponential backoff\n */\n\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { renderHook, act } from '@testing-library/react'\nimport { useRetry } from '../../src/hooks/useRetry'\n\ndescribe('useRetry', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n  })\n\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  describe('Successful execution', () => {\n    it('executes function successfully on first try', async () => {\n      const { result } = renderHook(() => useRetry())\n      const mockFn = vi.fn().mockResolvedValue('success')\n\n      const executePromise = act(async () => {\n        return result.current.execute(mockFn)\n      })\n\n      const response = await executePromise\n\n      expect(response).toBe('success')\n      expect(mockFn).toHaveBeenCalledTimes(1)\n      expect(result.current.retrying).toBe(false)\n      expect(result.current.retryCount).toBe(0)\n      expect(result.current.lastError).toBe(null)\n    })\n  })", "metadata": {}}
{"id": "725", "text": "const executePromise = act(async () => {\n        return result.current.execute(mockFn)\n      })\n\n      const response = await executePromise\n\n      expect(response).toBe('success')\n      expect(mockFn).toHaveBeenCalledTimes(1)\n      expect(result.current.retrying).toBe(false)\n      expect(result.current.retryCount).toBe(0)\n      expect(result.current.lastError).toBe(null)\n    })\n  })\n\n  describe('Retry behavior', () => {\n    it('retries failed operations', async () => {\n      const { result } = renderHook(() => useRetry({\n        maxRetries: 2,\n        initialDelay: 10, // Very short delay for testing\n        backoffFactor: 1.1\n      }))\n\n      const mockFn = vi.fn()\n        .mockRejectedValueOnce(new Error('network error'))\n        .mockRejectedValueOnce(new Error('network error'))\n        .mockResolvedValueOnce('success')\n\n      const response = await act(async () => {\n        return result.current.execute(mockFn)\n      })", "metadata": {}}
{"id": "726", "text": "const mockFn = vi.fn()\n        .mockRejectedValueOnce(new Error('network error'))\n        .mockRejectedValueOnce(new Error('network error'))\n        .mockResolvedValueOnce('success')\n\n      const response = await act(async () => {\n        return result.current.execute(mockFn)\n      })\n\n      expect(response).toBe('success')\n      expect(mockFn).toHaveBeenCalledTimes(3)\n      expect(result.current.retrying).toBe(false)\n    })\n\n    it('respects maxRetries limit', async () => {\n      const { result } = renderHook(() => useRetry({\n        maxRetries: 1,\n        initialDelay: 10\n      }))\n      const mockError = new Error('persistent network error')\n      const mockFn = vi.fn().mockRejectedValue(mockError)\n\n      let caughtError: Error | null = null\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        caughtError = error as Error\n      }", "metadata": {}}
{"id": "727", "text": "it('respects maxRetries limit', async () => {\n      const { result } = renderHook(() => useRetry({\n        maxRetries: 1,\n        initialDelay: 10\n      }))\n      const mockError = new Error('persistent network error')\n      const mockFn = vi.fn().mockRejectedValue(mockError)\n\n      let caughtError: Error | null = null\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        caughtError = error as Error\n      }\n\n      expect(caughtError).toBe(mockError)\n      expect(mockFn).toHaveBeenCalledTimes(2) // Initial + 1 retry\n      expect(result.current.retrying).toBe(false)\n      expect(result.current.lastError).toBeTruthy()\n    })\n  })", "metadata": {}}
{"id": "728", "text": "let caughtError: Error | null = null\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        caughtError = error as Error\n      }\n\n      expect(caughtError).toBe(mockError)\n      expect(mockFn).toHaveBeenCalledTimes(2) // Initial + 1 retry\n      expect(result.current.retrying).toBe(false)\n      expect(result.current.lastError).toBeTruthy()\n    })\n  })\n\n  describe('Retry conditions', () => {\n    it('respects custom retry conditions', async () => {\n      const { result } = renderHook(() => useRetry({\n        maxRetries: 2,\n        initialDelay: 10,\n        retryCondition: (error) => error.message.includes('retryable')\n      }))\n\n      const nonRetryableError = new Error('validation error')\n      const mockFn = vi.fn().mockRejectedValue(nonRetryableError)\n\n      let caughtError: Error | null = null", "metadata": {}}
{"id": "729", "text": "describe('Retry conditions', () => {\n    it('respects custom retry conditions', async () => {\n      const { result } = renderHook(() => useRetry({\n        maxRetries: 2,\n        initialDelay: 10,\n        retryCondition: (error) => error.message.includes('retryable')\n      }))\n\n      const nonRetryableError = new Error('validation error')\n      const mockFn = vi.fn().mockRejectedValue(nonRetryableError)\n\n      let caughtError: Error | null = null\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        caughtError = error as Error\n      }\n\n      expect(caughtError).toBe(nonRetryableError)\n      expect(mockFn).toHaveBeenCalledTimes(1) // No retries due to condition\n      expect(result.current.retrying).toBe(false)\n    })\n  })", "metadata": {}}
{"id": "730", "text": "const nonRetryableError = new Error('validation error')\n      const mockFn = vi.fn().mockRejectedValue(nonRetryableError)\n\n      let caughtError: Error | null = null\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        caughtError = error as Error\n      }\n\n      expect(caughtError).toBe(nonRetryableError)\n      expect(mockFn).toHaveBeenCalledTimes(1) // No retries due to condition\n      expect(result.current.retrying).toBe(false)\n    })\n  })\n\n  describe('Reset functionality', () => {\n    it('resets retry state', async () => {\n      const { result } = renderHook(() => useRetry({\n        maxRetries: 0,\n        initialDelay: 10\n      }))\n      const mockError = new Error('network error')\n      const mockFn = vi.fn().mockRejectedValue(mockError)\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        // Expected to fail\n      }", "metadata": {}}
{"id": "731", "text": "describe('Reset functionality', () => {\n    it('resets retry state', async () => {\n      const { result } = renderHook(() => useRetry({\n        maxRetries: 0,\n        initialDelay: 10\n      }))\n      const mockError = new Error('network error')\n      const mockFn = vi.fn().mockRejectedValue(mockError)\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        // Expected to fail\n      }\n\n      expect(result.current.lastError).toBeTruthy()\n\n      act(() => {\n        result.current.reset()\n      })\n\n      expect(result.current.retrying).toBe(false)\n      expect(result.current.retryCount).toBe(0)\n      expect(result.current.lastError).toBe(null)\n    })\n  })", "metadata": {}}
{"id": "732", "text": "try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        // Expected to fail\n      }\n\n      expect(result.current.lastError).toBeTruthy()\n\n      act(() => {\n        result.current.reset()\n      })\n\n      expect(result.current.retrying).toBe(false)\n      expect(result.current.retryCount).toBe(0)\n      expect(result.current.lastError).toBe(null)\n    })\n  })\n\n  describe('Error handling', () => {\n    it('preserves original error types', async () => {\n      const { result } = renderHook(() => useRetry({ maxRetries: 0, initialDelay: 10 }))\n      const customError = new TypeError('Custom error type')\n      const mockFn = vi.fn().mockRejectedValue(customError)\n\n      let caughtError: Error | null = null\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        caughtError = error as Error\n      }", "metadata": {}}
{"id": "733", "text": "describe('Error handling', () => {\n    it('preserves original error types', async () => {\n      const { result } = renderHook(() => useRetry({ maxRetries: 0, initialDelay: 10 }))\n      const customError = new TypeError('Custom error type')\n      const mockFn = vi.fn().mockRejectedValue(customError)\n\n      let caughtError: Error | null = null\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        caughtError = error as Error\n      }\n\n      expect(caughtError).toBeInstanceOf(TypeError)\n      expect(caughtError?.message).toBe('Custom error type')\n    })\n\n    it('handles non-Error objects', async () => {\n      const { result } = renderHook(() => useRetry({ maxRetries: 0, initialDelay: 10 }))\n      const mockFn = vi.fn().mockRejectedValue('string error')\n\n      let caughtError: Error | null = null", "metadata": {}}
{"id": "734", "text": "expect(caughtError).toBeInstanceOf(TypeError)\n      expect(caughtError?.message).toBe('Custom error type')\n    })\n\n    it('handles non-Error objects', async () => {\n      const { result } = renderHook(() => useRetry({ maxRetries: 0, initialDelay: 10 }))\n      const mockFn = vi.fn().mockRejectedValue('string error')\n\n      let caughtError: Error | null = null\n\n      try {\n        await act(async () => {\n          await result.current.execute(mockFn)\n        })\n      } catch (error) {\n        caughtError = error as Error\n      }\n\n      expect(caughtError).toBeInstanceOf(Error)\n      expect(caughtError?.message).toBe('Unknown error')\n    })\n  })\n})", "metadata": {}}
{"id": "735", "text": "import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { ImageGallery } from '../../src/components/ImageGallery/ImageGallery';\nimport { ImageDetailModal } from '../../src/components/ImageDetailModal/ImageDetailModal';\nimport { useImageDetail } from '../../src/hooks/useImageDetail';\nimport { createTestImage } from '../utils/test-utils';\n\n// Mock the hooks\nvi.mock('../../src/hooks/useImageDetail');\nvi.mock('../../src/hooks/useGallery');\n\nconst mockImages = [\n  createTestImage({ id: '1', filename: 'image1.jpg', caption: 'First image' }),\n  createTestImage({ id: '2', filename: 'image2.jpg', caption: 'Second image' }),\n  createTestImage({ id: '3', filename: 'image3.jpg', caption: 'Third image' }),\n];\n\ndescribe('Image Detail Flow Integration Test', () => {\n  beforeEach(() => {\n    // Reset mocks\n    vi.clearAllMocks();", "metadata": {}}
{"id": "736", "text": "const mockImages = [\n  createTestImage({ id: '1', filename: 'image1.jpg', caption: 'First image' }),\n  createTestImage({ id: '2', filename: 'image2.jpg', caption: 'Second image' }),\n  createTestImage({ id: '3', filename: 'image3.jpg', caption: 'Third image' }),\n];\n\ndescribe('Image Detail Flow Integration Test', () => {\n  beforeEach(() => {\n    // Reset mocks\n    vi.clearAllMocks();\n\n    // Mock gallery hook\n    const mockUseGallery = vi.fn().mockReturnValue({\n      images: mockImages,\n      loading: false,\n      error: null,\n    });\n    require('../../src/hooks/useGallery').useGallery = mockUseGallery;\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });", "metadata": {}}
{"id": "737", "text": "describe('Image Detail Flow Integration Test', () => {\n  beforeEach(() => {\n    // Reset mocks\n    vi.clearAllMocks();\n\n    // Mock gallery hook\n    const mockUseGallery = vi.fn().mockReturnValue({\n      images: mockImages,\n      loading: false,\n      error: null,\n    });\n    require('../../src/hooks/useGallery').useGallery = mockUseGallery;\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it('should open detail modal when clicking on an image', async () => {\n    const mockOpenDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: false,\n      openDetail: mockOpenDetail,\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageGallery />);\n\n    // Click on first image\n    const firstImage = screen.getByAltText(mockImages[0].caption || 'Image');\n    await userEvent.click(firstImage);", "metadata": {}}
{"id": "738", "text": "render(<ImageGallery />);\n\n    // Click on first image\n    const firstImage = screen.getByAltText(mockImages[0].caption || 'Image');\n    await userEvent.click(firstImage);\n\n    expect(mockOpenDetail).toHaveBeenCalledWith(mockImages[0].id);\n  });\n\n  it('should display correct image details in modal', async () => {\n    const mockCloseDetail = vi.fn();\n    const selectedImage = mockImages[0];\n\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Verify image is displayed\n    const image = screen.getByAltText(selectedImage.caption || 'Image detail');\n    expect(image).toBeInTheDocument();", "metadata": {}}
{"id": "739", "text": "const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Verify image is displayed\n    const image = screen.getByAltText(selectedImage.caption || 'Image detail');\n    expect(image).toBeInTheDocument();\n\n    // Verify metadata is displayed\n    expect(screen.getByText(selectedImage.filename)).toBeInTheDocument();\n    expect(screen.getByText(/Uploaded by:/)).toBeInTheDocument();\n    expect(screen.getByText(/Uploaded at:/)).toBeInTheDocument();\n  });\n\n  it('should fetch full image data when opening detail view', async () => {\n    const mockOpenDetail = vi.fn();\n    const mockFetchImageDetails = vi.fn().mockResolvedValue(mockImages[0]);", "metadata": {}}
{"id": "740", "text": "// Verify image is displayed\n    const image = screen.getByAltText(selectedImage.caption || 'Image detail');\n    expect(image).toBeInTheDocument();\n\n    // Verify metadata is displayed\n    expect(screen.getByText(selectedImage.filename)).toBeInTheDocument();\n    expect(screen.getByText(/Uploaded by:/)).toBeInTheDocument();\n    expect(screen.getByText(/Uploaded at:/)).toBeInTheDocument();\n  });\n\n  it('should fetch full image data when opening detail view', async () => {\n    const mockOpenDetail = vi.fn();\n    const mockFetchImageDetails = vi.fn().mockResolvedValue(mockImages[0]);\n\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: false,\n      openDetail: mockOpenDetail,\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n      fetchImageDetails: mockFetchImageDetails,\n    });\n\n    render(<ImageGallery />);", "metadata": {}}
{"id": "741", "text": "it('should fetch full image data when opening detail view', async () => {\n    const mockOpenDetail = vi.fn();\n    const mockFetchImageDetails = vi.fn().mockResolvedValue(mockImages[0]);\n\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: false,\n      openDetail: mockOpenDetail,\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n      fetchImageDetails: mockFetchImageDetails,\n    });\n\n    render(<ImageGallery />);\n\n    // Click on image\n    const firstImage = screen.getByAltText(mockImages[0].caption || 'Image');\n    await userEvent.click(firstImage);\n\n    // Verify fetch was called\n    await waitFor(() => {\n      expect(mockFetchImageDetails).toHaveBeenCalledWith(mockImages[0].id);\n    });\n  });", "metadata": {}}
{"id": "742", "text": "render(<ImageGallery />);\n\n    // Click on image\n    const firstImage = screen.getByAltText(mockImages[0].caption || 'Image');\n    await userEvent.click(firstImage);\n\n    // Verify fetch was called\n    await waitFor(() => {\n      expect(mockFetchImageDetails).toHaveBeenCalledWith(mockImages[0].id);\n    });\n  });\n\n  it('should show loading state while fetching image details', async () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: true,\n      loading: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    expect(screen.getByText(/Loading image details.../)).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "743", "text": "it('should show loading state while fetching image details', async () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: true,\n      loading: true,\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    expect(screen.getByText(/Loading image details.../)).toBeInTheDocument();\n  });\n\n  it('should show error state when image fetch fails', async () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: true,\n      error: 'Failed to load image',\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    expect(screen.getByText(/Failed to load image/)).toBeInTheDocument();\n  });", "metadata": {}}
{"id": "744", "text": "it('should show error state when image fetch fails', async () => {\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: true,\n      error: 'Failed to load image',\n      openDetail: vi.fn(),\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    expect(screen.getByText(/Failed to load image/)).toBeInTheDocument();\n  });\n\n  it('should maintain gallery state when modal opens', async () => {\n    const mockOpenDetail = vi.fn();\n    const mockUseGallery = require('../../src/hooks/useGallery').useGallery;\n    mockUseGallery.mockReturnValue({\n      images: mockImages,\n      loading: false,\n      error: null,\n    });", "metadata": {}}
{"id": "745", "text": "render(<ImageDetailModal />);\n\n    expect(screen.getByText(/Failed to load image/)).toBeInTheDocument();\n  });\n\n  it('should maintain gallery state when modal opens', async () => {\n    const mockOpenDetail = vi.fn();\n    const mockUseGallery = require('../../src/hooks/useGallery').useGallery;\n    mockUseGallery.mockReturnValue({\n      images: mockImages,\n      loading: false,\n      error: null,\n    });\n\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: null,\n      isDetailOpen: false,\n      openDetail: mockOpenDetail,\n      closeDetail: vi.fn(),\n      updateImage: vi.fn(),\n    });\n\n    const { container } = render(<ImageGallery />);\n\n    // Gallery should show all images\n    const images = container.querySelectorAll('img');\n    expect(images).toHaveLength(mockImages.length);\n\n    // Click on first image\n    const firstImage = screen.getByAltText(mockImages[0].caption || 'Image');\n    await userEvent.click(firstImage);", "metadata": {}}
{"id": "746", "text": "const { container } = render(<ImageGallery />);\n\n    // Gallery should show all images\n    const images = container.querySelectorAll('img');\n    expect(images).toHaveLength(mockImages.length);\n\n    // Click on first image\n    const firstImage = screen.getByAltText(mockImages[0].caption || 'Image');\n    await userEvent.click(firstImage);\n\n    // Gallery should still be visible in background\n    expect(container.querySelector('.gallery-container')).toBeInTheDocument();\n  });\n});", "metadata": {}}
{"id": "747", "text": "import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { ImageDetailModal } from '../../src/components/ImageDetailModal/ImageDetailModal';\nimport { useImageDetail } from '../../src/hooks/useImageDetail';\nimport { createTestImage } from '../utils/test-utils';\n\n// Mock the hook\nvi.mock('../../src/hooks/useImageDetail');\n\nconst mockImage = createTestImage({ id: '1', filename: 'test.jpg', caption: 'Test image' });\n\ndescribe('Modal Close Methods Integration Test', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });", "metadata": {}}
{"id": "748", "text": "// Mock the hook\nvi.mock('../../src/hooks/useImageDetail');\n\nconst mockImage = createTestImage({ id: '1', filename: 'test.jpg', caption: 'Test image' });\n\ndescribe('Modal Close Methods Integration Test', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it('should close modal when clicking close button', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Find and click close button\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    await userEvent.click(closeButton);\n\n    expect(mockCloseDetail).toHaveBeenCalled();\n  });", "metadata": {}}
{"id": "749", "text": "render(<ImageDetailModal />);\n\n    // Find and click close button\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    await userEvent.click(closeButton);\n\n    expect(mockCloseDetail).toHaveBeenCalled();\n  });\n\n  it('should close modal when pressing Escape key', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Press Escape key\n    await userEvent.keyboard('{Escape}');\n\n    expect(mockCloseDetail).toHaveBeenCalled();\n  });", "metadata": {}}
{"id": "750", "text": "it('should close modal when pressing Escape key', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Press Escape key\n    await userEvent.keyboard('{Escape}');\n\n    expect(mockCloseDetail).toHaveBeenCalled();\n  });\n\n  it('should close modal when clicking outside the modal content', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    const { container } = render(<ImageDetailModal />);", "metadata": {}}
{"id": "751", "text": "expect(mockCloseDetail).toHaveBeenCalled();\n  });\n\n  it('should close modal when clicking outside the modal content', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    const { container } = render(<ImageDetailModal />);\n\n    // Click on backdrop (outside modal content)\n    const backdrop = container.querySelector('[role=\"dialog\"]')?.parentElement;\n    if (backdrop) {\n      await userEvent.click(backdrop);\n      expect(mockCloseDetail).toHaveBeenCalled();\n    }\n  });", "metadata": {}}
{"id": "752", "text": "const { container } = render(<ImageDetailModal />);\n\n    // Click on backdrop (outside modal content)\n    const backdrop = container.querySelector('[role=\"dialog\"]')?.parentElement;\n    if (backdrop) {\n      await userEvent.click(backdrop);\n      expect(mockCloseDetail).toHaveBeenCalled();\n    }\n  });\n\n  it('should NOT close modal when clicking inside modal content', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Click on image inside modal\n    const image = screen.getByAltText(mockImage.caption || 'Image detail');\n    await userEvent.click(image);\n\n    expect(mockCloseDetail).not.toHaveBeenCalled();\n  });", "metadata": {}}
{"id": "753", "text": "render(<ImageDetailModal />);\n\n    // Click on image inside modal\n    const image = screen.getByAltText(mockImage.caption || 'Image detail');\n    await userEvent.click(image);\n\n    expect(mockCloseDetail).not.toHaveBeenCalled();\n  });\n\n  it('should cleanup state when modal closes', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n\n    // Simulate state cleanup after close\n    mockUseImageDetail\n      .mockReturnValueOnce({\n        selectedImage: mockImage,\n        isDetailOpen: true,\n        openDetail: vi.fn(),\n        closeDetail: mockCloseDetail,\n        updateImage: vi.fn(),\n      })\n      .mockReturnValueOnce({\n        selectedImage: null,\n        isDetailOpen: false,\n        openDetail: vi.fn(),\n        closeDetail: mockCloseDetail,\n        updateImage: vi.fn(),\n      });\n\n    const { rerender } = render(<ImageDetailModal />);", "metadata": {}}
{"id": "754", "text": "// Simulate state cleanup after close\n    mockUseImageDetail\n      .mockReturnValueOnce({\n        selectedImage: mockImage,\n        isDetailOpen: true,\n        openDetail: vi.fn(),\n        closeDetail: mockCloseDetail,\n        updateImage: vi.fn(),\n      })\n      .mockReturnValueOnce({\n        selectedImage: null,\n        isDetailOpen: false,\n        openDetail: vi.fn(),\n        closeDetail: mockCloseDetail,\n        updateImage: vi.fn(),\n      });\n\n    const { rerender } = render(<ImageDetailModal />);\n\n    // Close modal\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    await userEvent.click(closeButton);\n\n    // Re-render with updated state\n    rerender(<ImageDetailModal />);\n\n    // Modal should not be in DOM or be hidden\n    expect(screen.queryByRole('dialog')).not.toBeInTheDocument();\n  });", "metadata": {}}
{"id": "755", "text": "const { rerender } = render(<ImageDetailModal />);\n\n    // Close modal\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    await userEvent.click(closeButton);\n\n    // Re-render with updated state\n    rerender(<ImageDetailModal />);\n\n    // Modal should not be in DOM or be hidden\n    expect(screen.queryByRole('dialog')).not.toBeInTheDocument();\n  });\n\n  it('should handle multiple close method calls gracefully', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);", "metadata": {}}
{"id": "756", "text": "// Modal should not be in DOM or be hidden\n    expect(screen.queryByRole('dialog')).not.toBeInTheDocument();\n  });\n\n  it('should handle multiple close method calls gracefully', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Close modal multiple times\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    await userEvent.click(closeButton);\n    await userEvent.click(closeButton);\n    await userEvent.keyboard('{Escape}');\n\n    // Should only be called once per state change\n    expect(mockCloseDetail).toHaveBeenCalledTimes(1);\n  });", "metadata": {}}
{"id": "757", "text": "render(<ImageDetailModal />);\n\n    // Close modal multiple times\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    await userEvent.click(closeButton);\n    await userEvent.click(closeButton);\n    await userEvent.keyboard('{Escape}');\n\n    // Should only be called once per state change\n    expect(mockCloseDetail).toHaveBeenCalledTimes(1);\n  });\n\n  it('should close modal and return focus to gallery', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Mock focus management\n    const mockFocus = vi.fn();\n    HTMLElement.prototype.focus = mockFocus;", "metadata": {}}
{"id": "758", "text": "it('should close modal and return focus to gallery', async () => {\n    const mockCloseDetail = vi.fn();\n    const mockUseImageDetail = useImageDetail as ReturnType<typeof vi.fn>;\n    mockUseImageDetail.mockReturnValue({\n      selectedImage: mockImage,\n      isDetailOpen: true,\n      openDetail: vi.fn(),\n      closeDetail: mockCloseDetail,\n      updateImage: vi.fn(),\n    });\n\n    render(<ImageDetailModal />);\n\n    // Mock focus management\n    const mockFocus = vi.fn();\n    HTMLElement.prototype.focus = mockFocus;\n\n    // Close modal\n    const closeButton = screen.getByRole('button', { name: /close|✕/i });\n    await userEvent.click(closeButton);\n\n    // Check if close was called\n    expect(mockCloseDetail).toHaveBeenCalled();\n  });\n});", "metadata": {}}
{"id": "759", "text": "/**\n * MockDataService Tests\n * Tests the mock data service implementation following TDD approach\n */\n\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { MockDataService } from '../../src/services/MockDataService'\nimport { Album, Photo, UploadSession, PhotoService } from '../../src/types'\nimport { waitForNextTick, createMockFile, createMockFileList } from '../utils'\n\ndescribe('MockDataService', () => {\n  let service: PhotoService\n  let mockFiles: File[]\n\n  beforeEach(() => {\n    service = new MockDataService()\n    mockFiles = [\n      createMockFile('photo1.jpg', 'image/jpeg', 2048000),\n      createMockFile('photo2.png', 'image/png', 1536000),\n      createMockFile('photo3.jpg', 'image/jpeg', 3072000),\n    ]\n    vi.clearAllMocks()\n  })\n\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })", "metadata": {}}
{"id": "760", "text": "describe('MockDataService', () => {\n  let service: PhotoService\n  let mockFiles: File[]\n\n  beforeEach(() => {\n    service = new MockDataService()\n    mockFiles = [\n      createMockFile('photo1.jpg', 'image/jpeg', 2048000),\n      createMockFile('photo2.png', 'image/png', 1536000),\n      createMockFile('photo3.jpg', 'image/jpeg', 3072000),\n    ]\n    vi.clearAllMocks()\n  })\n\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  describe('Service Initialization', () => {\n    it('creates service instance successfully', () => {\n      expect(service).toBeDefined()\n      expect(service).toBeInstanceOf(MockDataService)\n    })", "metadata": {}}
{"id": "761", "text": "afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  describe('Service Initialization', () => {\n    it('creates service instance successfully', () => {\n      expect(service).toBeDefined()\n      expect(service).toBeInstanceOf(MockDataService)\n    })\n\n    it('implements PhotoService interface', () => {\n      expect(service.uploadPhotos).toBeDefined()\n      expect(service.getAllAlbums).toBeDefined()\n      expect(service.getPhotosInAlbum).toBeDefined()\n      expect(service.getFullPhoto).toBeDefined()\n      expect(service.updateAlbumOrder).toBeDefined()\n      expect(service.exportAlbumAsZip).toBeDefined()\n      expect(service.deletePhoto).toBeDefined()\n      expect(service.deleteAlbum).toBeDefined()\n    })\n\n    it('starts with empty state', async () => {\n      const albums = await service.getAllAlbums()\n      expect(albums).toEqual([])\n    })\n  })\n\n  describe('Album Management', () => {\n    it('returns empty array when no albums exist', async () => {\n      const albums = await service.getAllAlbums()\n\n      expect(albums).toEqual([])\n      expect(Array.isArray(albums)).toBe(true)\n    })", "metadata": {}}
{"id": "762", "text": "it('starts with empty state', async () => {\n      const albums = await service.getAllAlbums()\n      expect(albums).toEqual([])\n    })\n  })\n\n  describe('Album Management', () => {\n    it('returns empty array when no albums exist', async () => {\n      const albums = await service.getAllAlbums()\n\n      expect(albums).toEqual([])\n      expect(Array.isArray(albums)).toBe(true)\n    })\n\n    it('returns albums ordered by display order', async () => {\n      // Upload files to create albums\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n\n      expect(albums.length).toBeGreaterThan(0)\n      expect(albums[0].displayOrder).toBeLessThanOrEqual(albums[albums.length - 1].displayOrder)\n    })\n\n    it('includes correct album metadata', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 1))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]", "metadata": {}}
{"id": "763", "text": "const albums = await service.getAllAlbums()\n\n      expect(albums.length).toBeGreaterThan(0)\n      expect(albums[0].displayOrder).toBeLessThanOrEqual(albums[albums.length - 1].displayOrder)\n    })\n\n    it('includes correct album metadata', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 1))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n\n      expect(album).toMatchObject({\n        id: expect.any(Number),\n        name: expect.any(String),\n        captureDate: expect.any(Date),\n        displayOrder: expect.any(Number),\n        thumbnailPhotoId: expect.any(Number),\n        photoCount: expect.any(Number),\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date),\n      })\n    })\n\n    it('updates album order correctly', async () => {\n      // Create multiple albums\n      await service.uploadPhotos([mockFiles[0]])\n      await service.uploadPhotos([mockFiles[1]])\n      await waitForNextTick()", "metadata": {}}
{"id": "764", "text": "expect(album).toMatchObject({\n        id: expect.any(Number),\n        name: expect.any(String),\n        captureDate: expect.any(Date),\n        displayOrder: expect.any(Number),\n        thumbnailPhotoId: expect.any(Number),\n        photoCount: expect.any(Number),\n        createdAt: expect.any(Date),\n        updatedAt: expect.any(Date),\n      })\n    })\n\n    it('updates album order correctly', async () => {\n      // Create multiple albums\n      await service.uploadPhotos([mockFiles[0]])\n      await service.uploadPhotos([mockFiles[1]])\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const firstAlbum = albums[0]\n      const originalOrder = firstAlbum.displayOrder\n\n      await service.updateAlbumOrder(firstAlbum.id, originalOrder + 10)\n\n      const updatedAlbums = await service.getAllAlbums()\n      const updatedAlbum = updatedAlbums.find(a => a.id === firstAlbum.id)\n\n      expect(updatedAlbum?.displayOrder).toBe(originalOrder + 10)\n    })", "metadata": {}}
{"id": "765", "text": "const albums = await service.getAllAlbums()\n      const firstAlbum = albums[0]\n      const originalOrder = firstAlbum.displayOrder\n\n      await service.updateAlbumOrder(firstAlbum.id, originalOrder + 10)\n\n      const updatedAlbums = await service.getAllAlbums()\n      const updatedAlbum = updatedAlbums.find(a => a.id === firstAlbum.id)\n\n      expect(updatedAlbum?.displayOrder).toBe(originalOrder + 10)\n    })\n\n    it('handles invalid album ID in updateAlbumOrder gracefully', async () => {\n      await expect(service.updateAlbumOrder(999, 1)).resolves.not.toThrow()\n    })\n\n    it('deletes album and all its photos', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const albumToDelete = albums[0]\n      const photosBeforeDelete = await service.getPhotosInAlbum(albumToDelete.id)\n\n      expect(photosBeforeDelete.length).toBeGreaterThan(0)\n\n      await service.deleteAlbum(albumToDelete.id)", "metadata": {}}
{"id": "766", "text": "it('deletes album and all its photos', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const albumToDelete = albums[0]\n      const photosBeforeDelete = await service.getPhotosInAlbum(albumToDelete.id)\n\n      expect(photosBeforeDelete.length).toBeGreaterThan(0)\n\n      await service.deleteAlbum(albumToDelete.id)\n\n      const remainingAlbums = await service.getAllAlbums()\n      const deletedAlbumExists = remainingAlbums.find(a => a.id === albumToDelete.id)\n\n      expect(deletedAlbumExists).toBeUndefined()\n    })\n\n    it('handles deletion of non-existent album gracefully', async () => {\n      await expect(service.deleteAlbum(999)).resolves.not.toThrow()\n    })\n  })\n\n  describe('Photo Management', () => {\n    it('returns empty array for non-existent album', async () => {\n      const photos = await service.getPhotosInAlbum(999)\n\n      expect(photos).toEqual([])\n      expect(Array.isArray(photos)).toBe(true)\n    })", "metadata": {}}
{"id": "767", "text": "expect(deletedAlbumExists).toBeUndefined()\n    })\n\n    it('handles deletion of non-existent album gracefully', async () => {\n      await expect(service.deleteAlbum(999)).resolves.not.toThrow()\n    })\n  })\n\n  describe('Photo Management', () => {\n    it('returns empty array for non-existent album', async () => {\n      const photos = await service.getPhotosInAlbum(999)\n\n      expect(photos).toEqual([])\n      expect(Array.isArray(photos)).toBe(true)\n    })\n\n    it('returns photos for existing album', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const photos = await service.getPhotosInAlbum(album.id)", "metadata": {}}
{"id": "768", "text": "describe('Photo Management', () => {\n    it('returns empty array for non-existent album', async () => {\n      const photos = await service.getPhotosInAlbum(999)\n\n      expect(photos).toEqual([])\n      expect(Array.isArray(photos)).toBe(true)\n    })\n\n    it('returns photos for existing album', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const photos = await service.getPhotosInAlbum(album.id)\n\n      expect(photos.length).toBeGreaterThan(0)\n      expect(photos[0]).toMatchObject({\n        id: expect.any(Number),\n        filename: expect.any(String),\n        albumId: album.id,\n        fileData: expect.any(Blob),\n        thumbnailData: expect.any(Blob),\n        captureDate: expect.any(Date),\n        fileSize: expect.any(Number),\n        width: expect.any(Number),\n        height: expect.any(Number),\n        uploadTimestamp: expect.any(Date),\n      })\n    })", "metadata": {}}
{"id": "769", "text": "expect(photos.length).toBeGreaterThan(0)\n      expect(photos[0]).toMatchObject({\n        id: expect.any(Number),\n        filename: expect.any(String),\n        albumId: album.id,\n        fileData: expect.any(Blob),\n        thumbnailData: expect.any(Blob),\n        captureDate: expect.any(Date),\n        fileSize: expect.any(Number),\n        width: expect.any(Number),\n        height: expect.any(Number),\n        uploadTimestamp: expect.any(Date),\n      })\n    })\n\n    it('retrieves full photo data by ID', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 1))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const photos = await service.getPhotosInAlbum(albums[0].id)\n      const photoId = photos[0].id\n\n      const fullPhoto = await service.getFullPhoto(photoId)", "metadata": {}}
{"id": "770", "text": "it('retrieves full photo data by ID', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 1))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const photos = await service.getPhotosInAlbum(albums[0].id)\n      const photoId = photos[0].id\n\n      const fullPhoto = await service.getFullPhoto(photoId)\n\n      expect(fullPhoto).toMatchObject({\n        id: photoId,\n        filename: expect.any(String),\n        albumId: expect.any(Number),\n        fileData: expect.any(Blob),\n        thumbnailData: expect.any(Blob),\n      })\n    })\n\n    it('throws error for non-existent photo ID', async () => {\n      await expect(service.getFullPhoto(999)).rejects.toThrow('Photo not found')\n    })\n\n    it('deletes photo and updates album photo count', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()", "metadata": {}}
{"id": "771", "text": "expect(fullPhoto).toMatchObject({\n        id: photoId,\n        filename: expect.any(String),\n        albumId: expect.any(Number),\n        fileData: expect.any(Blob),\n        thumbnailData: expect.any(Blob),\n      })\n    })\n\n    it('throws error for non-existent photo ID', async () => {\n      await expect(service.getFullPhoto(999)).rejects.toThrow('Photo not found')\n    })\n\n    it('deletes photo and updates album photo count', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const photos = await service.getPhotosInAlbum(album.id)\n      const photoToDelete = photos[0]\n      const initialPhotoCount = album.photoCount\n\n      await service.deletePhoto(photoToDelete.id)\n\n      const updatedPhotos = await service.getPhotosInAlbum(album.id)\n      const updatedAlbums = await service.getAllAlbums()\n      const updatedAlbum = updatedAlbums.find(a => a.id === album.id)", "metadata": {}}
{"id": "772", "text": "const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const photos = await service.getPhotosInAlbum(album.id)\n      const photoToDelete = photos[0]\n      const initialPhotoCount = album.photoCount\n\n      await service.deletePhoto(photoToDelete.id)\n\n      const updatedPhotos = await service.getPhotosInAlbum(album.id)\n      const updatedAlbums = await service.getAllAlbums()\n      const updatedAlbum = updatedAlbums.find(a => a.id === album.id)\n\n      expect(updatedPhotos.length).toBe(photos.length - 1)\n      expect(updatedAlbum?.photoCount).toBe(initialPhotoCount - 1)\n    })\n\n    it('handles deletion of non-existent photo gracefully', async () => {\n      await expect(service.deletePhoto(999)).resolves.not.toThrow()\n    })\n\n    it('removes empty albums after deleting all photos', async () => {\n      await service.uploadPhotos([mockFiles[0]]) // Single photo album\n      await waitForNextTick()", "metadata": {}}
{"id": "773", "text": "expect(updatedPhotos.length).toBe(photos.length - 1)\n      expect(updatedAlbum?.photoCount).toBe(initialPhotoCount - 1)\n    })\n\n    it('handles deletion of non-existent photo gracefully', async () => {\n      await expect(service.deletePhoto(999)).resolves.not.toThrow()\n    })\n\n    it('removes empty albums after deleting all photos', async () => {\n      await service.uploadPhotos([mockFiles[0]]) // Single photo album\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const photos = await service.getPhotosInAlbum(album.id)\n\n      expect(photos.length).toBe(1)\n\n      await service.deletePhoto(photos[0].id)\n\n      const remainingAlbums = await service.getAllAlbums()\n      const deletedAlbum = remainingAlbums.find(a => a.id === album.id)\n\n      expect(deletedAlbum).toBeUndefined()\n    })\n  })", "metadata": {}}
{"id": "774", "text": "const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const photos = await service.getPhotosInAlbum(album.id)\n\n      expect(photos.length).toBe(1)\n\n      await service.deletePhoto(photos[0].id)\n\n      const remainingAlbums = await service.getAllAlbums()\n      const deletedAlbum = remainingAlbums.find(a => a.id === album.id)\n\n      expect(deletedAlbum).toBeUndefined()\n    })\n  })\n\n  describe('Photo Upload', () => {\n    it('uploads photos and creates upload session', async () => {\n      const session = await service.uploadPhotos(mockFiles)\n\n      expect(session).toMatchObject({\n        id: expect.any(String),\n        status: 'processing',\n        totalFiles: mockFiles.length,\n        processedFiles: 0,\n        errorCount: 0,\n        startedAt: expect.any(Date),\n        completedAt: null,\n      })\n    })\n\n    it('handles empty file list gracefully', async () => {\n      const session = await service.uploadPhotos([])", "metadata": {}}
{"id": "775", "text": "describe('Photo Upload', () => {\n    it('uploads photos and creates upload session', async () => {\n      const session = await service.uploadPhotos(mockFiles)\n\n      expect(session).toMatchObject({\n        id: expect.any(String),\n        status: 'processing',\n        totalFiles: mockFiles.length,\n        processedFiles: 0,\n        errorCount: 0,\n        startedAt: expect.any(Date),\n        completedAt: null,\n      })\n    })\n\n    it('handles empty file list gracefully', async () => {\n      const session = await service.uploadPhotos([])\n\n      expect(session.totalFiles).toBe(0)\n      expect(session.status).toBe('completed')\n      expect(session.completedAt).toBeDefined()\n    })\n\n    it('processes files and updates session progress', async () => {\n      const progressSpy = vi.fn()\n      const completeSpy = vi.fn()\n\n      // Mock event listeners\n      const mockService = service as any\n      mockService.on = vi.fn()\n      mockService.emit = vi.fn()\n\n      const session = await service.uploadPhotos(mockFiles)", "metadata": {}}
{"id": "776", "text": "expect(session.totalFiles).toBe(0)\n      expect(session.status).toBe('completed')\n      expect(session.completedAt).toBeDefined()\n    })\n\n    it('processes files and updates session progress', async () => {\n      const progressSpy = vi.fn()\n      const completeSpy = vi.fn()\n\n      // Mock event listeners\n      const mockService = service as any\n      mockService.on = vi.fn()\n      mockService.emit = vi.fn()\n\n      const session = await service.uploadPhotos(mockFiles)\n\n      // Wait for processing to complete\n      await waitForNextTick()\n\n      expect(session.status).toBe('processing')\n    })\n\n    it('groups photos by capture date into albums', async () => {\n      // Create files with different dates through filenames\n      const filesWithDates = [\n        createMockFile('IMG_20240715_001.jpg'),\n        createMockFile('IMG_20240715_002.jpg'),\n        createMockFile('IMG_20240716_001.jpg'),\n      ]\n\n      await service.uploadPhotos(filesWithDates)\n      await waitForNextTick()", "metadata": {}}
{"id": "777", "text": "// Wait for processing to complete\n      await waitForNextTick()\n\n      expect(session.status).toBe('processing')\n    })\n\n    it('groups photos by capture date into albums', async () => {\n      // Create files with different dates through filenames\n      const filesWithDates = [\n        createMockFile('IMG_20240715_001.jpg'),\n        createMockFile('IMG_20240715_002.jpg'),\n        createMockFile('IMG_20240716_001.jpg'),\n      ]\n\n      await service.uploadPhotos(filesWithDates)\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n\n      // Should create separate albums for different dates\n      expect(albums.length).toBeGreaterThanOrEqual(1)\n    })\n\n    it('handles upload errors gracefully', async () => {\n      // Create invalid file\n      const invalidFile = new File([''], 'invalid.txt', { type: 'text/plain' })\n\n      const session = await service.uploadPhotos([invalidFile])\n      await waitForNextTick()", "metadata": {}}
{"id": "778", "text": "await service.uploadPhotos(filesWithDates)\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n\n      // Should create separate albums for different dates\n      expect(albums.length).toBeGreaterThanOrEqual(1)\n    })\n\n    it('handles upload errors gracefully', async () => {\n      // Create invalid file\n      const invalidFile = new File([''], 'invalid.txt', { type: 'text/plain' })\n\n      const session = await service.uploadPhotos([invalidFile])\n      await waitForNextTick()\n\n      expect(session.totalFiles).toBe(1)\n      expect(session.errorCount).toBeGreaterThanOrEqual(0)\n    })\n\n    it('generates proper thumbnail data for uploaded photos', async () => {\n      await service.uploadPhotos([mockFiles[0]])\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const photos = await service.getPhotosInAlbum(albums[0].id)\n      const photo = photos[0]", "metadata": {}}
{"id": "779", "text": "const session = await service.uploadPhotos([invalidFile])\n      await waitForNextTick()\n\n      expect(session.totalFiles).toBe(1)\n      expect(session.errorCount).toBeGreaterThanOrEqual(0)\n    })\n\n    it('generates proper thumbnail data for uploaded photos', async () => {\n      await service.uploadPhotos([mockFiles[0]])\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const photos = await service.getPhotosInAlbum(albums[0].id)\n      const photo = photos[0]\n\n      expect(photo.thumbnailData).toBeInstanceOf(Blob)\n      expect(photo.thumbnailData.size).toBeGreaterThan(0)\n      expect(photo.thumbnailData.type).toMatch(/^image\\//)\n    })\n  })\n\n  describe('Album Export', () => {\n    it('exports album as ZIP file', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n\n      const zipBlob = await service.exportAlbumAsZip(album.id)", "metadata": {}}
{"id": "780", "text": "expect(photo.thumbnailData).toBeInstanceOf(Blob)\n      expect(photo.thumbnailData.size).toBeGreaterThan(0)\n      expect(photo.thumbnailData.type).toMatch(/^image\\//)\n    })\n  })\n\n  describe('Album Export', () => {\n    it('exports album as ZIP file', async () => {\n      await service.uploadPhotos(mockFiles.slice(0, 2))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n\n      const zipBlob = await service.exportAlbumAsZip(album.id)\n\n      expect(zipBlob).toBeInstanceOf(Blob)\n      expect(zipBlob.type).toBe('application/zip')\n      expect(zipBlob.size).toBeGreaterThan(0)\n    })\n\n    it('handles export of empty album by removing it', async () => {\n      await service.uploadPhotos([mockFiles[0]])\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const albumId = albums[0].id\n      await service.deletePhoto((await service.getPhotosInAlbum(albumId))[0].id)", "metadata": {}}
{"id": "781", "text": "const zipBlob = await service.exportAlbumAsZip(album.id)\n\n      expect(zipBlob).toBeInstanceOf(Blob)\n      expect(zipBlob.type).toBe('application/zip')\n      expect(zipBlob.size).toBeGreaterThan(0)\n    })\n\n    it('handles export of empty album by removing it', async () => {\n      await service.uploadPhotos([mockFiles[0]])\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const albumId = albums[0].id\n      await service.deletePhoto((await service.getPhotosInAlbum(albumId))[0].id)\n\n      // Album should be removed when emptied, so export should fail\n      await expect(service.exportAlbumAsZip(albumId)).rejects.toThrow('Album not found')\n    })\n\n    it('throws error for non-existent album export', async () => {\n      await expect(service.exportAlbumAsZip(999)).rejects.toThrow('Album not found')\n    })", "metadata": {}}
{"id": "782", "text": "const albums = await service.getAllAlbums()\n      const albumId = albums[0].id\n      await service.deletePhoto((await service.getPhotosInAlbum(albumId))[0].id)\n\n      // Album should be removed when emptied, so export should fail\n      await expect(service.exportAlbumAsZip(albumId)).rejects.toThrow('Album not found')\n    })\n\n    it('throws error for non-existent album export', async () => {\n      await expect(service.exportAlbumAsZip(999)).rejects.toThrow('Album not found')\n    })\n\n    it('includes all photos in exported ZIP', async () => {\n      const numberOfPhotos = 3\n      await service.uploadPhotos(mockFiles.slice(0, numberOfPhotos))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const zipBlob = await service.exportAlbumAsZip(album.id)\n\n      // ZIP should contain metadata about included files\n      expect(zipBlob.size).toBeGreaterThan(numberOfPhotos * 1000) // Rough size check\n    })\n  })", "metadata": {}}
{"id": "783", "text": "it('includes all photos in exported ZIP', async () => {\n      const numberOfPhotos = 3\n      await service.uploadPhotos(mockFiles.slice(0, numberOfPhotos))\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const zipBlob = await service.exportAlbumAsZip(album.id)\n\n      // ZIP should contain metadata about included files\n      expect(zipBlob.size).toBeGreaterThan(numberOfPhotos * 1000) // Rough size check\n    })\n  })\n\n  describe('Data Persistence Simulation', () => {\n    it('maintains data consistency across operations', async () => {\n      // Upload photos\n      await service.uploadPhotos(mockFiles)\n      await waitForNextTick()\n\n      const albums1 = await service.getAllAlbums()\n      const initialAlbumCount = albums1.length\n\n      // Delete a photo\n      const photos = await service.getPhotosInAlbum(albums1[0].id)\n      await service.deletePhoto(photos[0].id)", "metadata": {}}
{"id": "784", "text": "describe('Data Persistence Simulation', () => {\n    it('maintains data consistency across operations', async () => {\n      // Upload photos\n      await service.uploadPhotos(mockFiles)\n      await waitForNextTick()\n\n      const albums1 = await service.getAllAlbums()\n      const initialAlbumCount = albums1.length\n\n      // Delete a photo\n      const photos = await service.getPhotosInAlbum(albums1[0].id)\n      await service.deletePhoto(photos[0].id)\n\n      // Check consistency\n      const albums2 = await service.getAllAlbums()\n      const updatedPhotos = await service.getPhotosInAlbum(albums1[0].id)\n\n      expect(updatedPhotos.length).toBe(photos.length - 1)\n\n      // Album count should remain same or decrease if album was emptied\n      expect(albums2.length).toBeLessThanOrEqual(initialAlbumCount)\n    })", "metadata": {}}
{"id": "785", "text": "// Delete a photo\n      const photos = await service.getPhotosInAlbum(albums1[0].id)\n      await service.deletePhoto(photos[0].id)\n\n      // Check consistency\n      const albums2 = await service.getAllAlbums()\n      const updatedPhotos = await service.getPhotosInAlbum(albums1[0].id)\n\n      expect(updatedPhotos.length).toBe(photos.length - 1)\n\n      // Album count should remain same or decrease if album was emptied\n      expect(albums2.length).toBeLessThanOrEqual(initialAlbumCount)\n    })\n\n    it('handles concurrent operations gracefully', async () => {\n      const uploadPromises = [\n        service.uploadPhotos([mockFiles[0]]),\n        service.uploadPhotos([mockFiles[1]]),\n        service.uploadPhotos([mockFiles[2]]),\n      ]\n\n      const sessions = await Promise.all(uploadPromises)\n      await waitForNextTick()\n\n      expect(sessions).toHaveLength(3)\n      sessions.forEach(session => {\n        expect(session.id).toBeDefined()\n        expect(session.totalFiles).toBe(1)\n      })", "metadata": {}}
{"id": "786", "text": "it('handles concurrent operations gracefully', async () => {\n      const uploadPromises = [\n        service.uploadPhotos([mockFiles[0]]),\n        service.uploadPhotos([mockFiles[1]]),\n        service.uploadPhotos([mockFiles[2]]),\n      ]\n\n      const sessions = await Promise.all(uploadPromises)\n      await waitForNextTick()\n\n      expect(sessions).toHaveLength(3)\n      sessions.forEach(session => {\n        expect(session.id).toBeDefined()\n        expect(session.totalFiles).toBe(1)\n      })\n\n      const albums = await service.getAllAlbums()\n      expect(albums.length).toBeGreaterThan(0)\n    })\n  })\n\n  describe('Performance Simulation', () => {\n    it('simulates realistic delays', async () => {\n      const startTime = Date.now()\n      await service.getAllAlbums()\n      const endTime = Date.now()\n\n      const duration = endTime - startTime\n      expect(duration).toBeGreaterThanOrEqual(0) // Should have some delay simulation\n    })", "metadata": {}}
{"id": "787", "text": "const albums = await service.getAllAlbums()\n      expect(albums.length).toBeGreaterThan(0)\n    })\n  })\n\n  describe('Performance Simulation', () => {\n    it('simulates realistic delays', async () => {\n      const startTime = Date.now()\n      await service.getAllAlbums()\n      const endTime = Date.now()\n\n      const duration = endTime - startTime\n      expect(duration).toBeGreaterThanOrEqual(0) // Should have some delay simulation\n    })\n\n    it('handles large file uploads efficiently', async () => {\n      const largeFiles = Array.from({ length: 10 }, (_, i) =>\n        createMockFile(`large-photo-${i}.jpg`, 'image/jpeg', 5 * 1024 * 1024)\n      )\n\n      const startTime = Date.now()\n      const session = await service.uploadPhotos(largeFiles)\n      const endTime = Date.now()\n\n      expect(session.totalFiles).toBe(10)\n      expect(endTime - startTime).toBeLessThan(5000) // Should complete within reasonable time\n    })", "metadata": {}}
{"id": "788", "text": "it('handles large file uploads efficiently', async () => {\n      const largeFiles = Array.from({ length: 10 }, (_, i) =>\n        createMockFile(`large-photo-${i}.jpg`, 'image/jpeg', 5 * 1024 * 1024)\n      )\n\n      const startTime = Date.now()\n      const session = await service.uploadPhotos(largeFiles)\n      const endTime = Date.now()\n\n      expect(session.totalFiles).toBe(10)\n      expect(endTime - startTime).toBeLessThan(5000) // Should complete within reasonable time\n    })\n\n    it('efficiently manages memory with large datasets', async () => {\n      // Create many small uploads to simulate large dataset\n      const batches = Array.from({ length: 5 }, (_, batchIndex) =>\n        Array.from({ length: 4 }, (_, photoIndex) =>\n          createMockFile(`batch-${batchIndex}-photo-${photoIndex}.jpg`)\n        )\n      )\n\n      for (const batch of batches) {\n        await service.uploadPhotos(batch)\n      }\n\n      await waitForNextTick()", "metadata": {}}
{"id": "789", "text": "it('efficiently manages memory with large datasets', async () => {\n      // Create many small uploads to simulate large dataset\n      const batches = Array.from({ length: 5 }, (_, batchIndex) =>\n        Array.from({ length: 4 }, (_, photoIndex) =>\n          createMockFile(`batch-${batchIndex}-photo-${photoIndex}.jpg`)\n        )\n      )\n\n      for (const batch of batches) {\n        await service.uploadPhotos(batch)\n      }\n\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const totalPhotos = await Promise.all(\n        albums.map(album => service.getPhotosInAlbum(album.id))\n      )\n\n      const photoCount = totalPhotos.reduce((sum, photos) => sum + photos.length, 0)\n      expect(photoCount).toBe(20) // 5 batches * 4 photos each\n    })\n  })", "metadata": {}}
{"id": "790", "text": "for (const batch of batches) {\n        await service.uploadPhotos(batch)\n      }\n\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const totalPhotos = await Promise.all(\n        albums.map(album => service.getPhotosInAlbum(album.id))\n      )\n\n      const photoCount = totalPhotos.reduce((sum, photos) => sum + photos.length, 0)\n      expect(photoCount).toBe(20) // 5 batches * 4 photos each\n    })\n  })\n\n  describe('Edge Cases and Error Conditions', () => {\n    it('handles malformed file data gracefully', async () => {\n      const malformedFile = new File(['corrupt data'], 'corrupt.jpg', { type: 'image/jpeg' })\n\n      const session = await service.uploadPhotos([malformedFile])\n      await waitForNextTick()\n\n      expect(session.totalFiles).toBe(1)\n      // Should not crash, may increment error count\n    })", "metadata": {}}
{"id": "791", "text": "describe('Edge Cases and Error Conditions', () => {\n    it('handles malformed file data gracefully', async () => {\n      const malformedFile = new File(['corrupt data'], 'corrupt.jpg', { type: 'image/jpeg' })\n\n      const session = await service.uploadPhotos([malformedFile])\n      await waitForNextTick()\n\n      expect(session.totalFiles).toBe(1)\n      // Should not crash, may increment error count\n    })\n\n    it('validates file types correctly', async () => {\n      const textFile = createMockFile('document.txt', 'text/plain')\n      const imageFile = createMockFile('photo.jpg', 'image/jpeg')\n\n      const session = await service.uploadPhotos([textFile, imageFile])\n      await waitForNextTick()\n\n      expect(session.totalFiles).toBe(2)\n    })\n\n    it('handles extremely large photo collections', async () => {\n      // Simulate 100 photos\n      const manyFiles = Array.from({ length: 100 }, (_, i) =>\n        createMockFile(`photo-${i}.jpg`)\n      )", "metadata": {}}
{"id": "792", "text": "const session = await service.uploadPhotos([textFile, imageFile])\n      await waitForNextTick()\n\n      expect(session.totalFiles).toBe(2)\n    })\n\n    it('handles extremely large photo collections', async () => {\n      // Simulate 100 photos\n      const manyFiles = Array.from({ length: 100 }, (_, i) =>\n        createMockFile(`photo-${i}.jpg`)\n      )\n\n      const session = await service.uploadPhotos(manyFiles)\n      expect(session.totalFiles).toBe(100)\n\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      expect(albums.length).toBeGreaterThan(0)\n    })\n\n    it('maintains referential integrity during cascading deletes', async () => {\n      await service.uploadPhotos(mockFiles)\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const photos = await service.getPhotosInAlbum(album.id)\n\n      // Delete album (should cascade to photos)\n      await service.deleteAlbum(album.id)", "metadata": {}}
{"id": "793", "text": "await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      expect(albums.length).toBeGreaterThan(0)\n    })\n\n    it('maintains referential integrity during cascading deletes', async () => {\n      await service.uploadPhotos(mockFiles)\n      await waitForNextTick()\n\n      const albums = await service.getAllAlbums()\n      const album = albums[0]\n      const photos = await service.getPhotosInAlbum(album.id)\n\n      // Delete album (should cascade to photos)\n      await service.deleteAlbum(album.id)\n\n      // Verify photos are also deleted\n      for (const photo of photos) {\n        await expect(service.getFullPhoto(photo.id)).rejects.toThrow('Photo not found')\n      }\n    })\n  })\n})", "metadata": {}}
{"id": "794", "text": "import { Image, User } from '../../src/types';\n\nexport function createTestUser(overrides?: Partial<User>): User {\n  return {\n    id: overrides?.id || '550e8400-e29b-41d4-a716-446655440000',\n    username: overrides?.username || 'testuser',\n    displayName: overrides?.displayName || 'Test User',\n    email: overrides?.email || 'test@example.com',\n    avatarUrl: overrides?.avatarUrl || 'https://example.com/avatar.jpg',\n    ...overrides\n  };\n}\n\nexport function createTestImage(overrides?: Partial<Image>): Image {\n  const testUser = createTestUser(overrides?.uploadedBy as Partial<User>);\n\n  return {\n    id: overrides?.id || '550e8400-e29b-41d4-a716-446655440000',\n    filename: overrides?.filename || 'test-image.jpg',\n    path: overrides?.path || '/images/test-image.jpg',\n    url: overrides?.url || 'blob:https://app.example.com/test',\n    caption: overrides?.caption || 'Test image caption',", "metadata": {}}
{"id": "795", "text": "export function createTestImage(overrides?: Partial<Image>): Image {\n  const testUser = createTestUser(overrides?.uploadedBy as Partial<User>);\n\n  return {\n    id: overrides?.id || '550e8400-e29b-41d4-a716-446655440000',\n    filename: overrides?.filename || 'test-image.jpg',\n    path: overrides?.path || '/images/test-image.jpg',\n    url: overrides?.url || 'blob:https://app.example.com/test',\n    caption: overrides?.caption || 'Test image caption',\n    uploadedBy: overrides?.uploadedBy || testUser,\n    uploadedAt: overrides?.uploadedAt || new Date('2024-09-26T14:30:00Z'),\n    capturedAt: overrides?.capturedAt || new Date('2024-09-25T18:45:00Z'),\n    fileSize: overrides?.fileSize || 2457600,\n    width: overrides?.width || 4032,\n    height: overrides?.height || 3024,\n    mimeType: overrides?.", "metadata": {}}
{"id": "796", "text": "com/test',\n    caption: overrides?.caption || 'Test image caption',\n    uploadedBy: overrides?.uploadedBy || testUser,\n    uploadedAt: overrides?.uploadedAt || new Date('2024-09-26T14:30:00Z'),\n    capturedAt: overrides?.capturedAt || new Date('2024-09-25T18:45:00Z'),\n    fileSize: overrides?.fileSize || 2457600,\n    width: overrides?.width || 4032,\n    height: overrides?.height || 3024,\n    mimeType: overrides?.mimeType || 'image/jpeg',\n    cameraModel: overrides?.cameraModel || 'iPhone 14 Pro',\n    location: overrides?.location || '37.7749,-122.4194',\n    tags: overrides?.tags || ['test', 'nature'],\n    ...overrides\n  };\n}", "metadata": {}}
{"id": "797", "text": "fileSize: overrides?.fileSize || 2457600,\n    width: overrides?.width || 4032,\n    height: overrides?.height || 3024,\n    mimeType: overrides?.mimeType || 'image/jpeg',\n    cameraModel: overrides?.cameraModel || 'iPhone 14 Pro',\n    location: overrides?.location || '37.7749,-122.4194',\n    tags: overrides?.tags || ['test', 'nature'],\n    ...overrides\n  };\n}\n\nexport function createMockImageResponse(image: Image) {\n  return {\n    ...image,\n    uploadedAt: image.uploadedAt.toISOString(),\n    capturedAt: image.capturedAt?.toISOString(),\n  };\n}", "metadata": {}}
{"id": "798", "text": "height || 3024,\n    mimeType: overrides?.mimeType || 'image/jpeg',\n    cameraModel: overrides?.cameraModel || 'iPhone 14 Pro',\n    location: overrides?.location || '37.7749,-122.4194',\n    tags: overrides?.tags || ['test', 'nature'],\n    ...overrides\n  };\n}\n\nexport function createMockImageResponse(image: Image) {\n  return {\n    ...image,\n    uploadedAt: image.uploadedAt.toISOString(),\n    capturedAt: image.capturedAt?.toISOString(),\n  };\n}\n\nexport function mockFetch(response: any, status = 200) {\n  global.fetch = vi.fn().mockResolvedValue({\n    ok: status >= 200 && status < 300,\n    status,\n    json: () => Promise.resolve(response),\n    blob: () => Promise.resolve(new Blob(['test'], { type: 'image/jpeg' })),\n    arrayBuffer: () => Promise.resolve(new ArrayBuffer(8)),\n    headers: new Map(),\n  });\n}", "metadata": {}}
{"id": "799", "text": "export function mockFetch(response: any, status = 200) {\n  global.fetch = vi.fn().mockResolvedValue({\n    ok: status >= 200 && status < 300,\n    status,\n    json: () => Promise.resolve(response),\n    blob: () => Promise.resolve(new Blob(['test'], { type: 'image/jpeg' })),\n    arrayBuffer: () => Promise.resolve(new ArrayBuffer(8)),\n    headers: new Map(),\n  });\n}\n\nexport function mockFetchError(message: string, status = 400) {\n  global.fetch = vi.fn().mockResolvedValue({\n    ok: false,\n    status,\n    json: () => Promise.resolve({ error: message }),\n  });\n}\n\nexport function mockNetworkError() {\n  global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));\n}\n\nexport function setupTestEnvironment() {\n  // Reset all mocks\n  vi.clearAllMocks();", "metadata": {}}
{"id": "800", "text": "export function mockFetchError(message: string, status = 400) {\n  global.fetch = vi.fn().mockResolvedValue({\n    ok: false,\n    status,\n    json: () => Promise.resolve({ error: message }),\n  });\n}\n\nexport function mockNetworkError() {\n  global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));\n}\n\nexport function setupTestEnvironment() {\n  // Reset all mocks\n  vi.clearAllMocks();\n\n  // Mock window methods\n  Object.defineProperty(window, 'matchMedia', {\n    writable: true,\n    value: vi.fn().mockImplementation(query => ({\n      matches: false,\n      media: query,\n      onchange: null,\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn(),\n    })),\n  });\n\n  // Mock URL methods\n  global.URL.createObjectURL = vi.fn(() => 'blob:test-url');\n  global.URL.revokeObjectURL = vi.fn();", "metadata": {}}
{"id": "801", "text": "// Mock window methods\n  Object.defineProperty(window, 'matchMedia', {\n    writable: true,\n    value: vi.fn().mockImplementation(query => ({\n      matches: false,\n      media: query,\n      onchange: null,\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn(),\n    })),\n  });\n\n  // Mock URL methods\n  global.URL.createObjectURL = vi.fn(() => 'blob:test-url');\n  global.URL.revokeObjectURL = vi.fn();\n\n  // Mock resize observer\n  global.ResizeObserver = vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  }));\n\n  // Mock intersection observer\n  global.IntersectionObserver = vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  }));\n}\n\nexport function cleanupTestEnvironment() {\n  vi.restoreAllMocks();\n}", "metadata": {}}
{"id": "802", "text": "// Mock resize observer\n  global.ResizeObserver = vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  }));\n\n  // Mock intersection observer\n  global.IntersectionObserver = vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  }));\n}\n\nexport function cleanupTestEnvironment() {\n  vi.restoreAllMocks();\n}\n\n// Mock localStorage\nexport function createMockLocalStorage() {\n  const store: Record<string, string> = {};\n  return {\n    getItem: vi.fn((key: string) => store[key]),\n    setItem: vi.fn((key: string, value: string) => {\n      store[key] = value.toString();\n    }),\n    removeItem: vi.fn((key: string) => {\n      delete store[key];\n    }),\n    clear: vi.fn(() => {\n      Object.keys(store).forEach(key => delete store[key]);\n    }),\n  };\n}\n\n// Wait for async operations\nexport function waitForAsync() {\n  return new Promise(resolve => setTimeout(resolve, 0));\n}", "metadata": {}}
{"id": "803", "text": "// Wait for async operations\nexport function waitForAsync() {\n  return new Promise(resolve => setTimeout(resolve, 0));\n}\n\n// Mock user event helpers\nexport async function type(element: HTMLElement, text: string) {\n  await userEvent.type(element, text);\n}\n\nexport async function click(element: HTMLElement) {\n  await userEvent.click(element);\n}\n\nexport async function tab() {\n  await userEvent.tab();\n}\n\nexport async function keyboard(key: string) {\n  await userEvent.keyboard(key);\n}", "metadata": {}}
{"id": "804", "text": "/**\n * Test utilities and custom render functions\n * Provides enhanced testing helpers for React Testing Library\n */\n\nimport React, { ReactElement } from 'react'\nimport { render, RenderOptions, RenderResult } from '@testing-library/react'\nimport { vi } from 'vitest'\nimport { Album, Photo, UploadSession } from '../src/types'\n\n// ============================================================================\n// Test Providers and Wrappers\n// ============================================================================\n\ninterface TestProvidersProps {\n  children: React.ReactNode\n}\n\n/**\n * Wrapper component that provides all necessary context providers for testing\n */\nconst TestProviders: React.FC<TestProvidersProps> = ({ children }) => {\n  return (\n    <div data-testid=\"test-wrapper\">\n      {children}\n    </div>\n  )\n}\n\n// ============================================================================\n// Custom Render Function\n// ============================================================================\n\ninterface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {\n  wrapper?: React.ComponentType<any>\n}", "metadata": {}}
{"id": "805", "text": "// ============================================================================\n// Test Providers and Wrappers\n// ============================================================================\n\ninterface TestProvidersProps {\n  children: React.ReactNode\n}\n\n/**\n * Wrapper component that provides all necessary context providers for testing\n */\nconst TestProviders: React.FC<TestProvidersProps> = ({ children }) => {\n  return (\n    <div data-testid=\"test-wrapper\">\n      {children}\n    </div>\n  )\n}\n\n// ============================================================================\n// Custom Render Function\n// ============================================================================\n\ninterface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {\n  wrapper?: React.ComponentType<any>\n}\n\n/**\n * Custom render function that includes all providers\n * Use this instead of RTL's render for consistent test setup\n */\nexport const renderWithProviders = (\n  ui: ReactElement,\n  options: CustomRenderOptions = {}\n): RenderResult => {\n  const { wrapper: CustomWrapper = TestProviders, ...renderOptions } = options\n\n  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n    return <CustomWrapper>{children}</CustomWrapper>\n  }\n\n  return render(ui, { wrapper: Wrapper, ...renderOptions })\n}", "metadata": {}}
{"id": "806", "text": "/**\n * Custom render function that includes all providers\n * Use this instead of RTL's render for consistent test setup\n */\nexport const renderWithProviders = (\n  ui: ReactElement,\n  options: CustomRenderOptions = {}\n): RenderResult => {\n  const { wrapper: CustomWrapper = TestProviders, ...renderOptions } = options\n\n  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n    return <CustomWrapper>{children}</CustomWrapper>\n  }\n\n  return render(ui, { wrapper: Wrapper, ...renderOptions })\n}\n\n// Re-export everything from testing-library\nexport * from '@testing-library/react'\nexport { renderWithProviders as render }\n\n// ============================================================================\n// Mock Data Factories\n// ============================================================================", "metadata": {}}
{"id": "807", "text": "const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n    return <CustomWrapper>{children}</CustomWrapper>\n  }\n\n  return render(ui, { wrapper: Wrapper, ...renderOptions })\n}\n\n// Re-export everything from testing-library\nexport * from '@testing-library/react'\nexport { renderWithProviders as render }\n\n// ============================================================================\n// Mock Data Factories\n// ============================================================================\n\n/**\n * Create a mock Album with customizable properties\n */\nexport const createMockAlbum = (overrides: Partial<Album> = {}): Album => ({\n  id: 1,\n  name: 'Test Album',\n  captureDate: new Date('2024-09-15'),\n  displayOrder: 1,\n  thumbnailPhotoId: 1,\n  photoCount: 10,\n  createdAt: new Date('2024-09-15T10:00:00Z'),\n  updatedAt: new Date('2024-09-15T10:00:00Z'),\n  ...overrides,\n})", "metadata": {}}
{"id": "808", "text": "/**\n * Create a mock Album with customizable properties\n */\nexport const createMockAlbum = (overrides: Partial<Album> = {}): Album => ({\n  id: 1,\n  name: 'Test Album',\n  captureDate: new Date('2024-09-15'),\n  displayOrder: 1,\n  thumbnailPhotoId: 1,\n  photoCount: 10,\n  createdAt: new Date('2024-09-15T10:00:00Z'),\n  updatedAt: new Date('2024-09-15T10:00:00Z'),\n  ...overrides,\n})\n\n/**\n * Create multiple mock Albums\n */\nexport const createMockAlbums = (count: number): Album[] => {\n  return Array.from({ length: count }, (_, index) =>\n    createMockAlbum({\n      id: index + 1,\n      name: `Album ${index + 1}`,\n      displayOrder: index + 1,\n      thumbnailPhotoId: (index * 10) + 1,\n    })\n  )\n}", "metadata": {}}
{"id": "809", "text": "/**\n * Create multiple mock Albums\n */\nexport const createMockAlbums = (count: number): Album[] => {\n  return Array.from({ length: count }, (_, index) =>\n    createMockAlbum({\n      id: index + 1,\n      name: `Album ${index + 1}`,\n      displayOrder: index + 1,\n      thumbnailPhotoId: (index * 10) + 1,\n    })\n  )\n}\n\n/**\n * Create a mock Photo with customizable properties\n */\nexport const createMockPhoto = (overrides: Partial<Photo> = {}): Photo => {\n  const mockBlob = new Blob(['test'], { type: 'image/jpeg' })", "metadata": {}}
{"id": "810", "text": "/**\n * Create a mock Photo with customizable properties\n */\nexport const createMockPhoto = (overrides: Partial<Photo> = {}): Photo => {\n  const mockBlob = new Blob(['test'], { type: 'image/jpeg' })\n\n  return {\n    id: 1,\n    filename: 'test-photo.jpg',\n    albumId: 1,\n    fileData: mockBlob,\n    thumbnailData: mockBlob,\n    captureDate: new Date('2024-09-15'),\n    fileSize: 1024000,\n    width: 1920,\n    height: 1080,\n    uploadTimestamp: new Date('2024-09-15T10:00:00Z'),\n    ...overrides,\n  }\n}\n\n/**\n * Create multiple mock Photos\n */\nexport const createMockPhotos = (count: number, albumId: number = 1): Photo[] => {\n  return Array.from({ length: count }, (_, index) =>\n    createMockPhoto({\n      id: index + 1,\n      filename: `photo-${index + 1}.jpg`,\n      albumId,\n    })\n  )\n}", "metadata": {}}
{"id": "811", "text": "/**\n * Create multiple mock Photos\n */\nexport const createMockPhotos = (count: number, albumId: number = 1): Photo[] => {\n  return Array.from({ length: count }, (_, index) =>\n    createMockPhoto({\n      id: index + 1,\n      filename: `photo-${index + 1}.jpg`,\n      albumId,\n    })\n  )\n}\n\n/**\n * Create a mock UploadSession\n */\nexport const createMockUploadSession = (\n  overrides: Partial<UploadSession> = {}\n): UploadSession => ({\n  id: 'session-123',\n  status: 'processing',\n  totalFiles: 10,\n  processedFiles: 5,\n  errorCount: 0,\n  startedAt: new Date('2024-09-15T10:00:00Z'),\n  completedAt: null,\n  ...overrides,\n})\n\n// ============================================================================\n// Mock URL Object URLs (for Blob handling)\n// ============================================================================\n\n/**\n * Mock URL.createObjectURL for testing file handling\n */\nexport const mockCreateObjectURL = (): string => {\n  return 'blob:mock-url-12345'\n}", "metadata": {}}
{"id": "812", "text": "// ============================================================================\n// Mock URL Object URLs (for Blob handling)\n// ============================================================================\n\n/**\n * Mock URL.createObjectURL for testing file handling\n */\nexport const mockCreateObjectURL = (): string => {\n  return 'blob:mock-url-12345'\n}\n\n/**\n * Setup URL mocks for tests involving file handling\n */\nexport const setupURLMocks = () => {\n  Object.defineProperty(global, 'URL', {\n    value: {\n      createObjectURL: vi.fn().mockImplementation(mockCreateObjectURL),\n      revokeObjectURL: vi.fn(),\n    },\n    writable: true,\n  })\n}\n\n// ============================================================================\n// DOM Mocks and Utilities\n// ============================================================================\n\n/**\n * Mock IntersectionObserver for infinite scroll tests\n */\nexport const mockIntersectionObserver = () => {\n  const observe = vi.fn()\n  const disconnect = vi.fn()\n  const unobserve = vi.fn()\n\n  // Mock constructor\n  const IntersectionObserverMock = vi.fn().mockImplementation((callback) => ({\n    observe,\n    disconnect,\n    unobserve,\n    callback,\n  }))\n\n  Object.defineProperty(global, 'IntersectionObserver', {\n    value: IntersectionObserverMock,\n    writable: true,\n  })", "metadata": {}}
{"id": "813", "text": "// ============================================================================\n// DOM Mocks and Utilities\n// ============================================================================\n\n/**\n * Mock IntersectionObserver for infinite scroll tests\n */\nexport const mockIntersectionObserver = () => {\n  const observe = vi.fn()\n  const disconnect = vi.fn()\n  const unobserve = vi.fn()\n\n  // Mock constructor\n  const IntersectionObserverMock = vi.fn().mockImplementation((callback) => ({\n    observe,\n    disconnect,\n    unobserve,\n    callback,\n  }))\n\n  Object.defineProperty(global, 'IntersectionObserver', {\n    value: IntersectionObserverMock,\n    writable: true,\n  })\n\n  return { observe, disconnect, unobserve, IntersectionObserverMock }\n}\n\n/**\n * Mock ResizeObserver for responsive components\n */\nexport const mockResizeObserver = () => {\n  const observe = vi.fn()\n  const disconnect = vi.fn()\n  const unobserve = vi.fn()\n\n  const ResizeObserverMock = vi.fn().mockImplementation(() => ({\n    observe,\n    disconnect,\n    unobserve,\n  }))\n\n  Object.defineProperty(global, 'ResizeObserver', {\n    value: ResizeObserverMock,\n    writable: true,\n  })", "metadata": {}}
{"id": "814", "text": "return { observe, disconnect, unobserve, IntersectionObserverMock }\n}\n\n/**\n * Mock ResizeObserver for responsive components\n */\nexport const mockResizeObserver = () => {\n  const observe = vi.fn()\n  const disconnect = vi.fn()\n  const unobserve = vi.fn()\n\n  const ResizeObserverMock = vi.fn().mockImplementation(() => ({\n    observe,\n    disconnect,\n    unobserve,\n  }))\n\n  Object.defineProperty(global, 'ResizeObserver', {\n    value: ResizeObserverMock,\n    writable: true,\n  })\n\n  return { observe, disconnect, unobserve, ResizeObserverMock }\n}\n\n/**\n * Mock getBoundingClientRect for layout tests\n */\nexport const mockGetBoundingClientRect = (overrides: Partial<DOMRect> = {}) => {\n  const mockRect: DOMRect = {\n    bottom: 0,\n    height: 0,\n    left: 0,\n    right: 0,\n    top: 0,\n    width: 0,\n    x: 0,\n    y: 0,\n    toJSON: () => ({}),\n    ...overrides,\n  }\n\n  Element.prototype.getBoundingClientRect = vi.fn(() => mockRect)", "metadata": {}}
{"id": "815", "text": "/**\n * Mock getBoundingClientRect for layout tests\n */\nexport const mockGetBoundingClientRect = (overrides: Partial<DOMRect> = {}) => {\n  const mockRect: DOMRect = {\n    bottom: 0,\n    height: 0,\n    left: 0,\n    right: 0,\n    top: 0,\n    width: 0,\n    x: 0,\n    y: 0,\n    toJSON: () => ({}),\n    ...overrides,\n  }\n\n  Element.prototype.getBoundingClientRect = vi.fn(() => mockRect)\n\n  return mockRect\n}\n\n// ============================================================================\n// Drag and Drop Test Utilities\n// ============================================================================\n\n/**\n * Create a mock DragEvent for testing drag and drop\n */\nexport const createMockDragEvent = (\n  type: string,\n  dataTransfer?: Partial<DataTransfer>\n): DragEvent => {\n  const event = new Event(type) as DragEvent", "metadata": {}}
{"id": "816", "text": "Element.prototype.getBoundingClientRect = vi.fn(() => mockRect)\n\n  return mockRect\n}\n\n// ============================================================================\n// Drag and Drop Test Utilities\n// ============================================================================\n\n/**\n * Create a mock DragEvent for testing drag and drop\n */\nexport const createMockDragEvent = (\n  type: string,\n  dataTransfer?: Partial<DataTransfer>\n): DragEvent => {\n  const event = new Event(type) as DragEvent\n\n  Object.defineProperty(event, 'dataTransfer', {\n    value: {\n      dropEffect: 'none',\n      effectAllowed: 'all',\n      files: [],\n      items: [],\n      types: [],\n      clearData: vi.fn(),\n      getData: vi.fn(),\n      setData: vi.fn(),\n      setDragImage: vi.fn(),\n      ...dataTransfer,\n    },\n    writable: true,\n  })\n\n  return event\n}", "metadata": {}}
{"id": "817", "text": "Object.defineProperty(event, 'dataTransfer', {\n    value: {\n      dropEffect: 'none',\n      effectAllowed: 'all',\n      files: [],\n      items: [],\n      types: [],\n      clearData: vi.fn(),\n      getData: vi.fn(),\n      setData: vi.fn(),\n      setDragImage: vi.fn(),\n      ...dataTransfer,\n    },\n    writable: true,\n  })\n\n  return event\n}\n\n/**\n * Simulate drag and drop interaction\n */\nexport const simulateDragAndDrop = (\n  source: HTMLElement,\n  target: HTMLElement,\n  dataTransfer: Partial<DataTransfer> = {}\n) => {\n  const dragStartEvent = createMockDragEvent('dragstart', dataTransfer)\n  const dropEvent = createMockDragEvent('drop', dataTransfer)\n\n  source.dispatchEvent(dragStartEvent)\n  target.dispatchEvent(dropEvent)\n\n  return { dragStartEvent, dropEvent }\n}\n\n// ============================================================================\n// File Upload Test Utilities\n// ============================================================================", "metadata": {}}
{"id": "818", "text": "return event\n}\n\n/**\n * Simulate drag and drop interaction\n */\nexport const simulateDragAndDrop = (\n  source: HTMLElement,\n  target: HTMLElement,\n  dataTransfer: Partial<DataTransfer> = {}\n) => {\n  const dragStartEvent = createMockDragEvent('dragstart', dataTransfer)\n  const dropEvent = createMockDragEvent('drop', dataTransfer)\n\n  source.dispatchEvent(dragStartEvent)\n  target.dispatchEvent(dropEvent)\n\n  return { dragStartEvent, dropEvent }\n}\n\n// ============================================================================\n// File Upload Test Utilities\n// ============================================================================\n\n/**\n * Create a mock File for testing file uploads\n */\nexport const createMockFile = (\n  name: string = 'test.jpg',\n  type: string = 'image/jpeg',\n  size: number = 1024000\n): File => {\n  const file = new File(['test content'], name, { type })\n  Object.defineProperty(file, 'size', { value: size })\n  return file\n}", "metadata": {}}
{"id": "819", "text": "source.dispatchEvent(dragStartEvent)\n  target.dispatchEvent(dropEvent)\n\n  return { dragStartEvent, dropEvent }\n}\n\n// ============================================================================\n// File Upload Test Utilities\n// ============================================================================\n\n/**\n * Create a mock File for testing file uploads\n */\nexport const createMockFile = (\n  name: string = 'test.jpg',\n  type: string = 'image/jpeg',\n  size: number = 1024000\n): File => {\n  const file = new File(['test content'], name, { type })\n  Object.defineProperty(file, 'size', { value: size })\n  return file\n}\n\n/**\n * Create FileList for testing multiple file uploads\n */\nexport const createMockFileList = (files: File[]): FileList => {\n  const fileList = files as any\n  fileList.item = (index: number) => fileList[index] || null\n  Object.defineProperty(fileList, 'length', { value: files.length })\n  return fileList as FileList\n}\n\n// ============================================================================\n// Async Testing Utilities\n// ============================================================================", "metadata": {}}
{"id": "820", "text": "/**\n * Create FileList for testing multiple file uploads\n */\nexport const createMockFileList = (files: File[]): FileList => {\n  const fileList = files as any\n  fileList.item = (index: number) => fileList[index] || null\n  Object.defineProperty(fileList, 'length', { value: files.length })\n  return fileList as FileList\n}\n\n// ============================================================================\n// Async Testing Utilities\n// ============================================================================\n\n/**\n * Wait for next tick (useful for async state updates)\n */\nexport const waitForNextTick = () =>\n  new Promise((resolve) => setTimeout(resolve, 0))\n\n/**\n * Wait for multiple ticks (useful for animation frames)\n */\nexport const waitForTicks = (count: number = 1) =>\n  new Promise((resolve) => {\n    let remaining = count\n    const tick = () => {\n      remaining--\n      if (remaining <= 0) {\n        resolve(undefined)\n      } else {\n        setTimeout(tick, 0)\n      }\n    }\n    setTimeout(tick, 0)\n  })\n\n// ============================================================================\n// Accessibility Testing Helpers\n// ============================================================================", "metadata": {}}
{"id": "821", "text": "/**\n * Wait for multiple ticks (useful for animation frames)\n */\nexport const waitForTicks = (count: number = 1) =>\n  new Promise((resolve) => {\n    let remaining = count\n    const tick = () => {\n      remaining--\n      if (remaining <= 0) {\n        resolve(undefined)\n      } else {\n        setTimeout(tick, 0)\n      }\n    }\n    setTimeout(tick, 0)\n  })\n\n// ============================================================================\n// Accessibility Testing Helpers\n// ============================================================================\n\n/**\n * Check if element has proper ARIA attributes\n */\nexport const hasAriaLabel = (element: HTMLElement): boolean => {\n  return !!(\n    element.getAttribute('aria-label') ||\n    element.getAttribute('aria-labelledby')\n  )\n}\n\n/**\n * Check if element is keyboard accessible\n */\nexport const isKeyboardAccessible = (element: HTMLElement): boolean => {\n  const tabIndex = element.getAttribute('tabindex')\n  return (\n    element.tagName === 'BUTTON' ||\n    element.tagName === 'A' ||\n    element.tagName === 'INPUT' ||\n    (tabIndex !== null && parseInt(tabIndex) >= 0)\n  )\n}", "metadata": {}}
{"id": "822", "text": "/**\n * Check if element is keyboard accessible\n */\nexport const isKeyboardAccessible = (element: HTMLElement): boolean => {\n  const tabIndex = element.getAttribute('tabindex')\n  return (\n    element.tagName === 'BUTTON' ||\n    element.tagName === 'A' ||\n    element.tagName === 'INPUT' ||\n    (tabIndex !== null && parseInt(tabIndex) >= 0)\n  )\n}\n\n// ============================================================================\n// Performance Testing Utilities\n// ============================================================================\n\n/**\n * Measure performance of a function\n */\nexport const measurePerformance = async function <TResult>(\n  fn: () => TResult | Promise<TResult>\n): Promise<{ result: TResult; duration: number }> {\n  const start = performance.now()\n  const result = await fn()\n  const end = performance.now()\n  const duration = end - start\n\n  return { result, duration }\n}", "metadata": {}}
